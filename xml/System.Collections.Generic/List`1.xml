<Type Name="List&lt;T&gt;" FullName="System.Collections.Generic.List&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d4017c7d6a84f5e8e60ad203744abe71325cd1f8" /><Meta Name="ms.sourcegitcommit" Value="9a6da88bd5455e8274257ca7ad259b42f1de114f" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="05/22/2019" /><Meta Name="ms.locfileid" Value="66007893" /></Metadata><TypeSignature Language="C#" Value="public class List&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IList&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.Generic.IReadOnlyList&lt;T&gt;, System.Collections.IList" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit List`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IList`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyList`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.List`1" />
  <TypeSignature Language="VB.NET" Value="Public Class List(Of T)&#xA;Implements ICollection(Of T), IEnumerable(Of T), IList, IList(Of T), IReadOnlyCollection(Of T), IReadOnlyList(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class List : System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IList&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::Generic::IReadOnlyList&lt;T&gt;, System::Collections::IList" />
  <TypeSignature Language="F#" Value="type List&lt;'T&gt; = class&#xA;    interface IList&lt;'T&gt;&#xA;    interface IList&#xA;    interface IReadOnlyList&lt;'T&gt;&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable&#xA;    interface ICollection&#xA;    interface IReadOnlyCollection&lt;'T&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_CollectionDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">列表中元素的类型。</typeparam>
    <summary>表示可通过索引访问的对象的强类型列表。 提供用于对列表进行搜索、排序和操作的方法。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>类是等效的泛型<xref:System.Collections.ArrayList>类。 它实现了<xref:System.Collections.Generic.IList%601>所需使用作为动态增加其大小的数组的泛型接口。  
  
 您可以将项添加到<xref:System.Collections.Generic.List%601>通过使用<xref:System.Collections.Generic.List%601.Add%2A>或<xref:System.Collections.Generic.List%601.AddRange%2A>方法。  
  
 <xref:System.Collections.Generic.List%601>类使用相等比较器和排序比较器。  
  
-   等方法<xref:System.Collections.Generic.List%601.Contains%2A>， <xref:System.Collections.Generic.List%601.IndexOf%2A>， <xref:System.Collections.Generic.List%601.LastIndexOf%2A>，和<xref:System.Collections.Generic.Dictionary%602.Remove%2A>列表元素使用相等比较器。 类型的默认相等比较器`T`确定，如下所示。 如果类型`T`实现<xref:System.IEquatable%601>泛型接口，则相等比较器是<xref:System.IEquatable%601.Equals%28%600%29>接口; 方法的默认相等比较器是为<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>。  
  
-   等方法<xref:System.Collections.Generic.List%601.BinarySearch%2A>和<xref:System.Collections.Generic.List%601.Sort%2A>排序比较器用于列表元素。 类型的默认比较器`T`确定，如下所示。  如果类型`T`实现<xref:System.IComparable%601>泛型接口，则默认比较器是<xref:System.IComparable%601.CompareTo%28%600%29>方法的接口; 否则为如果类型`T`实现非泛型<xref:System.IComparable>接口，则默认值比较器是<xref:System.IComparable.CompareTo%28System.Object%29>该接口的方法。 如果类型`T`实现两个接口，则没有默认比较器，必须显式提供的比较器或比较委托。  
  
 <xref:System.Collections.Generic.List%601>不保证排序。  您必须进行排序<xref:System.Collections.Generic.List%601>之前执行的操作 (如<xref:System.Collections.Generic.List%601.BinarySearch%2A>)，需要<xref:System.Collections.Generic.List%601>进行排序。  
  
 可以使用整数索引访问此集合中的元素。  在此集合中的索引都是从零开始的。  
  
 **仅限.NET framework:** 对于非常大<xref:System.Collections.Generic.List%601>对象，可以通过设置增加到 20 亿元素在 64 位系统上的最大容量`enabled`的属性[ `<gcAllowVeryLargeObjects>` ](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) configuration 元素`true`中运行时环境。  
  
 <xref:System.Collections.Generic.List%601> 接受`null`是有效的引用值类型以及允许重复的元素。  
  
 不可变版本<xref:System.Collections.Generic.List%601>类，请参阅<xref:System.Collections.Immutable.ImmutableList%601>。  
  
## <a name="performance-considerations"></a>性能注意事项  
 在决定是否使用<xref:System.Collections.Generic.List%601>或<xref:System.Collections.ArrayList>类，两者都具有类似的功能，请记住，<xref:System.Collections.Generic.List%601>类在大多数情况下更好地执行，并是类型安全的。 如果引用类型用于类型`T`的<xref:System.Collections.Generic.List%601>类，两个类的行为是完全相同。 但是，如果值类型用于类型`T`，您需要考虑实现和装箱问题。  
  
 如果值类型用于类型`T`，则编译器将生成的实现<xref:System.Collections.Generic.List%601>专门针对该值类型的类。 这意味着一个列表元素的<xref:System.Collections.Generic.List%601>对象不需要进行装箱前可以使用该元素，并且创建大约 500 个列表元素后保存未装箱列表元素的内存大于用来生成的类实现的内存。  
  
 确保用于类型的值类型`T`实现<xref:System.IEquatable%601>泛型接口。 如果不，等的方法<xref:System.Collections.Generic.List%601.Contains%2A>必须调用<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>框受影响的列表元素的方法。 如果值类型实现<xref:System.IComparable>接口，并且您拥有源代码，还实现<xref:System.IComparable%601>泛型接口，以防止<xref:System.Collections.Generic.List%601.BinarySearch%2A>和<xref:System.Collections.Generic.List%601.Sort%2A>中装箱列表元素的方法。 如果您不拥有的源代码，则传递<xref:System.Collections.Generic.IComparer%601>对象传递给<xref:System.Collections.Generic.List%601.BinarySearch%2A>和<xref:System.Collections.Generic.List%601.Sort%2A>方法  
  
 它是为您带来益处，若要使用的特定于类型的实现<xref:System.Collections.Generic.List%601>类而不是使用<xref:System.Collections.ArrayList>类或自己编写强类型化的包装集合。 原因是您的实现必须执行什么.NET 框架的用途，且公共语言运行时可以共享 Microsoft 中间语言代码和元数据，您的实现不能。  
  
## <a name="f-considerations"></a>F#注意事项  
 <xref:System.Collections.Generic.List%601>类用于不常在F#代码。 相反，[列出了](https://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d)，这是不可变、 单向链接列表，通常最好是。 F#列表提供有序的、 不可变的一系列值，并支持在函数式开发中使用。 通过F#，则<xref:System.Collections.Generic.List%601>类通常将按引用[ResizeArray\<不 >](https://msdn.microsoft.com/library/ee353447.aspx)类型缩写，以避免命名冲突与F#列出了  
  
   
  
## Examples  
 下面的示例演示如何添加、 删除和插入中的简单业务对象<xref:System.Collections.Generic.List%601>。  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 下面的示例演示一些属性和方法的<xref:System.Collections.Generic.List%601>字符串类型的泛型类。 (有关的示例<xref:System.Collections.Generic.List%601>复杂类型，请参阅<xref:System.Collections.Generic.List%601.Contains%2A>方法。)  
  
 默认构造函数用于具有默认容量创建字符串的列表。 <xref:System.Collections.Generic.List%601.Capacity%2A>显示属性，然后<xref:System.Collections.Generic.List%601.Add%2A>方法用于将添加多个项。 会列出项目，并<xref:System.Collections.Generic.List%601.Capacity%2A>属性显示同样，与<xref:System.Collections.Generic.List%601.Count%2A>属性，以显示根据需要是否增加容量。  
  
 <xref:System.Collections.Generic.List%601.Contains%2A>方法用于测试的列表中的项是否存在<xref:System.Collections.Generic.List%601.Insert%2A>方法用于插入新项中间列表中，然后再次显示列表的内容。  
  
 默认值<xref:System.Collections.Generic.List%601.Item%2A>使用属性 （C# 中为索引器） 来检索项，<xref:System.Collections.Generic.List%601.Remove%2A>方法用于删除重复项之前，添加的第一个实例，并再次显示内容。 <xref:System.Collections.Generic.List%601.Remove%2A>方法始终会删除它遇到的第一个实例。  
  
 <xref:System.Collections.Generic.List%601.TrimExcess%2A>方法用于减少容量以匹配计数，并<xref:System.Collections.Generic.List%601.Capacity%2A>和<xref:System.Collections.Generic.List%601.Count%2A>属性将显示。 如果未使用的容量小于 10%的总容量，列表将不具有已调整大小。  
  
 最后，<xref:System.Collections.Generic.List%601.Clear%2A>方法用于从列表中，删除所有项并<xref:System.Collections.Generic.List%601.Capacity%2A>和<xref:System.Collections.Generic.List%601.Count%2A>属性将显示。  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
    </remarks>
    <threadsafe>公共静态 (<see langword="Shared" />在 Visual Basic 中) 的此类型的成员是线程安全。 但不保证所有实例成员都是线程安全的。  
  
则可以安全地执行多个读取的操作<see cref="T:System.Collections.Generic.List`1" />，但如果在读取时修改该集合，可能会出现问题。 若要确保线程安全，读取期间锁定集合，或写操作。 若要启用集合由多个线程用于读取和写入访问，必须实现自己的同步。 使用内置同步集合，请参阅中的类<see cref="N:System.Collections.Concurrent" />命名空间。 本质上是线程安全的替代方法，请参阅<see cref="T:System.Collections.Immutable.ImmutableList`1" />类。</threadsafe>
    <altmember cref="T:System.Collections.IList" />
    <altmember cref="T:System.Collections.Immutable.ImmutableList`1" />
    <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">在集合中执行不区分区域性的字符串操作</related>
    <related type="Article" href="https://msdn.microsoft.com/library/f45331db-d595-46ec-9142-551d3d1eb1a7">迭代器（C# 和 Visual Basic）</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Collections.Generic.List`1" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Collections.Generic.List`1" /> 类的新实例，该实例为空并且具有默认初始容量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 容量<xref:System.Collections.Generic.List%601>是元素数目的<xref:System.Collections.Generic.List%601>可以容纳。 元素添加到<xref:System.Collections.Generic.List%601>，自动增加容量所要求的重新分配内部数组。  
  
 如果可以估计集合的大小，使用<xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29>构造函数和指定的初始容量消除了需要执行多个大小调整操作，同时将元素添加到<xref:System.Collections.Generic.List%601>。  
  
 可以通过调用减少容量<xref:System.Collections.Generic.List%601.TrimExcess%2A>方法或通过设置<xref:System.Collections.Generic.List%601.Capacity%2A>属性显式。 减少容量重新分配内存并将中的所有元素都复制<xref:System.Collections.Generic.List%601>。  
  
 此构造函数是 o （1） 操作。  
  
   
  
## Examples  
 下面的示例演示的默认构造函数<xref:System.Collections.Generic.List%601>泛型类。 默认构造函数创建列表，其中默认容量，如下所示通过显示<xref:System.Collections.Generic.List%601.Capacity%2A>属性。  
  
 该示例添加、 插入、 和移除项，显示如何容量更改使用这些方法。  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.List&lt;'T&gt; : seq&lt;'T&gt; -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="new System.Collections.Generic.List&lt;'T&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">一个集合，其元素被复制到新列表中。</param>
        <summary>初始化 <see cref="T:System.Collections.Generic.List`1" /> 类的新实例，该实例包含从指定集合复制的元素并且具有足够的容量来容纳所复制的元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将元素复制到<xref:System.Collections.Generic.List%601>读取集合的枚举器的顺序相同。  
  
 此构造函数是 O (*n*) 操作，其中*n*是中的元素数`collection`。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Collections.Generic.List%601.%23ctor%2A>构造函数和各种方法的<xref:System.Collections.Generic.List%601>对范围进行操作的类。 创建一个字符串数组并将其传递给构造函数中，填充数组的元素列表。 <xref:System.Collections.Generic.List%601.Capacity%2A>属性然后会显示，显示的初始容量正好就是需要输入的元素。  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.List&lt;'T&gt; : int -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="new System.Collections.Generic.List&lt;'T&gt; capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">新列表最初可以存储的元素数。</param>
        <summary>初始化 <see cref="T:System.Collections.Generic.List`1" /> 类的新实例，该实例为空并且具有指定的初始容量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 容量<xref:System.Collections.Generic.List%601>是元素数目的<xref:System.Collections.Generic.List%601>可以容纳。 元素添加到<xref:System.Collections.Generic.List%601>，自动增加容量所要求的重新分配内部数组。  
  
 如果可以估计集合的大小，指定的初始容量，则无需要执行多个大小调整操作，同时将元素添加到<xref:System.Collections.Generic.List%601>。  
  
 可以通过调用减少容量<xref:System.Collections.Generic.List%601.TrimExcess%2A>方法或通过设置<xref:System.Collections.Generic.List%601.Capacity%2A>属性显式。 减少容量重新分配内存并将中的所有元素都复制<xref:System.Collections.Generic.List%601>。  
  
 此构造函数是 O (*n*) 操作，其中*n*是`capacity`。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29>构造函数。 一个<xref:System.Collections.Generic.List%601>的容量为 4 的字符串创建，因为列表的最终大小已知恰好为 4。 列表中填充了四个字符串，并且通过使用创建的只读副本<xref:System.Collections.Generic.List%601.AsReadOnly%2A>方法。  
  
 [!code-cpp[List\`1_AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp#1)]
 [!code-csharp[List\`1_AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs#1)]
 [!code-vb[List\`1_AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> 小于 0。</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(T item);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'T -&gt; unit&#xA;override this.Add : 'T -&gt; unit" Usage="list.Add item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">要添加到 <see cref="T:System.Collections.Generic.List`1" /> 末尾的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <summary>将对象添加到 <see cref="T:System.Collections.Generic.List`1" /> 的结尾处。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 接受`null`是有效的引用值类型以及允许重复的元素。  
  
 如果<xref:System.Collections.Generic.List%601.Count%2A>已等于<xref:System.Collections.Generic.List%601.Capacity%2A>，则容量的<xref:System.Collections.Generic.List%601>自动重新分配内部数组中，增加和现有元素之前添加新元素将复制到新数组。  
  
 如果<xref:System.Collections.Generic.List%601.Count%2A>是小于<xref:System.Collections.Generic.List%601.Capacity%2A>，此方法为 o （1） 运算。 如果需要增加以容纳新元素的容量，此方法将成为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示如何添加、 删除和插入中的简单业务对象<xref:System.Collections.Generic.List%601>。  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 下面的示例演示几个属性和方法<xref:System.Collections.Generic.List%601>泛型类，其中包括<xref:System.Collections.Generic.List%601.Add%2A>方法。 默认构造函数用于创建字符串列表的容量为 0。 <xref:System.Collections.Generic.List%601.Capacity%2A>显示属性，然后<xref:System.Collections.Generic.List%601.Add%2A>方法用于将添加多个项。 会列出项目，并<xref:System.Collections.Generic.List%601.Capacity%2A>属性显示同样，与<xref:System.Collections.Generic.List%601.Count%2A>属性，以显示根据需要是否增加容量。  
  
 其他属性和方法用于搜索、 插入和删除元素从列表中，最后以清除列表。  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="member this.AddRange : seq&lt;'T&gt; -&gt; unit" Usage="list.AddRange collection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">一个集合，其元素应被添加到 <see cref="T:System.Collections.Generic.List`1" /> 的末尾。 集合自身不能为 <see langword="null" />，但它可以包含为 <see langword="null" /> 的元素（如果类型 <paramref name="T" /> 为引用类型）。</param>
        <summary>将指定集合的元素添加到 <see cref="T:System.Collections.Generic.List`1" /> 的末尾。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 集合中元素的顺序将保留在<xref:System.Collections.Generic.List%601>。  
  
 如果新<xref:System.Collections.Generic.List%601.Count%2A>(当前<xref:System.Collections.Generic.List%601.Count%2A>plus 集合的大小) 将大于<xref:System.Collections.Generic.List%601.Capacity%2A>，则容量的<xref:System.Collections.Generic.List%601>增加通过自动重新分配要容纳新元素的内部数组和之前添加新元素，现有元素将复制到新数组。  
  
 如果<xref:System.Collections.Generic.List%601>可以容纳新元素而不增加<xref:System.Collections.Generic.List%601.Capacity%2A>，此方法为 O (*n*) 操作，其中*n*是要添加的元素数。 如果需要增加以容纳新元素的容量，此方法将成为 O (*n* + *m*) 操作，其中*n*是元素的数目要添加并*m*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Collections.Generic.List%601.AddRange%2A>方法和各种其他方法的<xref:System.Collections.Generic.List%601>对范围进行操作的类。 创建一个字符串数组并将其传递给构造函数中，填充数组的元素列表。 <xref:System.Collections.Generic.List%601.AddRange%2A>调用方法时，与作为其参数列表。 结果是列表的当前元素添加到列表中，复制所有元素的末尾。  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="AsReadOnly">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!T&gt; AsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Function AsReadOnly () As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly();" />
      <MemberSignature Language="F#" Value="member this.AsReadOnly : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;" Usage="list.AsReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回当前集合的只读 <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> 包装器。</summary>
        <returns>一个对象，作为围绕当前 <see cref="T:System.Collections.Generic.List`1" /> 的只读包装器。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要防止对进行任何修改<xref:System.Collections.Generic.List%601>对象，将其公开只能通过此包装器。 一个<xref:System.Collections.ObjectModel.ReadOnlyCollection%601>对象未公开修改集合的方法。 但是，如果对更改基础<xref:System.Collections.Generic.List%601>对象，只读集合反映这些更改。  
  
 此方法为 o （1） 运算。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Collections.Generic.List%601.AsReadOnly%2A>方法。 一个<xref:System.Collections.Generic.List%601>的容量为 4 的字符串创建，因为列表的最终大小已知恰好为 4。 列表中填充了四个字符串，并<xref:System.Collections.Generic.List%601.AsReadOnly%2A>方法用于获取一个只读的<xref:System.Collections.Generic.IList%601>包装原始列表的泛型接口实现。  
  
 原始列表的元素设置为"Coelophysis"使用<xref:System.Collections.Generic.List%601.Item%2A>属性 （索引器在 C# 中），只读列表的内容将显示和再次以证明它只是原始列表的包装器。  
  
 [!code-cpp[List\`1_AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp#1)]
 [!code-csharp[List\`1_AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs#1)]
 [!code-vb[List\`1_AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使用对分检索算法在已排序的 <see cref="T:System.Collections.Generic.List`1" /> 或它的一部分中查找特定元素。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(T item);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : 'T -&gt; int" Usage="list.BinarySearch item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">要定位的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <summary>使用默认的比较器在整个已排序的 <see cref="T:System.Collections.Generic.List`1" /> 中搜索元素，并返回该元素从零开始的索引。</summary>
        <returns>如果找到 <paramref name="item" />，则为已排序的 <see cref="T:System.Collections.Generic.List`1" /> 中 <paramref name="item" /> 的从零开始的索引；否则为一个负数，该负数是大于 <paramref name="item" /> 的下一个元素的索引的按位求补。如果没有更大的元素，则为 <see cref="P:System.Collections.Generic.List`1.Count" /> 的按位求补。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用默认比较器<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>类型`T`以确定列表元素的顺序。 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>属性检查是否类型`T`实现<xref:System.IComparable%601>泛型接口，并使用该实现，如果可用。  如果不是，<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>检查是否类型`T`实现<xref:System.IComparable>接口。  如果类型`T`不实现任何一个接口，<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>引发<xref:System.InvalidOperationException>。  
  
 <xref:System.Collections.Generic.List%601>必须已排序根据比较器实现中; 否则，结果是不正确。  
  
 比较`null`与任何引用类型允许和不会生成异常时使用<xref:System.IComparable%601>泛型接口。 排序时，`null`被视为小于任何其他对象。  
  
 如果<xref:System.Collections.Generic.List%601>多个元素具有相同的值，该方法将返回只包含其中一个匹配项，并且它可能会返回任何一个匹配项，不一定是第一个。  
  
 如果<xref:System.Collections.Generic.List%601>不包含指定的值，该方法返回一个负整数。 您可以应用于此负整数，以获取大于搜索值的第一个元素的索引的按位求补运算 （~）。 当将值插入到<xref:System.Collections.Generic.List%601>，此索引应使用作为插入点，以保持排序顺序。  
  
 此方法为 O (log *n*) 操作，其中*n*是范围中的元素数。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Collections.Generic.List%601.Sort>方法重载和<xref:System.Collections.Generic.List%601.BinarySearch%28%600%29>方法重载。 一个<xref:System.Collections.Generic.List%601>的字符串创建并填充了四个字符串，顺序不分先后。 显示、 排序，列表，并再次显示。  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29>然后使用方法重载的两个字符串的不是在列表中，搜索和<xref:System.Collections.Generic.List%601.Insert%2A>方法用于将它们插入。 返回值<xref:System.Collections.Generic.List%601.BinarySearch%28%600%29>方法为负每种情况下，因为字符串不是在列表中。 执行按位求补 (~ 运算符在C#和 Visual C++，`Xor`在 Visual Basic 中的为-1) 此负数值的生成大于搜索字符串，并将在此位置中的列表中的第一个元素的索引保留排序顺序。 第二个搜索字符串是大于在列表中，任何元素，因此在列表的末尾处的插入位置。  
  
 [!code-cpp[List\`1_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此默认比较器 <see cref="P:System.Collections.Generic.Comparer`1.Default" /> 无法找到 <see cref="T:System.IComparable`1" /> 泛型接口或类型为 <paramref name="T" /> 的 <see cref="T:System.IComparable" /> 接口的实现。</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (item As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(T item, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="list.BinarySearch (item, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="item">要定位的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 实现。  
  
- 或 - 
 如果使用默认比较器 <see cref="P:System.Collections.Generic.Comparer`1.Default" />，则为 <see langword="null" />。</param>
        <summary>使用指定的比较器在整个已排序的 <see cref="T:System.Collections.Generic.List`1" /> 中搜索元素，并返回该元素从零开始的索引。</summary>
        <returns>如果找到 <paramref name="item" />，则为已排序的 <see cref="T:System.Collections.Generic.List`1" /> 中 <paramref name="item" /> 的从零开始的索引；否则为一个负数，该负数是大于 <paramref name="item" /> 的下一个元素的索引的按位求补。如果没有更大的元素，则为 <see cref="P:System.Collections.Generic.List`1.Count" /> 的按位求补。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比较器自定义对元素进行比较。 例如，可以使用<xref:System.Collections.CaseInsensitiveComparer>作为要执行不区分大小写的字符串搜索的比较器的实例。  
  
 如果`comparer`提供的元素<xref:System.Collections.Generic.List%601>为指定的值使用指定比较<xref:System.Collections.Generic.IComparer%601>实现。  
  
 如果`comparer`是`null`，默认比较器<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>检查是否类型`T`实现<xref:System.IComparable%601>泛型接口，并使用该实现，如果可用。  如果不是，<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>检查是否类型`T`实现<xref:System.IComparable>接口。  如果类型`T`不实现任何一个接口，<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>引发<xref:System.InvalidOperationException>。  
  
 <xref:System.Collections.Generic.List%601>必须已排序根据比较器实现中; 否则，结果是不正确。  
  
 比较`null`与任何引用类型允许和不会生成异常时使用<xref:System.IComparable%601>泛型接口。 排序时，`null`被视为小于任何其他对象。  
  
 如果<xref:System.Collections.Generic.List%601>多个元素具有相同的值，该方法将返回只包含其中一个匹配项，并且它可能会返回任何一个匹配项，不一定是第一个。  
  
 如果<xref:System.Collections.Generic.List%601>不包含指定的值，该方法返回一个负整数。 您可以应用于此负整数，以获取大于搜索值的第一个元素的索引的按位求补运算 （~）。 当将值插入到<xref:System.Collections.Generic.List%601>，此索引应使用作为插入点，以保持排序顺序。  
  
 此方法为 O (log *n*) 操作，其中*n*是范围中的元素数。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29>方法重载和<xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>方法重载。  
  
 该示例定义名为 DinoCompare，实现的字符串将替代比较器`IComparer<string>`(`IComparer(Of String)`在 Visual Basic`IComparer<String^>`视觉对象中C++) 泛型接口。 比较器的工作方式如下：首先，测试比较数是否为`null`，并为 null 引用被视为小于非空。 其次，比较字符串长度，并更长的字符串被认为更高版本。 第三，如果长度相等，则使用常规字符串比较。  
  
 一个<xref:System.Collections.Generic.List%601>的字符串创建并填充了四个字符串，顺序不分先后。 列表、 排序使用备用的比较器，并显示再次显示。  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>方法重载然后用于搜索将不在列表中，该示例使用的多个字符串。 <xref:System.Collections.Generic.List%601.Insert%2A>方法用来插入字符串。 这两种方法都位于名为的函数`SearchAndInsert`，以及代码执行按位求补 (~ 运算符在C#和 Visual C++，`Xor`在 Visual Basic 中的为-1) 返回负号<xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>并将其用作插入的新字符串的索引。  
  
 [!code-cpp[List\`1_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> 为 <see langword="null" />，并且默认比较器 <see cref="P:System.Collections.Generic.Comparer`1.Default" /> 找不到 <see cref="T:System.IComparable`1" /> 泛型接口或类型为 <paramref name="T" /> 的 <see cref="T:System.IComparable" /> 接口的实现。</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (int index, int count, T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(int32 index, int32 count, !T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (index As Integer, count As Integer, item As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(int index, int count, T item, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : int * int * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="list.BinarySearch (index, count, item, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">要搜索范围的从零开始的起始索引。</param>
        <param name="count">要搜索的范围的长度。</param>
        <param name="item">要定位的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 实现，若要使用默认比较器 <see cref="P:System.Collections.Generic.Comparer`1.Default" />，则为 <see langword="null" />。</param>
        <summary>使用指定的比较器在已排序 <see cref="T:System.Collections.Generic.List`1" /> 的某个元素范围中搜索元素，并返回该元素从零开始的索引。</summary>
        <returns>如果找到 <paramref name="item" />，则为已排序的 <see cref="T:System.Collections.Generic.List`1" /> 中 <paramref name="item" /> 的从零开始的索引；否则为一个负数，该负数是大于 <paramref name="item" /> 的下一个元素的索引的按位求补。如果没有更大的元素，则为 <see cref="P:System.Collections.Generic.List`1.Count" /> 的按位求补。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比较器自定义对元素进行比较。 例如，可以使用<xref:System.Collections.CaseInsensitiveComparer>作为要执行不区分大小写的字符串搜索的比较器的实例。  
  
 如果`comparer`提供的元素<xref:System.Collections.Generic.List%601>为指定的值使用指定比较<xref:System.Collections.Generic.IComparer%601>实现。  
  
 如果`comparer`是`null`，默认比较器<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>检查是否类型`T`实现<xref:System.IComparable%601>泛型接口，并使用该实现，如果可用。  如果不是，<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>检查是否类型`T`实现<xref:System.IComparable>接口。  如果类型`T`不实现任何一个接口，<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>引发<xref:System.InvalidOperationException>。  
  
 <xref:System.Collections.Generic.List%601>必须已排序根据比较器实现中; 否则，结果是不正确。  
  
 比较`null`与任何引用类型允许和不会生成异常时使用<xref:System.IComparable%601>泛型接口。 排序时，`null`被视为小于任何其他对象。  
  
 如果<xref:System.Collections.Generic.List%601>多个元素具有相同的值，该方法将返回只包含其中一个匹配项，并且它可能会返回任何一个匹配项，不一定是第一个。  
  
 如果<xref:System.Collections.Generic.List%601>不包含指定的值，该方法返回一个负整数。 您可以应用于此负整数，以获取大于搜索值的第一个元素的索引的按位求补运算 （~）。 当将值插入到<xref:System.Collections.Generic.List%601>，此索引应使用作为插入点，以保持排序顺序。  
  
 此方法为 O (log *n*) 操作，其中*n*是范围中的元素数。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>方法重载和<xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>方法重载。  
  
 该示例定义名为 DinoCompare，实现的字符串将替代比较器`IComparer<string>`(`IComparer(Of String)`在 Visual Basic`IComparer<String^>`视觉对象中C++) 泛型接口。 比较器的工作方式如下：首先，测试比较数是否为`null`，并为 null 引用被视为小于非空。 其次，比较字符串长度，并更长的字符串被认为更高版本。 第三，如果长度相等，则使用常规字符串比较。  
  
 一个<xref:System.Collections.Generic.List%601>的字符串创建并填充一个和示例的名称。 在两个组中，名称不按任何特定的排序顺序。 显示的列表，使用备用的比较器排序该，并再次显示列表。  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>方法重载然后用于搜索"Brachiosaurus"仅草食范围。 找不到字符串，并按位求补 (~ 中的运算符C#和 Visual C++，`Xor`在 Visual Basic 中的为-1) 返回负号<xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>方法用于插入新的字符串用作索引。  
  
 [!code-cpp[List\`1_SortSearchComparerRange#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparerRange#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparerRange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 0。  
  
- 或 - 
 <paramref name="count" /> 小于 0。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 和 <paramref name="count" /> 不表示 <see cref="T:System.Collections.Generic.List`1" /> 中的有效范围。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> 为 <see langword="null" />，并且默认比较器 <see cref="P:System.Collections.Generic.Comparer`1.Default" /> 找不到 <see cref="T:System.IComparable`1" /> 泛型接口或类型为 <paramref name="T" /> 的 <see cref="T:System.IComparable" /> 接口的实现。</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Collections.Generic.List&lt;'T&gt;.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置该内部数据结构在不调整大小的情况下能够容纳的元素总数。</summary>
        <value>在需要调整大小之前 <see cref="T:System.Collections.Generic.List`1" /> 能够容纳的元素的数目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A> 是的元素数的<xref:System.Collections.Generic.List%601>可以存储之前调整大小是必需的而<xref:System.Collections.Generic.List%601.Count%2A>是中的实际的元素数目<xref:System.Collections.Generic.List%601>。  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> 始终是大于或等于<xref:System.Collections.Generic.List%601.Count%2A>。 如果<xref:System.Collections.Generic.List%601.Count%2A>超出了<xref:System.Collections.Generic.List%601.Capacity%2A>时添加元素，通过在复制旧元素和添加新元素之前自动重新分配内部数组增加容量。  
  
 如果容量显著大于计数，并且你想要减少使用的内存<xref:System.Collections.Generic.List%601>，可以通过调用减少容量<xref:System.Collections.Generic.List%601.TrimExcess%2A>方法或通过设置<xref:System.Collections.Generic.List%601.Capacity%2A>显式为较低值的属性。 时的值<xref:System.Collections.Generic.List%601.Capacity%2A>设置显式，内部数组还重新分配以适应指定的容量，并复制所有元素。  
  
 检索此属性的值是 o （1） 的操作;将属性设置为 O (*n*) 操作，其中*n*新容量。  
  
   
  
## Examples  
 下面的示例演示如何检查的容量和计数<xref:System.Collections.Generic.List%601>，其中包含简单的业务对象，说明了如何使用<xref:System.Collections.Generic.List%601.TrimExcess%2A>方法以删除额外的容量。  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 下面的示例演示<xref:System.Collections.Generic.List%601.Capacity%2A>在列表的生命周期中的多个位置的属性。 默认构造函数使用的容量为 0，创建一个字符串列表和<xref:System.Collections.Generic.List%601.Capacity%2A>属性显示为了说明这一点。 之后<xref:System.Collections.Generic.List%601.Add%2A>方法已用于添加多个项，会列出项目，然后<xref:System.Collections.Generic.List%601.Capacity%2A>属性显示同样，与<xref:System.Collections.Generic.List%601.Count%2A>属性，以显示根据需要是否增加容量。  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A>属性显示后再次<xref:System.Collections.Generic.List%601.TrimExcess%2A>方法用于减少容量以匹配计数。 最后，<xref:System.Collections.Generic.List%601.Clear%2A>方法用于从列表中，删除所有项并<xref:System.Collections.Generic.List%601.Capacity%2A>和<xref:System.Collections.Generic.List%601.Count%2A>再次显示属性。  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Collections.Generic.List`1.Capacity" /> 已设置为一个小于 <see cref="P:System.Collections.Generic.List`1.Count" /> 的值。</exception>
        <exception cref="T:System.OutOfMemoryException">系统上没有足够的可用内存。</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="list.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从 <see cref="T:System.Collections.Generic.List`1" /> 中移除所有元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Count%2A> 设置为 0，并且对其他对象的集合的元素也被释放。  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> 保持不变。 若要重置的容量<xref:System.Collections.Generic.List%601>，调用<xref:System.Collections.Generic.List%601.TrimExcess%2A>方法或一组<xref:System.Collections.Generic.List%601.Capacity%2A>直接属性。 减少容量重新分配内存并将中的所有元素都复制<xref:System.Collections.Generic.List%601>。 截去空<xref:System.Collections.Generic.List%601>的容量设置<xref:System.Collections.Generic.List%601>到默认容量。  
  
 此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Collections.Generic.List%601.Clear%2A>方法和各种其他属性和方法的<xref:System.Collections.Generic.List%601>泛型类。 <xref:System.Collections.Generic.List%601.Clear%2A>方法的末尾程序，使用从列表中，删除所有项并<xref:System.Collections.Generic.List%601.Capacity%2A>和<xref:System.Collections.Generic.List%601.Count%2A>然后显示属性。  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.TrimExcess" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(T item);" />
      <MemberSignature Language="F#" Value="abstract member Contains : 'T -&gt; bool&#xA;override this.Contains : 'T -&gt; bool" Usage="list.Contains item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">要在 <see cref="T:System.Collections.Generic.List`1" /> 中定位的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <summary>确定某元素是否在 <see cref="T:System.Collections.Generic.List`1" /> 中。</summary>
        <returns>如果在 <see langword="true" /> 中找到 <paramref name="item" />，则为 <see cref="T:System.Collections.Generic.List`1" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法通过使用默认的相等性比较器，来确定相等性，定义的对象的实现<xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType>方法`T`（列表中的值类型）。  
  
 此方法执行线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Collections.Generic.List%601.Contains%2A>并<xref:System.Collections.Generic.List%601.Exists%2A>上的方法<xref:System.Collections.Generic.List%601>，其中包含实现的简单业务对象<xref:System.IEquatable%601.Equals%2A>。  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 下面的示例包含一系列类型的复杂对象`Cube`。 `Cube`类实现<xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType>方法，以便两个多维数据集被视为相等，如果其维度相同。 在此示例中，<xref:System.Collections.Generic.List%601.Contains%2A>方法将返回`true`，因为具有指定的维度的多维数据集已在集合中。  
  
 [!code-csharp[System.Collections.Generic.List.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.contains/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.contains/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;TOutput&gt; ConvertAll&lt;TOutput&gt; (Converter&lt;T,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!!TOutput&gt; ConvertAll&lt;TOutput&gt;(class System.Converter`2&lt;!T, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertAll(Of TOutput) (converter As Converter(Of T, TOutput)) As List(Of TOutput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA; System::Collections::Generic::List&lt;TOutput&gt; ^ ConvertAll(Converter&lt;T, TOutput&gt; ^ converter);" />
      <MemberSignature Language="F#" Value="member this.ConvertAll : Converter&lt;'T, 'Output&gt; -&gt; System.Collections.Generic.List&lt;'Output&gt;" Usage="list.ConvertAll converter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="converter" Type="System.Converter&lt;T,TOutput&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">目标数组元素的类型。</typeparam>
        <param name="converter">一个 <see cref="T:System.Converter`2" /> 委托，可将每个元素从一种类型转换为另一种类型。</param>
        <summary>将当前 <see cref="T:System.Collections.Generic.List`1" /> 中的元素转换为另一种类型，并返回包含已转换元素的列表。</summary>
        <returns>目标类型的 <see cref="T:System.Collections.Generic.List`1" />，包含当前 <see cref="T:System.Collections.Generic.List`1" /> 中转换后的元素。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Converter%602>是一个委托，将对象转换为目标类型的方法。  当前元素<xref:System.Collections.Generic.List%601>逐个传递给<xref:System.Converter%602>委托，并且转换后的元素将保存在新<xref:System.Collections.Generic.List%601>。  
  
 当前<xref:System.Collections.Generic.List%601>保持不变。  
  
 此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例定义一个名为方法`PointFToPoint`，用于将<xref:System.Drawing.PointF>结构<xref:System.Drawing.Point>结构。 该示例然后创建<xref:System.Collections.Generic.List%601>的<xref:System.Drawing.PointF>结构，则创建`Converter\<PointF, Point>`委托 (`Converter(Of PointF, Point)`在 Visual Basic 中) 来表示`PointFToPoint`方法，并将传递到委托<xref:System.Collections.Generic.List%601.ConvertAll%2A>方法。 <xref:System.Collections.Generic.List%601.ConvertAll%2A>方法将传递到输入列表的每个元素`PointFToPoint`方法并将转换后的元素放入新的列表<xref:System.Drawing.Point>结构。 显示这两个列表。  
  
 [!code-cpp[List\`1_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[List\`1_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_ConvertAll/cs/source.cs#1)]
 [!code-vb[List\`1_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="converter" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将 <see cref="T:System.Collections.Generic.List`1" /> 或它的一部分复制到一个数组中。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] -&gt; unit" Usage="list.CopyTo array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array">一维 <see cref="T:System.Array" />，它是从 <see cref="T:System.Collections.Generic.List`1" /> 复制的元素的目标。 <see cref="T:System.Array" /> 必须具有从零开始的索引。</param>
        <summary>将整个 <see cref="T:System.Collections.Generic.List`1" /> 复制到兼容的一维数组中，从目标数组的开头开始放置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用<xref:System.Array.Copy%2A?displayProperty=nameWithType>元素将复制到。  
  
 将元素复制到<xref:System.Array>枚举器循环访问的相同顺序<xref:System.Collections.Generic.List%601>。  
  
 此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示的所有三个重载<xref:System.Collections.Generic.List%601.CopyTo%2A>方法。 一个<xref:System.Collections.Generic.List%601>的字符串创建并填充了 5 个字符串。 创建一个空字符串数组的 15 个元素，并<xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29>方法重载用于将列表的所有元素都复制到数组的第一个元素开始的数组。 <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29>方法重载用于复制的所有元素的数组索引 6 开始的数组到列表 （将索引 5 留为空）。 最后，<xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>使用方法重载来复制从列表中，索引 2 开始的 3 个元素，使用到开始数组的数组索引 12 （将索引 11 留为空）。 然后显示数组的内容。  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">源 <see cref="T:System.Collections.Generic.List`1" /> 中的元素个数大于目标 <paramref name="array" /> 可以包含的元素个数。</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : 'T[] * int -&gt; unit&#xA;override this.CopyTo : 'T[] * int -&gt; unit" Usage="list.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">一维 <see cref="T:System.Array" />，它是从 <see cref="T:System.Collections.Generic.List`1" /> 复制的元素的目标。 <see cref="T:System.Array" /> 必须具有从零开始的索引。</param>
        <param name="arrayIndex"><paramref name="array" /> 中从零开始的索引，从此处开始复制。</param>
        <summary>从目标数组的指定索引处开始，将整个 <see cref="T:System.Collections.Generic.List`1" /> 复制到兼容的一维数组。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用<xref:System.Array.Copy%2A?displayProperty=nameWithType>元素将复制到。  
  
 将元素复制到<xref:System.Array>枚举器循环访问的相同顺序<xref:System.Collections.Generic.List%601>。  
  
 此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示的所有三个重载<xref:System.Collections.Generic.List%601.CopyTo%2A>方法。 一个<xref:System.Collections.Generic.List%601>的字符串创建并填充了 5 个字符串。 创建一个空字符串数组的 15 个元素，并<xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29>方法重载用于将列表的所有元素都复制到数组的第一个元素开始的数组。 <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29>方法重载用于复制的所有元素的数组索引 6 开始的数组到列表 （将索引 5 留为空）。 最后，<xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>使用方法重载来复制从列表中，索引 2 开始的 3 个元素，使用到开始数组的数组索引 12 （将索引 11 留为空）。 然后显示数组的内容。  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" /> 小于 0。</exception>
        <exception cref="T:System.ArgumentException">源 <see cref="T:System.Collections.Generic.List`1" /> 中的元素个数大于从 <paramref name="arrayIndex" /> 到目标 <paramref name="array" /> 末尾之间的可用空间。</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int index, T[] array, int arrayIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 index, !T[] array, int32 arrayIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (index As Integer, array As T(), arrayIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int index, cli::array &lt;T&gt; ^ array, int arrayIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * 'T[] * int * int -&gt; unit" Usage="list.CopyTo (index, array, arrayIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">复制即从源 <see cref="T:System.Collections.Generic.List`1" /> 中从零开始的索引开始。</param>
        <param name="array">一维 <see cref="T:System.Array" />，它是从 <see cref="T:System.Collections.Generic.List`1" /> 复制的元素的目标。 <see cref="T:System.Array" /> 必须具有从零开始的索引。</param>
        <param name="arrayIndex"><paramref name="array" /> 中从零开始的索引，从此处开始复制。</param>
        <param name="count">要复制的元素数。</param>
        <summary>将一定范围的元素从 <see cref="T:System.Collections.Generic.List`1" /> 复制到兼容的一维数组中，从目标数组的指定索引位置开始放置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用<xref:System.Array.Copy%2A?displayProperty=nameWithType>元素将复制到。  
  
 将元素复制到<xref:System.Array>枚举器循环访问的相同顺序<xref:System.Collections.Generic.List%601>。  
  
 此方法为 O (*n*) 操作，其中*n*是`count`。  
  
   
  
## Examples  
 下面的示例演示的所有三个重载<xref:System.Collections.Generic.List%601.CopyTo%2A>方法。 一个<xref:System.Collections.Generic.List%601>的字符串创建并填充了 5 个字符串。 创建一个空字符串数组的 15 个元素，并<xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29>方法重载用于将列表的所有元素都复制到数组的第一个元素开始的数组。 <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29>方法重载用于复制的所有元素的数组索引 6 开始的数组到列表 （将索引 5 留为空）。 最后，<xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>使用方法重载来复制从列表中，索引 2 开始的 3 个元素，使用到开始数组的数组索引 12 （将索引 11 留为空）。 然后显示数组的内容。  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 0。  
  
- 或 - 
 <paramref name="arrayIndex" /> 小于 0。  
  
- 或 - 
 <paramref name="count" /> 小于 0。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 等于或大于源 <see cref="T:System.Collections.Generic.List`1" /> 的 <see cref="P:System.Collections.Generic.List`1.Count" />。  
  
- 或 - 
从 <paramref name="index" /> 到源 <see cref="T:System.Collections.Generic.List`1" /> 的末尾的元素数大于从 <paramref name="arrayIndex" /> 到目标 <paramref name="array" /> 的末尾的可用空间。</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.List&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Collections.Generic.List`1" /> 中包含的元素数。</summary>
        <value><see cref="T:System.Collections.Generic.List`1" /> 中包含的元素数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A> 是的元素数的<xref:System.Collections.Generic.List%601>需要调整大小之前可以存储。 <xref:System.Collections.Generic.List%601.Count%2A> 是中的实际的元素数目<xref:System.Collections.Generic.List%601>。  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> 始终是大于或等于<xref:System.Collections.Generic.List%601.Count%2A>。 如果<xref:System.Collections.Generic.List%601.Count%2A>超出了<xref:System.Collections.Generic.List%601.Capacity%2A>时添加元素，通过在复制旧元素和添加新元素之前自动重新分配内部数组增加容量。  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
   
  
## Examples  
 下面的示例演示如何检查的容量和计数<xref:System.Collections.Generic.List%601>，其中包含简单的业务对象，说明了如何使用<xref:System.Collections.Generic.List%601.TrimExcess%2A>方法以删除额外的容量。  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 下面的示例显示的值<xref:System.Collections.Generic.List%601.Count%2A>生命周期的列表的不同位置的属性。 创建和填充列表并显示它的元素后,<xref:System.Collections.Generic.List%601.Capacity%2A>和<xref:System.Collections.Generic.List%601.Count%2A>属性将显示。 这些属性将显示后再次<xref:System.Collections.Generic.List%601.TrimExcess%2A>方法已被清除被调用，并在列表的内容后再次。  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public bool Exists (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Exists(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Exists (match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Exists(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.Exists : Predicate&lt;'T&gt; -&gt; bool" Usage="list.Exists match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match"><see cref="T:System.Predicate`1" /> 委托，用于定义要搜索的元素应满足的条件。</param>
        <summary>确定 <see cref="T:System.Collections.Generic.List`1" /> 是否包含与指定谓词所定义的条件相匹配的元素。</summary>
        <returns>如果 <see cref="T:System.Collections.Generic.List`1" /> 包含一个或多个与指定谓词所定义的条件相匹配的元素，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>是返回的方法的委托`true`如果该对象传递给委托中定义的条件匹配。  当前元素<xref:System.Collections.Generic.List%601>逐个传递给<xref:System.Predicate%601>委托，然后处理已停止时找到匹配项。  
  
 此方法执行线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Collections.Generic.List%601.Contains%2A>并<xref:System.Collections.Generic.List%601.Exists%2A>上的方法<xref:System.Collections.Generic.List%601>，其中包含实现的简单业务对象<xref:System.IEquatable%601.Equals%2A>。  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 下面的示例演示<xref:System.Collections.Generic.List%601.Exists%2A>方法和其他几种方法使用<xref:System.Predicate%601>泛型委托。  
  
 一个<xref:System.Collections.Generic.List%601>的字符串创建，包含 8 个恐龙名称，其中 （位于位置 1 和 5） 两个以"saurus"结尾。 该示例还定义一个名为搜索谓词的方法`EndsWithSaurus`、，它接受字符串参数和返回一个布尔值，该值指示是否以"saurus"结尾的输入的字符串。  
  
 <xref:System.Collections.Generic.List%601.Find%2A>， <xref:System.Collections.Generic.List%601.FindLast%2A>，并<xref:System.Collections.Generic.List%601.FindAll%2A>方法用于在列表中搜索与搜索谓词方法，然后<xref:System.Collections.Generic.List%601.RemoveAll%2A>方法用于删除以"saurus"结尾的所有项。  
  
 最后，<xref:System.Collections.Generic.List%601.Exists%2A>调用方法。 它从开始时，将每个元素传递给反过来将遍历列表`EndsWithSaurus`方法。 搜索停止，并且该方法返回`true`如果`EndsWithSaurus`方法将返回`true`的任何元素。 <xref:System.Collections.Generic.List%601.Exists%2A>方法将返回`false`因为已删除所有此类元素。  
  
> [!NOTE]
>  在 C# 和 Visual Basic 中，它不需要创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中) 显式。 这些语言推断从上下文正确的委托，并自动创建。  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public T Find (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Find(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Find(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.Find : Predicate&lt;'T&gt; -&gt; 'T" Usage="list.Find match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match"><see cref="T:System.Predicate`1" /> 委托，用于定义要搜索的元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，并返回整个 <see cref="T:System.Collections.Generic.List`1" /> 中的第一个匹配元素。</summary>
        <returns>如果找到与指定谓词定义的条件匹配的第一个元素，则为该元素；否则为类型 <paramref name="T" /> 的默认值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>是返回的方法的委托`true`如果该对象传递给委托中定义的条件匹配。  当前元素<xref:System.Collections.Generic.List%601>逐个传递给<xref:System.Predicate%601>委托，在中向前移动<xref:System.Collections.Generic.List%601>，从第一个元素开始和结束的最后一个元素。  当找到匹配项时，停止处理。  
  
> [!IMPORTANT]
>  在搜索时包含值类型的列表，请确保该类型的默认值不满足搜索谓词。 否则，没有任何方式来区分一个默认值，该值指示已找到任何匹配项和一个列表元素，它恰好有类型的默认值。 如果默认值满足搜索谓词，则使用<xref:System.Collections.Generic.List%601.FindIndex%2A>方法相反。  
  
 此方法执行线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 以下示例演示包含简单上下文对象的 <xref:System.Collections.Generic.List%601.Find%2A> 上的 <xref:System.Collections.Generic.List%601> 方法。  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 下面的示例演示的查找方法<xref:System.Collections.Generic.List%601>类。 有关示例<xref:System.Collections.Generic.List%601>类包含`book`类的对象`Book`，使用的数据进行[示例 XML 文件：图书 (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f)。 `FillList`方法在示例中使用[LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13)分析的属性值的值从 XML`book`对象。  
  
 下表描述了为 find 方法提供的示例。  
  
|方法|示例|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|查找 ID 使用书`IDToFind`谓词委托。<br /><br /> C# 示例使用匿名委托。|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|查找所有丛书，其`Genre`属性是"计算机"使用`FindComputer`谓词委托。|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|2001 年，使用之前在发布日期在集合中查找最后一本书`PubBefore2001`谓词委托。<br /><br /> C# 示例使用匿名委托。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|查找的第一个计算机书籍使用索引`FindComputer`谓词委托。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|查找的最后一个的计算机书籍使用索引`FindComputer`谓词委托。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|集合中的后半部分中第二个查找的第一本计算机书籍索引使用`FindComputer`谓词委托。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|集合中的后半部分中第二个查找的最后一个的计算机书籍索引使用`FindComputer`谓词委托。|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; FindAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; FindAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAll (match As Predicate(Of T)) As List(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt; ^ FindAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindAll : Predicate&lt;'T&gt; -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="list.FindAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match"><see cref="T:System.Predicate`1" /> 委托，用于定义要搜索的元素应满足的条件。</param>
        <summary>检索与指定谓词定义的条件匹配的所有元素。</summary>
        <returns>如果找到，则为一个 <see cref="T:System.Collections.Generic.List`1" />，其中包含与指定谓词所定义的条件相匹配的所有元素；否则为一个空 <see cref="T:System.Collections.Generic.List`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>是返回的方法的委托`true`如果该对象传递给委托中定义的条件匹配。  当前元素<xref:System.Collections.Generic.List%601>逐个传递给<xref:System.Predicate%601>委托和与条件匹配的元素都将保存在返回<xref:System.Collections.Generic.List%601>。  
  
 此方法执行线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示的查找方法<xref:System.Collections.Generic.List%601>类。 有关示例<xref:System.Collections.Generic.List%601>类包含`book`类的对象`Book`，使用的数据进行[示例 XML 文件：图书 (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f)。 `FillList`方法在示例中使用[LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13)分析的属性值的值从 XML`book`对象。  
  
 下表描述了为 find 方法提供的示例。  
  
|方法|示例|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|查找 ID 使用书`IDToFind`谓词委托。<br /><br /> C# 示例使用匿名委托。|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|查找所有丛书，其`Genre`属性是"计算机"使用`FindComputer`谓词委托。|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|2001 年，使用之前在发布日期在集合中查找最后一本书`PubBefore2001`谓词委托。<br /><br /> C# 示例使用匿名委托。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|查找的第一个计算机书籍使用索引`FindComputer`谓词委托。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|查找的最后一个的计算机书籍使用索引`FindComputer`谓词委托。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|集合中的后半部分中第二个查找的第一本计算机书籍索引使用`FindComputer`谓词委托。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|集合中的后半部分中第二个查找的最后一个的计算机书籍索引使用`FindComputer`谓词委托。|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，返回 <see cref="T:System.Collections.Generic.List`1" /> 或它的一部分中第一个匹配项的从零开始的索引。 如果未找到与条件匹配的项，则此方法返回 -1。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match"><see cref="T:System.Predicate`1" /> 委托，用于定义要搜索的元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，并返回整个 <see cref="T:System.Collections.Generic.List`1" /> 中第一个匹配元素的从零开始的索引。</summary>
        <returns>如果找到与 <paramref name="match" /> 定义的条件相匹配的第一个元素，则为该元素的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>向前的第一个元素开始和结束时间的最后一个元素搜索。  
  
 <xref:System.Predicate%601>是返回的方法的委托`true`如果该对象传递给委托中定义的条件匹配。  当前元素<xref:System.Collections.Generic.List%601>逐个传递给<xref:System.Predicate%601>委托。 委托的签名：  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 此方法执行线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例定义`Employee`类的两个字段`Name`和`Id`。 它还定义了`EmployeeSearch`具有单个方法的类`StartsWith`，，该值指示是否`Employee.Name`字段开头的指定子字符串，提供给`EmployeeSearch`类构造函数。 请注意此方法的签名  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 对应于可以传递给委托的签名<xref:System.Collections.Generic.List%601.FindIndex%2A>方法。 该示例实例化`List<Employee>`对象中，添加了许多`Employee`对象添加到它，，然后调用<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>方法两次搜索整个集合，第一个第一次`Employee`对象，其`Name`字段的开始使用"J"和第二次第一个`Employee`对象，其`Name`字段开头"Ju"。  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex2.cs#2)]
 [!code-vb[System.Collections.Generic.List.FindIndex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex (startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">从零开始的搜索的起始索引。</param>
        <param name="match"><see cref="T:System.Predicate`1" /> 委托，用于定义要搜索的元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，并返回 <see cref="T:System.Collections.Generic.List`1" /> 中从指定索引到最后一个元素的元素范围内第一个匹配项的从零开始的索引。</summary>
        <returns>如果找到与 <paramref name="match" /> 定义的条件相匹配的第一个元素，则为该元素的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>处开始向前搜索`startIndex`和结束时间的最后一个元素。  
  
 <xref:System.Predicate%601>是返回的方法的委托`true`如果该对象传递给委托中定义的条件匹配。  当前元素<xref:System.Collections.Generic.List%601>逐个传递给<xref:System.Predicate%601>委托。 委托的签名：  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 此方法执行线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是中的元素数`startIndex`末尾<xref:System.Collections.Generic.List%601>。  
  
   
  
## Examples  
 下面的示例定义`Employee`类的两个字段`Name`和`Id`。 它还定义了`EmployeeSearch`具有单个方法的类`StartsWith`，，该值指示是否`Employee.Name`字段开头的指定子字符串，提供给`EmployeeSearch`类构造函数。 请注意此方法的签名  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 对应于可以传递给委托的签名<xref:System.Collections.Generic.List%601.FindIndex%2A>方法。 该示例实例化`List<Employee>`对象中，添加了许多`Employee`对象添加到它，，然后调用<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>方法两次以开头的第五个成员 （即索引 4 处的成员） 在集合中搜索。 第一次，它会搜索的第一个`Employee`对象，其`Name`字段开头"J"; 第二个时，它会搜索的第一个`Employee`对象，其`Name`字段开头"Ju"。  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex3.cs#3)]
 [!code-vb[System.Collections.Generic.List.FindIndex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <see cref="T:System.Collections.Generic.List`1" /> 的有效索引范围。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : int * int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex (startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">从零开始的搜索的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <param name="match"><see cref="T:System.Predicate`1" /> 委托，用于定义要搜索的元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的一个元素，并返回 <see cref="T:System.Collections.Generic.List`1" /> 中从指定的索引开始、包含指定元素个数的元素范围内第一个匹配项的从零开始的索引。</summary>
        <returns>如果找到与 <paramref name="match" /> 定义的条件相匹配的第一个元素，则为该元素的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>处开始向前搜索`startIndex`结束时间`startIndex`plus`count`减 1，如果`count`大于 0。  
  
 <xref:System.Predicate%601>是返回的方法的委托`true`如果该对象传递给委托中定义的条件匹配。  当前元素<xref:System.Collections.Generic.List%601>逐个传递给<xref:System.Predicate%601>委托。 委托的签名：  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 此方法执行线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是`count`。  
  
   
  
## Examples  
 下面的示例定义`Employee`类的两个字段`Name`和`Id`。 它还定义了`EmployeeSearch`具有单个方法的类`StartsWith`，，该值指示是否`Employee.Name`字段开头的指定子字符串，提供给`EmployeeSearch`类构造函数。 请注意此方法的签名  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 对应于可以传递给委托的签名<xref:System.Collections.Generic.List%601.FindIndex%2A>方法。 示例实例化`List<Employee>`对象中，添加了许多`Employee`对象添加到它，，然后调用<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>两次，以在整个集合中搜索的方法 (即成员从索引 0 到索引<xref:System.Collections.Generic.List%601.Count%2A>-1)。 第一次，它会搜索的第一个`Employee`对象，其`Name`字段开头"J"; 第二个时，它会搜索的第一个`Employee`对象，其`Name`字段开头"Ju"。  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex1.cs#1)]
 [!code-vb[System.Collections.Generic.List.FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <see cref="T:System.Collections.Generic.List`1" /> 的有效索引范围。  
  
- 或 - 
 <paramref name="count" /> 小于 0。  
  
- 或 - 
 <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <see cref="T:System.Collections.Generic.List`1" /> 中指定有效部分。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast">
      <MemberSignature Language="C#" Value="public T FindLast (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T FindLast(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLast (match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T FindLast(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLast : Predicate&lt;'T&gt; -&gt; 'T" Usage="list.FindLast match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match"><see cref="T:System.Predicate`1" /> 委托，用于定义要搜索的元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，并返回整个 <see cref="T:System.Collections.Generic.List`1" /> 中的最后一个匹配元素。</summary>
        <returns>如果找到，则为与指定谓词所定义的条件相匹配的最后一个元素；否则为类型 <paramref name="T" /> 的默认值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>是返回的方法的委托`true`如果该对象传递给委托中定义的条件匹配。  当前元素<xref:System.Collections.Generic.List%601>逐个传递给<xref:System.Predicate%601>委托，向后移动<xref:System.Collections.Generic.List%601>，从最后一个元素开始和结束的第一个元素。  当找到匹配项时，停止处理。  
  
> [!IMPORTANT]
>  在搜索时包含值类型的列表，请确保该类型的默认值不满足搜索谓词。 否则，没有任何方式来区分一个默认值，该值指示已找到任何匹配项和一个列表元素，它恰好有类型的默认值。 如果默认值满足搜索谓词，则使用<xref:System.Collections.Generic.List%601.FindLastIndex%2A>方法相反。  
  
 此方法执行线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示的查找方法<xref:System.Collections.Generic.List%601>类。 有关示例<xref:System.Collections.Generic.List%601>类包含`book`类的对象`Book`，使用的数据进行[示例 XML 文件：图书 (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f)。 `FillList`方法在示例中使用[LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13)分析的属性值的值从 XML`book`对象。  
  
 下表描述了为 find 方法提供的示例。  
  
|方法|示例|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|查找 ID 使用书`IDToFind`谓词委托。<br /><br /> C# 示例使用匿名委托。|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|查找所有丛书，其`Genre`属性是"计算机"使用`FindComputer`谓词委托。|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|2001 年，使用之前在发布日期在集合中查找最后一本书`PubBefore2001`谓词委托。<br /><br /> C# 示例使用匿名委托。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|查找的第一个计算机书籍使用索引`FindComputer`谓词委托。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|查找的最后一个的计算机书籍使用索引`FindComputer`谓词委托。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|集合中的后半部分中第二个查找的第一本计算机书籍索引使用`FindComputer`谓词委托。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|集合中的后半部分中第二个查找的最后一个的计算机书籍索引使用`FindComputer`谓词委托。|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，返回 <see cref="T:System.Collections.Generic.List`1" /> 或它的一部分中最后一个匹配项的从零开始的索引。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match"><see cref="T:System.Predicate`1" /> 委托，用于定义要搜索的元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，并返回整个 <see cref="T:System.Collections.Generic.List`1" /> 中最后一个匹配元素的从零开始的索引。</summary>
        <returns>如果找到与 <paramref name="match" /> 定义的条件相匹配的最后一个元素，则为该元素的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>向后搜索的最后一个元素开始，结束时间的第一个元素。  
  
 <xref:System.Predicate%601>是返回的方法的委托`true`如果该对象传递给委托中定义的条件匹配。  当前元素<xref:System.Collections.Generic.List%601>逐个传递给<xref:System.Predicate%601>委托。  
  
 此方法执行线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示的查找方法<xref:System.Collections.Generic.List%601>类。 有关示例<xref:System.Collections.Generic.List%601>类包含`book`类的对象`Book`，使用的数据进行[示例 XML 文件：图书 (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f)。 `FillList`方法在示例中使用[LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13)分析的属性值的值从 XML`book`对象。  
  
 下表描述了为 find 方法提供的示例。  
  
|方法|示例|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|查找 ID 使用书`IDToFind`谓词委托。<br /><br /> C# 示例使用匿名委托。|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|查找所有丛书，其`Genre`属性是"计算机"使用`FindComputer`谓词委托。|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|2001 年，使用之前在发布日期在集合中查找最后一本书`PubBefore2001`谓词委托。<br /><br /> C# 示例使用匿名委托。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|查找的第一个计算机书籍使用索引`FindComputer`谓词委托。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|查找的最后一个的计算机书籍使用索引`FindComputer`谓词委托。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|集合中的后半部分中第二个查找的第一本计算机书籍索引使用`FindComputer`谓词委托。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|集合中的后半部分中第二个查找的最后一个的计算机书籍索引使用`FindComputer`谓词委托。|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex (startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">向后搜索的从零开始的起始索引。</param>
        <param name="match"><see cref="T:System.Predicate`1" /> 委托，用于定义要搜索的元素的条件。</param>
        <summary>搜索与由指定谓词定义的条件相匹配的元素，并返回 <see cref="T:System.Collections.Generic.List`1" /> 中从第一个元素到指定索引的元素范围内最后一个匹配项的从零开始的索引。</summary>
        <returns>如果找到与 <paramref name="match" /> 定义的条件相匹配的最后一个元素，则为该元素的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>是搜索处开始向后`startIndex`和结束时间的第一个元素。  
  
 <xref:System.Predicate%601>是返回的方法的委托`true`如果该对象传递给委托中定义的条件匹配。  当前元素<xref:System.Collections.Generic.List%601>逐个传递给<xref:System.Predicate%601>委托。  
  
 此方法执行线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是从开头的元素数目<xref:System.Collections.Generic.List%601>到`startIndex`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <see cref="T:System.Collections.Generic.List`1" /> 的有效索引范围。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : int * int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex (startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">向后搜索的从零开始的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <param name="match"><see cref="T:System.Predicate`1" /> 委托，用于定义要搜索的元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，并返回 <see cref="T:System.Collections.Generic.List`1" /> 中包含指定元素个数、到指定索引结束的元素范围内最后一个匹配项的从零开始的索引。</summary>
        <returns>如果找到与 <paramref name="match" /> 定义的条件相匹配的最后一个元素，则为该元素的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>是搜索处开始向后`startIndex`结束时间`startIndex`减去`count`加上 1，如果`count`大于 0。  
  
 <xref:System.Predicate%601>是返回的方法的委托`true`如果该对象传递给委托中定义的条件匹配。  当前元素<xref:System.Collections.Generic.List%601>逐个传递给<xref:System.Predicate%601>委托。  
  
 此方法执行线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是`count`。  
  
   
  
## Examples  
 下面的示例演示的查找方法<xref:System.Collections.Generic.List%601>类。 有关示例<xref:System.Collections.Generic.List%601>类包含`book`类的对象`Book`，使用的数据进行[示例 XML 文件：图书 (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f)。 `FillList`方法在示例中使用[LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13)分析的属性值的值从 XML`book`对象。  
  
 下表描述了为 find 方法提供的示例。  
  
|方法|示例|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|查找 ID 使用书`IDToFind`谓词委托。<br /><br /> C# 示例使用匿名委托。|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|查找所有丛书，其`Genre`属性是"计算机"使用`FindComputer`谓词委托。|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|2001 年，使用之前在发布日期在集合中查找最后一本书`PubBefore2001`谓词委托。<br /><br /> C# 示例使用匿名委托。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|查找的第一个计算机书籍使用索引`FindComputer`谓词委托。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|查找的最后一个的计算机书籍使用索引`FindComputer`谓词委托。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|集合中的后半部分中第二个查找的第一本计算机书籍索引使用`FindComputer`谓词委托。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|集合中的后半部分中第二个查找的最后一个的计算机书籍索引使用`FindComputer`谓词委托。|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <see cref="T:System.Collections.Generic.List`1" /> 的有效索引范围。  
  
- 或 - 
 <paramref name="count" /> 小于 0。  
  
- 或 - 
 <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <see cref="T:System.Collections.Generic.List`1" /> 中指定有效部分。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach">
      <MemberSignature Language="C#" Value="public void ForEach (Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ForEach(class System.Action`1&lt;!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ForEach(System.Action{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub ForEach (action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ForEach(Action&lt;T&gt; ^ action);" />
      <MemberSignature Language="F#" Value="member this.ForEach : Action&lt;'T&gt; -&gt; unit" Usage="list.ForEach action" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="action">要对 <see cref="T:System.Action`1" /> 的每个元素执行的 <see cref="T:System.Collections.Generic.List`1" /> 委托。</param>
        <summary>对 <see cref="T:System.Collections.Generic.List`1" /> 的每个元素执行指定操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Action%601>对象执行的操作方法的委托传递给它。  当前元素<xref:System.Collections.Generic.List%601>逐个传递给<xref:System.Action%601>委托。  
  
 此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
 修改基础集合中的正文<xref:System.Action%601>委托不受支持，会导致未定义的行为。  
  
   
  
## Examples  
 下面的示例演示如何将<xref:System.Action%601>要打印的内容委托<xref:System.Collections.Generic.List%601>对象。 在此示例中`Print`方法用于向控制台显示列表的内容。  
  
> [!NOTE]
>  除了显示使用的内容以外`Print`方法中，C#的示例演示如何使用[匿名方法](~/docs/csharp/programming-guide/statements-expressions-operators/anonymous-methods.md)若要将结果显示到控制台。  
  
 [!code-csharp[System.Action_PrintExample#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Action_PrintExample/cs/action.cs#01)]
 [!code-vb[System.Action_PrintExample#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Action_PrintExample/vb/action.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">已修改集合中的某个元素。</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.List`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As List(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.List&lt;'T&gt;.Enumerator" Usage="list.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回循环访问 <see cref="T:System.Collections.Generic.List`1" /> 的枚举数。</summary>
        <returns>用于 <see cref="T:System.Collections.Generic.List`1.Enumerator" /> 的 <see cref="T:System.Collections.Generic.List`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach`语句的C#语言 (`for each`中C++，`For Each`在 Visual Basic 中) 隐藏了枚举器的复杂性。 因此，建议使用 `foreach`，而不是直接操作枚举数。  
  
 枚举器可用于读取集合中的数据，但不能用于修改基础集合。  
  
 最初，枚举数定位在集合中第一个元素的前面。 在此位置上，<xref:System.Collections.Generic.List%601.Enumerator.Current%2A>未定义属性。 因此，您必须调用<xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A>方法将枚举数前移到集合，然后再读取的值的第一个元素<xref:System.Collections.Generic.List%601.Enumerator.Current%2A>。  
  
 <xref:System.Collections.Generic.List%601.Enumerator.Current%2A>属性返回同一对象，直到<xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A>调用。 <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> 将 <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> 设置为下一个元素。  
  
 如果<xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A>越过集合，枚举器的末尾放置在集合中的最后一个元素的后面和<xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A>返回`false`。 当枚举数位于此位置上，对后续调用<xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A>还返回`false`。 如果最后一次调用到<xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A>返回`false`，<xref:System.Collections.Generic.List%601.Enumerator.Current%2A>是不确定的。 无法再次将 <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> 设置为集合的第一个元素；必须改为创建新的枚举器实例。  
  
 只要集合保持不变，枚举数就保持有效。 如果进行了更改到集合中，例如添加、 修改或删除元素，该枚举数将失效且不可恢复，并且下次调用<xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A>或<xref:System.Collections.Generic.List%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A>引发<xref:System.InvalidOperationException>。  
  
 枚举数没有对集合的独占访问权；因此，从头到尾对一个集合进行枚举在本质上不是一个线程安全的过程。 若要确保枚举过程中的线程安全性，可以在整个枚举过程中锁定集合。  若要允许多个线程访问集合以进行读写操作，则必须实现自己的同步。  
  
 <xref:System.Collections.Generic?displayProperty=nameWithType> 命名空间中集合的默认实现是不同步的。  
  
 此方法为 o （1） 运算。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.List`1.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="GetRange">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; GetRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; GetRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRange (index As Integer, count As Integer) As List(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt; ^ GetRange(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetRange : int * int -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="list.GetRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">范围开始处的从零开始的 <see cref="T:System.Collections.Generic.List`1" /> 索引。</param>
        <param name="count">范围中的元素数。</param>
        <summary>创建源 <see cref="T:System.Collections.Generic.List`1" /> 中的元素范围的浅表副本。</summary>
        <returns>源 <see cref="T:System.Collections.Generic.List`1" /> 中的元素范围的浅表副本。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 该集合的子集或引用类型的集合的浅表副本包含仅对集合的元素的引用。 不复制对象本身。 新列表中的引用都指向相同的对象中的原始列表的引用。  
  
 值类型的集合或该集合的子集的浅表副本包含集合的元素。 但是，如果集合中的元素包含对其他对象的引用，不会复制这些对象。 在新集合的元素中引用都指向相同的对象中的原始集合的元素的引用。  
  
 与此相反，集合的深层副本复制这些元素以及由这些元素直接或间接引用的所有内容。  
  
 此方法为 O (*n*) 操作，其中*n*是`count`。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Collections.Generic.List%601.GetRange%2A>方法和其他方法<xref:System.Collections.Generic.List%601>对范围进行操作的类。 在此示例中，末尾<xref:System.Collections.Generic.List%601.GetRange%2A>方法用于从列表中，从开始的索引位置 2 获取三个项。 <xref:System.Collections.Generic.List%601.ToArray%2A>方法调用所产生<xref:System.Collections.Generic.List%601>，创建三个元素的数组。 将显示数组的元素。  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 0。  
  
- 或 - 
 <paramref name="count" /> 小于 0。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 和 <paramref name="count" /> 不表示 <see cref="T:System.Collections.Generic.List`1" /> 中元素的有效范围。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回 <see cref="T:System.Collections.Generic.List`1" /> 或它的一部分中某个值的第一个匹配项的从零开始的索引。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(T item);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : 'T -&gt; int&#xA;override this.IndexOf : 'T -&gt; int" Usage="list.IndexOf item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.IndexOf(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">要在 <see cref="T:System.Collections.Generic.List`1" /> 中定位的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <summary>搜索指定的对象，并返回整个 <see cref="T:System.Collections.Generic.List`1" /> 中第一个匹配项的从零开始的索引。</summary>
        <returns>如果找到，则为整个 <paramref name="item" /> 中 <see cref="T:System.Collections.Generic.List`1" /> 第一个匹配项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>向前的第一个元素开始和结束时间的最后一个元素搜索。  
  
 此方法可确定是否使用默认的相等比较的相等<xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>为`T`，列表中的值的类型。  
  
 此方法执行线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示的所有三个重载<xref:System.Collections.Generic.List%601.IndexOf%2A>方法。 一个<xref:System.Collections.Generic.List%601>的字符串创建后，显示两次，在索引位置 0 和 5 的索引位置的一个条目。 <xref:System.Collections.Generic.List%601.IndexOf%28%600%29>方法重载从一开始，在列表中搜索并查找字符串的第一个匹配项。 <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29>方法重载用于搜索的索引位置 3 开头的列表，直至列表的末尾，并查找字符串的第二个匹配项。 最后，<xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29>方法重载用于搜索的两个条目，开始的索引位置两个范围，则返回-1，因为没有在该范围内搜索字符串的实例。  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : 'T * int -&gt; int" Usage="list.IndexOf (item, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">要在 <see cref="T:System.Collections.Generic.List`1" /> 中定位的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <param name="index">从零开始的搜索的起始索引。 空列表中 0（零）为有效值。</param>
        <summary>搜索指定的对象，并返回 <see cref="T:System.Collections.Generic.List`1" /> 中从指定索引到最后一个元素的元素范围内第一个匹配项的从零开始的索引。</summary>
        <returns>如果在 <see cref="T:System.Collections.Generic.List`1" /> 中从 <paramref name="index" /> 到最后一个元素的元素范围内找到 <paramref name="item" /> 的第一个匹配项，则为该项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>处开始向前搜索`index`和结束时间的最后一个元素。  
  
 此方法可确定是否使用默认的相等比较的相等<xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>为`T`，列表中的值的类型。  
  
 此方法执行线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是中的元素数`index`末尾<xref:System.Collections.Generic.List%601>。  
  
   
  
## Examples  
 下面的示例演示的所有三个重载<xref:System.Collections.Generic.List%601.IndexOf%2A>方法。 一个<xref:System.Collections.Generic.List%601>的字符串创建后，显示两次，在索引位置 0 和 5 的索引位置的一个条目。 <xref:System.Collections.Generic.List%601.IndexOf%28%600%29>方法重载从一开始，在列表中搜索并查找字符串的第一个匹配项。 <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29>方法重载用于搜索的索引位置 3 开头的列表，直至列表的末尾，并查找字符串的第二个匹配项。 最后，<xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29>方法重载用于搜索的两个条目，开始的索引位置两个范围，则返回-1，因为没有在该范围内搜索字符串的实例。  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 超出了 <see cref="T:System.Collections.Generic.List`1" /> 的有效索引范围。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : 'T * int * int -&gt; int" Usage="list.IndexOf (item, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">要在 <see cref="T:System.Collections.Generic.List`1" /> 中定位的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <param name="index">从零开始的搜索的起始索引。 空列表中 0（零）为有效值。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <summary>搜索指定对象并返回 <see cref="T:System.Collections.Generic.List`1" /> 中从指定索引开始并包含指定元素数的这部分元素中第一个匹配项的从零开始索引。</summary>
        <returns>如果在 <see cref="T:System.Collections.Generic.List`1" /> 中从 <paramref name="index" /> 开始并包含 <paramref name="count" /> 个元素的元素范围内找到 <paramref name="item" /> 的第一个匹配项，则为该项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>处开始向前搜索`index`结束时间`index`plus`count`减 1，如果`count`大于 0。  
  
 此方法可确定是否使用默认的相等比较的相等<xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>为`T`，列表中的值的类型。  
  
 此方法执行线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是`count`。  
  
   
  
## Examples  
 下面的示例演示的所有三个重载<xref:System.Collections.Generic.List%601.IndexOf%2A>方法。 一个<xref:System.Collections.Generic.List%601>的字符串创建后，显示两次，在索引位置 0 和 5 的索引位置的一个条目。 <xref:System.Collections.Generic.List%601.IndexOf%28%600%29>方法重载从一开始，在列表中搜索并查找字符串的第一个匹配项。 <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29>方法重载用于搜索的索引位置 3 开头的列表，直至列表的末尾，并查找字符串的第二个匹配项。 最后，<xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29>方法重载用于搜索的两个条目，开始的索引位置两个范围，则返回-1，因为没有在该范围内搜索字符串的实例。  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 超出了 <see cref="T:System.Collections.Generic.List`1" /> 的有效索引范围。  
  
- 或 - 
 <paramref name="count" /> 小于 0。  
  
- 或 - 
 <paramref name="index" /> 和 <paramref name="count" /> 未在 <see cref="T:System.Collections.Generic.List`1" /> 中指定有效部分。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public void Insert (int index, T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Insert(int32 index, !T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Insert (index As Integer, item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Insert(int index, T item);" />
      <MemberSignature Language="F#" Value="abstract member Insert : int * 'T -&gt; unit&#xA;override this.Insert : int * 'T -&gt; unit" Usage="list.Insert (index, item)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="index">应插入 <paramref name="item" /> 的从零开始的索引。</param>
        <param name="item">要插入的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <summary>将元素插入 <see cref="T:System.Collections.Generic.List`1" /> 的指定索引处。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 接受`null`是有效的引用值类型以及允许重复的元素。  
  
 如果<xref:System.Collections.Generic.List%601.Count%2A>已等于<xref:System.Collections.Generic.List%601.Capacity%2A>，则容量的<xref:System.Collections.Generic.List%601>自动重新分配内部数组中，增加和现有元素之前添加新元素将复制到新数组。  
  
 如果`index`等同于<xref:System.Collections.Generic.List%601.Count%2A>，`item`添加到末尾<xref:System.Collections.Generic.List%601>。  
  
 此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示如何添加、 删除和插入中的简单业务对象<xref:System.Collections.Generic.List%601>。  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 下面的示例演示<xref:System.Collections.Generic.List%601.Insert%2A>方法，以及各种其他属性和方法的<xref:System.Collections.Generic.List%601>泛型类。 创建列表后，会添加元素。 <xref:System.Collections.Generic.List%601.Insert%2A>方法用于将项插入到列表的中间。 项插入是为使用更高版本删除的重复<xref:System.Collections.Generic.List%601.Remove%2A>方法。  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 0。  
  
- 或 - 
 <paramref name="index" /> 大于 <see cref="P:System.Collections.Generic.List`1.Count" />。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
      </Docs>
    </Member>
    <Member MemberName="InsertRange">
      <MemberSignature Language="C#" Value="public void InsertRange (int index, System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertRange(int32 index, class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertRange (index As Integer, collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertRange(int index, System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="member this.InsertRange : int * seq&lt;'T&gt; -&gt; unit" Usage="list.InsertRange (index, collection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">应在此处插入新元素的从零开始的索引。</param>
        <param name="collection">一个集合，应将其元素插入到 <see cref="T:System.Collections.Generic.List`1" /> 中。 集合自身不能为 <see langword="null" />，但它可以包含为 <see langword="null" /> 的元素（如果类型 <paramref name="T" /> 为引用类型）。</param>
        <summary>将集合中的元素插入 <see cref="T:System.Collections.Generic.List`1" /> 的指定索引处。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 接受`null`是有效的引用值类型以及允许重复的元素。  
  
 如果新<xref:System.Collections.Generic.List%601.Count%2A>(当前<xref:System.Collections.Generic.List%601.Count%2A>plus 集合的大小) 将大于<xref:System.Collections.Generic.List%601.Capacity%2A>，则容量的<xref:System.Collections.Generic.List%601>增加通过自动重新分配要容纳新元素的内部数组和之前添加新元素，现有元素将复制到新数组。  
  
 如果`index`等同于<xref:System.Collections.Generic.List%601.Count%2A>，元素将被添加到末尾<xref:System.Collections.Generic.List%601>。  
  
 集合中元素的顺序将保留在<xref:System.Collections.Generic.List%601>。  
  
 此方法为 O (*n* * *m*) 操作，其中*n*是要添加的元素数并*m*是<xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 下面的示例演示<xref:System.Collections.Generic.List%601.InsertRange%2A>方法和各种其他方法的<xref:System.Collections.Generic.List%601>对范围进行操作的类。 创建和使用多个平静工厂吃恐龙都暗示了，名称填充列表之后<xref:System.Collections.Generic.List%601.InsertRange%2A>方法用于将数组的三个凶恶肉吃恐龙都暗示了插入到列表中，索引位置 3 开始。  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 0。  
  
- 或 - 
 <paramref name="index" /> 大于 <see cref="P:System.Collections.Generic.List`1.Count" />。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(index As Integer) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T default[int] { T get(int index); void set(int index, T value); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : 'T with get, set" Usage="System.Collections.Generic.List&lt;'T&gt;.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IList`1.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要获取或设置的元素的从零开始的索引。</param>
        <summary>获取或设置指定索引处的元素。</summary>
        <value>指定索引处的元素。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 接受`null`是有效的引用值类型以及允许重复的元素。  
  
 可以使用下面的语法通过此属性访问集合中的特定元素：`myCollection[index]`。  
  
 检索此属性的值是 o （1） 的操作;将属性设置也是 o （1） 操作。  
  
   
  
## Examples  
 在本部分中的示例演示<xref:System.Collections.Generic.List%601.Item%2A>属性 （C# 中的索引器） 和各种其他属性和方法的<xref:System.Collections.Generic.List%601>泛型类。 列表后创建和使用填充<xref:System.Collections.Generic.List%601.Add%2A>方法中，元素将检索，显示使用<xref:System.Collections.Generic.List%601.Item%2A>属性。 (有关的示例，使用<xref:System.Collections.Generic.List%601.Item%2A>属性来设置元素的值列表，请参阅<xref:System.Collections.Generic.List%601.AsReadOnly%2A>。)  
  
> [!NOTE]
>  Visual Basic 中， C#，和C++所有具有访问语法<xref:System.Collections.Generic.List%601.Item%2A>而无需使用其名称的属性。 相反，变量包含<xref:System.Collections.Generic.List%601>，就好像数组使用。  
  
 C#语言中使用[ `this` ](~/docs/csharp/language-reference/keywords/this.md)关键字来定义而不是实现索引器<xref:System.Collections.Generic.List%601.Item%2A>属性。 Visual Basic 将 <xref:System.Collections.Generic.List%601.Item%2A> 实现为默认属性，该属性提供相同的索引功能。  
  
 [!code-csharp[List`1_Class#2](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#2)]
 [!code-vb[List`1_Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#2)]  
[!code-csharp[List`1_Class#3](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#3)]
[!code-vb[List`1_Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 0。  
  
- 或 - 
 <paramref name="index" /> 等于或大于 <see cref="P:System.Collections.Generic.List`1.Count" />。</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回 <see cref="T:System.Collections.Generic.List`1" /> 或它的一部分中某个值的最后一个匹配项的从零开始的索引。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T -&gt; int" Usage="list.LastIndexOf item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">要在 <see cref="T:System.Collections.Generic.List`1" /> 中定位的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <summary>搜索指定的对象，并返回整个 <see cref="T:System.Collections.Generic.List`1" /> 中最后一个匹配项的从零开始的索引。</summary>
        <returns>如果在整个 <see cref="T:System.Collections.Generic.List`1" /> 中找到 <paramref name="item" /> 的最后一个匹配项，则为该项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>向后搜索的最后一个元素开始，结束时间的第一个元素。  
  
 此方法可确定是否使用默认的相等比较的相等<xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>为`T`，列表中的值的类型。  
  
 此方法执行线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示的所有三个重载<xref:System.Collections.Generic.List%601.LastIndexOf%2A>方法。 一个<xref:System.Collections.Generic.List%601>的字符串创建后，显示两次，在索引位置 0 和 5 的索引位置的一个条目。 <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29>方法重载从结束时，在整个列表中搜索并查找字符串的第二个匹配项。 <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29>方法重载用于向后从索引位置 3 开始，然后再向列表的开头，因此会在列表中找到该字符串的第一个匹配项在列表中搜索。 最后，<xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29>方法重载用于搜索的索引位置 4 开始，往前的四个条目范围 （即，它搜索在位置 4、 3、 2 和 1 项）; 此搜索将返回-1，因为没有搜索的实例在该范围内的字符串。  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T * int -&gt; int" Usage="list.LastIndexOf (item, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">要在 <see cref="T:System.Collections.Generic.List`1" /> 中定位的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <param name="index">向后搜索的从零开始的起始索引。</param>
        <summary>搜索指定的对象，并返回 <see cref="T:System.Collections.Generic.List`1" /> 中从第一个元素到指定索引的元素范围内最后一个匹配项的从零开始的索引。</summary>
        <returns>如果找到，则返回在 <see cref="T:System.Collections.Generic.List`1" /> 中从第一个元素到 <paramref name="index" /> 的元素范围内找到 <paramref name="item" /> 的最后一个匹配项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>是搜索处开始向后`index`和结束时间的第一个元素。  
  
 此方法可确定是否使用默认的相等比较的相等<xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>为`T`，列表中的值的类型。  
  
 此方法执行线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是从开头的元素数目<xref:System.Collections.Generic.List%601>到`index`。  
  
   
  
## Examples  
 下面的示例演示的所有三个重载<xref:System.Collections.Generic.List%601.LastIndexOf%2A>方法。 一个<xref:System.Collections.Generic.List%601>的字符串创建后，显示两次，在索引位置 0 和 5 的索引位置的一个条目。 <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29>方法重载从结束时，在整个列表中搜索并查找字符串的第二个匹配项。 <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29>方法重载用于向后从索引位置 3 开始，然后再向列表的开头，因此会在列表中找到该字符串的第一个匹配项在列表中搜索。 最后，<xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29>方法重载用于搜索的索引位置 4 开始，往前的四个条目范围 （即，它搜索在位置 4、 3、 2 和 1 项）; 此搜索将返回-1，因为没有搜索的实例在该范围内的字符串。  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 超出了 <see cref="T:System.Collections.Generic.List`1" /> 的有效索引范围。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T * int * int -&gt; int" Usage="list.LastIndexOf (item, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">要在 <see cref="T:System.Collections.Generic.List`1" /> 中定位的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <param name="index">向后搜索的从零开始的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <summary>搜索指定对象并返回 <see cref="T:System.Collections.Generic.List`1" /> 中到指定索引为止包含指定元素数的这部分元素中最后一个匹配项的从零开始索引。</summary>
        <returns>如果在 <see cref="T:System.Collections.Generic.List`1" /> 中到 <paramref name="index" /> 为止包含 <paramref name="count" /> 个元素的这部分元素中找到 <paramref name="item" /> 的最后一个匹配项，则为该项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>是搜索处开始向后`index`结束时间`index`减去`count`加上 1，如果`count`大于 0。  
  
 此方法可确定是否使用默认的相等比较的相等<xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>为`T`，列表中的值的类型。  
  
 此方法执行线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是`count`。  
  
   
  
## Examples  
 下面的示例演示的所有三个重载<xref:System.Collections.Generic.List%601.LastIndexOf%2A>方法。 一个<xref:System.Collections.Generic.List%601>的字符串创建后，显示两次，在索引位置 0 和 5 的索引位置的一个条目。 <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29>方法重载从结束时，在整个列表中搜索并查找字符串的第二个匹配项。 <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29>方法重载用于向后从索引位置 3 开始，然后再向列表的开头，因此会在列表中找到该字符串的第一个匹配项在列表中搜索。 最后，<xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29>方法重载用于搜索的 4 个条目，索引位置 4 开始，并向后扩展范围 （即，它搜索在位置 4、 3、 2 和 1 项）; 此搜索将返回-1，因为没有搜索的实例在该范围内的字符串。  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 超出了 <see cref="T:System.Collections.Generic.List`1" /> 的有效索引范围。  
  
- 或 - 
 <paramref name="count" /> 小于 0。  
  
- 或 - 
 <paramref name="index" /> 和 <paramref name="count" /> 未在 <see cref="T:System.Collections.Generic.List`1" /> 中指定有效部分。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(T item);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'T -&gt; bool&#xA;override this.Remove : 'T -&gt; bool" Usage="list.Remove item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">要从 <see cref="T:System.Collections.Generic.List`1" /> 中删除的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <summary>从 <see cref="T:System.Collections.Generic.List`1" /> 中移除特定对象的第一个匹配项。</summary>
        <returns>如果成功移除 <paramref name="item" />，则为 <see langword="true" />；否则为 <see langword="false" />。  如果在 <see cref="T:System.Collections.Generic.List`1" /> 中没有找到 <paramref name="item" />，该方法也会返回 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果类型`T`实现<xref:System.IEquatable%601>泛型接口，则相等比较器是<xref:System.IEquatable%601.Equals%2A>接口; 方法的默认相等比较器是为<xref:System.Object.Equals%2A?displayProperty=nameWithType>。  
  
 此方法执行线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示如何添加、 删除和插入中的简单业务对象<xref:System.Collections.Generic.List%601>。  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 下面的示例演示<xref:System.Collections.Generic.List%601.Remove%2A>方法。 一些属性和方法的<xref:System.Collections.Generic.List%601>泛型类用于添加、 插入和搜索列表。 在执行这些操作之后, 该列表包含重复。 <xref:System.Collections.Generic.List%601.Remove%2A>方法用于删除重复项的第一个实例并显示内容。 <xref:System.Collections.Generic.List%601.Remove%2A>方法始终会删除它遇到的第一个实例。  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public int RemoveAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 RemoveAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAll (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int RemoveAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.RemoveAll : Predicate&lt;'T&gt; -&gt; int" Usage="list.RemoveAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match"><see cref="T:System.Predicate`1" /> 委托，用于定义要移除的元素应满足的条件。</param>
        <summary>移除与指定的谓词所定义的条件相匹配的所有元素。</summary>
        <returns>从 <see cref="T:System.Collections.Generic.List`1" /> 中移除的元素数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>是返回的方法的委托`true`如果该对象传递给委托中定义的条件匹配。  当前元素<xref:System.Collections.Generic.List%601>逐个传递给<xref:System.Predicate%601>委托和与条件匹配的元素将从<xref:System.Collections.Generic.List%601>。  
  
 此方法执行线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Collections.Generic.List%601.RemoveAll%2A>方法和其他几种方法使用<xref:System.Predicate%601>泛型委托。  
  
 一个<xref:System.Collections.Generic.List%601>的字符串创建，包含 8 个恐龙名称，其中 （位于位置 1 和 5） 两个以"saurus"结尾。 该示例还定义一个名为搜索谓词的方法`EndsWithSaurus`、，它接受字符串参数和返回一个布尔值，该值指示是否以"saurus"结尾的输入的字符串。  
  
 <xref:System.Collections.Generic.List%601.Find%2A>， <xref:System.Collections.Generic.List%601.FindLast%2A>，和<xref:System.Collections.Generic.List%601.FindAll%2A>方法用于在列表中搜索与搜索谓词方法。  
  
 <xref:System.Collections.Generic.List%601.RemoveAll%2A>方法用于删除以"saurus"结尾的所有项。 它从开始时，将每个元素传递给反过来将遍历列表`EndsWithSaurus`方法。 如果该元素已移除`EndsWithSaurus`方法将返回`true`。  
  
> [!NOTE]
>  在 C# 和 Visual Basic 中，它不需要创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中) 显式。 这些语言推断上下文中，从正确的委托，并自动创建。  
  
 最后，<xref:System.Collections.Generic.List%601.Exists%2A>方法验证是否在列表中没有以"saurus"结尾的字符串。  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="abstract member RemoveAt : int -&gt; unit&#xA;override this.RemoveAt : int -&gt; unit" Usage="list.RemoveAt index" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)</InterfaceMember>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要移除的元素的从零开始的索引。</param>
        <summary>移除 <see cref="T:System.Collections.Generic.List`1" /> 的指定索引处的元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当您调用<xref:System.Collections.Generic.List%601.RemoveAt%2A>要删除某个项，请在列表中的其余项目会重新编号来替换已删除的项。 例如，如果删除索引 3 处的项时，索引 4 处的项移动到 3 个位置。 此外，在列表中的项目数 (由表示<xref:System.Collections.Generic.List%601.Count%2A>属性) 缩小了 1。  
  
 此方法为 O (*n*) 操作，其中*n*是 (<xref:System.Collections.Generic.List%601.Count%2A> - `index`)。  
  
   
  
## Examples  
 下面的示例演示如何添加、 删除和插入中的简单业务对象<xref:System.Collections.Generic.List%601>。  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 0。  
  
- 或 - 
 <paramref name="index" /> 等于或大于 <see cref="P:System.Collections.Generic.List`1.Count" />。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveRange">
      <MemberSignature Language="C#" Value="public void RemoveRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveRange (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveRange(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.RemoveRange : int * int -&gt; unit" Usage="list.RemoveRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要移除的元素范围的从零开始的起始索引。</param>
        <param name="count">要移除的元素数。</param>
        <summary>从 <see cref="T:System.Collections.Generic.List`1" /> 中移除一定范围的元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 删除项和遵循它们中的所有元素<xref:System.Collections.Generic.List%601>降低了索引都`count`。  
  
 此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Collections.Generic.List%601.RemoveRange%2A>方法和各种其他方法的<xref:System.Collections.Generic.List%601>对范围进行操作的类。 创建和修改，列表之后<xref:System.Collections.Generic.List%601.RemoveRange%2A>方法用于删除两个元素从列表中，索引位置 2 开始。  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 0。  
  
- 或 - 
 <paramref name="count" /> 小于 0。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 和 <paramref name="count" /> 不表示 <see cref="T:System.Collections.Generic.List`1" /> 中元素的有效范围。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将 <see cref="T:System.Collections.Generic.List`1" /> 或它的一部分中元素的顺序反转。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse();" />
      <MemberSignature Language="F#" Value="member this.Reverse : unit -&gt; unit" Usage="list.Reverse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将整个 <see cref="T:System.Collections.Generic.List`1" /> 中元素的顺序反转。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用<xref:System.Array.Reverse%2A?displayProperty=nameWithType>若要反转的元素的顺序。  
  
 此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示的两个重载<xref:System.Collections.Generic.List%601.Reverse%2A>方法。 此示例将创建<xref:System.Collections.Generic.List%601>的字符串，并添加六个字符串。 <xref:System.Collections.Generic.List%601.Reverse>方法重载用于反向列表中，然后<xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29>方法重载用于反向列表中，从元素 1 开始，其中包含四个元素的中间。  
  
 [!code-cpp[List\`1_Reverse#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs#1)]
 [!code-vb[List\`1_Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.Reverse : int * int -&gt; unit" Usage="list.Reverse (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要反转的范围的从零开始的起始索引。</param>
        <param name="count">要反转的范围内的元素数。</param>
        <summary>将指定范围中元素的顺序反转。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用<xref:System.Array.Reverse%2A?displayProperty=nameWithType>若要反转的元素的顺序。  
  
 此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示的两个重载<xref:System.Collections.Generic.List%601.Reverse%2A>方法。 此示例将创建<xref:System.Collections.Generic.List%601>的字符串，并添加六个字符串。 <xref:System.Collections.Generic.List%601.Reverse>方法重载用于反向列表中，然后<xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29>方法重载用于反向列表中，从元素 1 开始，其中包含四个元素的中间。  
  
 [!code-cpp[List\`1_Reverse#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs#1)]
 [!code-vb[List\`1_Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 0。  
  
- 或 - 
 <paramref name="count" /> 小于 0。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 和 <paramref name="count" /> 不表示 <see cref="T:System.Collections.Generic.List`1" /> 中元素的有效范围。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使用指定或默认的 <see cref="T:System.Collections.Generic.IComparer`1" /> 实现或提供的 <see cref="T:System.Comparison`1" /> 委托对 <see cref="T:System.Collections.Generic.List`1" /> 中的元素或部分元素进行排序，以比较列表元素。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort();" />
      <MemberSignature Language="F#" Value="member this.Sort : unit -&gt; unit" Usage="list.Sort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使用默认比较器对整个 <see cref="T:System.Collections.Generic.List`1" /> 中的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用默认比较器<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>类型`T`以确定列表元素的顺序。 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>属性检查是否类型`T`实现<xref:System.IComparable%601>泛型接口，并使用该实现，如果可用。  如果不是，<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>检查是否类型`T`实现<xref:System.IComparable>接口。  如果类型`T`不实现任何一个接口，<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>引发<xref:System.InvalidOperationException>。  
  
 此方法使用<xref:System.Array.Sort%2A?displayProperty=nameWithType>方法，应用内省排序，如下所示：  
  
-   如果分区大小少于 16 个元素，它使用插入排序算法。  
  
-   如果分区数超过两个日志*n*，其中*n*是范围的输入数组，它使用 Heapsort 算法。  
  
-   否则，它使用快速排序算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，可能不会保留其顺序。 与此相反，一个稳定排序保留相等元素的顺序。  
  
 一般情况下，此方法为 O (*n*日志*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>; 最坏的情况是 O (*n* <sup>2</sup>) 操作。  
  
   
  
## Examples  
 以下示例将添加到某些名称`List<String>`对象，显示未排序顺序，列表会调<xref:System.Collections.Generic.List%601.Sort%2A>方法，然后显示已排序的列表。  
  
 [!code-csharp[System.Collections.Generic.List.Sort#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/Sort1.cs#2)]
 [!code-vb[System.Collections.Generic.List.Sort#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/Sort1.vb#2)]  
  
 下面的代码演示<xref:System.Collections.Generic.List%601.Sort>和<xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29>简单业务对象上的方法重载。 调用<xref:System.Collections.Generic.List%601.Sort>方法会导致使用默认比较器的部件类型和<xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29>使用匿名方法实现方法。  
  
 [!code-csharp[System.Collections.Generic.List.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb#1)]  
  
 下面的示例演示<xref:System.Collections.Generic.List%601.Sort>方法重载和<xref:System.Collections.Generic.List%601.BinarySearch%28%600%29>方法重载。 一个<xref:System.Collections.Generic.List%601>的字符串创建并填充了四个字符串，顺序不分先后。 显示、 排序，列表，并再次显示。  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29>然后使用方法重载的两个字符串的不是在列表中，搜索和<xref:System.Collections.Generic.List%601.Insert%2A>方法用于将它们插入。 返回值<xref:System.Collections.Generic.List%601.BinarySearch%2A>方法为负每种情况下，因为字符串不是在列表中。 执行按位求补 (~ 运算符在C#和 Visual C++，`Xor`在 Visual Basic 中的为-1) 此负数值的生成大于搜索字符串，并将在此位置中的列表中的第一个元素的索引保留排序顺序。 第二个搜索字符串是大于在列表中，任何元素，因此在列表的末尾处的插入位置。  
  
 [!code-cpp[List\`1_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此默认比较器 <see cref="P:System.Collections.Generic.Comparer`1.Default" /> 无法找到 <see cref="T:System.IComparable`1" /> 泛型接口或类型为 <paramref name="T" /> 的 <see cref="T:System.IComparable" /> 接口的实现。</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.Sort : System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="list.Sort comparer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 实现，若要使用默认比较器 <see cref="P:System.Collections.Generic.Comparer`1.Default" />，则为 <see langword="null" />。</param>
        <summary>使用指定的比较器对整个 <see cref="T:System.Collections.Generic.List`1" /> 中的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`comparer`提供的元素<xref:System.Collections.Generic.List%601>使用指定排序<xref:System.Collections.Generic.IComparer%601>实现。  
  
 如果`comparer`是`null`，默认比较器<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>检查是否类型`T`实现<xref:System.IComparable%601>泛型接口，并使用该实现，如果可用。  如果不是，<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>检查是否类型`T`实现<xref:System.IComparable>接口。  如果类型`T`不实现任何一个接口，<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>引发<xref:System.InvalidOperationException>。  
  
 此方法使用<xref:System.Array.Sort%2A?displayProperty=nameWithType>方法，应用内省排序，如下所示：  
  
-   如果分区大小少于 16 个元素，它使用插入排序算法。  
  
-   如果分区数超过两个日志*n*，其中*n*是范围的输入数组，它使用 Heapsort 算法。  
  
-   否则，它使用快速排序算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，可能不会保留其顺序。 与此相反，一个稳定排序保留相等元素的顺序。  
  
 一般情况下，此方法为 O (*n*日志*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>; 最坏的情况是 O (*n* <sup>2</sup>) 操作。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29>方法重载和<xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>方法重载。  
  
 该示例定义名为 DinoCompare，实现的字符串将替代比较器`IComparer<string>`(`IComparer(Of String)`在 Visual Basic`IComparer<String^>`视觉对象中C++) 泛型接口。 比较器的工作方式如下：首先，测试比较数是否为`null`，并为 null 引用被视为小于非空。 其次，比较字符串长度，并更长的字符串被认为更高版本。 第三，如果长度相等，则使用常规字符串比较。  
  
 一个<xref:System.Collections.Generic.List%601>的字符串创建并填充了四个字符串，顺序不分先后。 列表、 排序使用备用的比较器，并显示再次显示。  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>方法重载然后用于搜索将不在列表中，该示例使用的多个字符串。 <xref:System.Collections.Generic.List%601.Insert%2A>方法用来插入字符串。 这两种方法都位于名为的函数`SearchAndInsert`，以及代码执行按位求补 (~ 运算符在C#和 Visual C++，`Xor`在 Visual Basic 中的为-1) 返回负号<xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>并将其用作插入的新字符串的索引。  
  
 [!code-cpp[List\`1_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> 为 <see langword="null" />，且默认比较器 <see cref="P:System.Collections.Generic.Comparer`1.Default" /> 找不到 <see cref="T:System.IComparable`1" /> 泛型接口或类型为 <paramref name="T" /> 的 <see cref="T:System.IComparable" /> 接口的实现。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparer" /> 的实现导致排序时出现错误。 例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Comparison`1&lt;!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(Comparison&lt;T&gt; ^ comparison);" />
      <MemberSignature Language="F#" Value="member this.Sort : Comparison&lt;'T&gt; -&gt; unit" Usage="list.Sort comparison" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparison">比较元素时要使用的 <see cref="T:System.Comparison`1" />。</param>
        <summary>使用指定的 <see cref="T:System.Comparison`1" />，对整个 <see cref="T:System.Collections.Generic.List`1" /> 中的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`comparison`提供的元素<xref:System.Collections.Generic.List%601>使用委托所表示的方法进行排序。  
  
 如果`comparison`是`null`、<xref:System.ArgumentNullException>引发。  
  
 此方法使用<xref:System.Array.Sort%2A?displayProperty=nameWithType>，其应用内省排序，如下所示：  
  
-   如果分区大小少于 16 个元素，它使用插入排序算法  
  
-   如果分区数超过两个日志*n*，其中*n*是范围的输入数组，它使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则，它使用快速排序算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，可能不会保留其顺序。 与此相反，一个稳定排序保留相等元素的顺序。  
  
 一般情况下，此方法为 O (*n*日志*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>; 最坏的情况是 O (*n* <sup>2</sup>) 操作。  
  
   
  
## Examples  
 下面的代码演示<xref:System.Collections.Generic.List%601.Sort%2A>和<xref:System.Collections.Generic.List%601.Sort%2A>简单业务对象上的方法重载。 调用<xref:System.Collections.Generic.List%601.Sort%2A>方法会导致使用默认比较器的部件类型和<xref:System.Collections.Generic.List%601.Sort%2A>方法使用匿名方法实现。  
  
 [!code-csharp[System.Collections.Generic.List.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb#1)]  
  
 下面的示例演示<xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29>方法重载。  
  
 该示例定义名为的字符串替换比较方法`CompareDinosByLength`。 此方法的工作方式如下：首先，测试比较数是否为`null`，并为 null 引用被视为小于非空。 其次，比较字符串长度，并更长的字符串被认为更高版本。 第三，如果长度相等，则使用常规字符串比较。  
  
 一个<xref:System.Collections.Generic.List%601>的字符串创建并填充了四个字符串，顺序不分先后。 列表还包括一个空字符串和 null 引用。 显示列表，使用排序<xref:System.Comparison%601>泛型委托表示`CompareDinosByLength`方法，并再次显示。  
  
 [!code-cpp[List\`1_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortComparison/cs/source.cs#1)]
 [!code-vb[List\`1_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="comparison" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparison" /> 的实现导致排序时出现错误。 例如，将某个项与其自身比较时，<paramref name="comparison" /> 可能不返回 0。</exception>
        <altmember cref="T:System.Comparison`1" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (int index, int count, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(int32 index, int32 count, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (index As Integer, count As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(int index, int count, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.Sort : int * int * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="list.Sort (index, count, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">要排序范围的从零开始的起始索引。</param>
        <param name="count">要排序的范围的长度。</param>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 实现，若要使用默认比较器 <see cref="P:System.Collections.Generic.Comparer`1.Default" />，则为 <see langword="null" />。</param>
        <summary>使用指定的比较器对 <see cref="T:System.Collections.Generic.List`1" /> 中某个范围内的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`comparer`提供的元素<xref:System.Collections.Generic.List%601>使用指定排序<xref:System.Collections.Generic.IComparer%601>实现。  
  
 如果`comparer`是`null`，默认比较器<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>检查是否类型`T`实现<xref:System.IComparable%601>泛型接口，并使用该实现，如果可用。  如果不是，<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>检查是否类型`T`实现<xref:System.IComparable>接口。  如果类型`T`不实现任何一个接口，<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>引发<xref:System.InvalidOperationException>。  
  
 此方法使用<xref:System.Array.Sort%2A?displayProperty=nameWithType>，其应用内省排序，如下所示：  
  
-   如果分区大小少于 16 个元素，它使用插入排序算法  
  
-   如果分区数超过两个日志*n*，其中*n*是范围的输入数组，它使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则，它使用快速排序算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，可能不会保留其顺序。 与此相反，一个稳定排序保留相等元素的顺序。  
  
 一般情况下，此方法为 O (*n*日志*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>; 最坏的情况是 O (*n* <sup>2</sup>) 操作。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>方法重载和<xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>方法重载。  
  
 该示例定义名为 DinoCompare，实现的字符串将替代比较器`IComparer<string>`(`IComparer(Of String)`在 Visual Basic`IComparer<String^>`视觉对象中C++) 泛型接口。 比较器的工作方式如下：首先，测试比较数是否为`null`，并为 null 引用被视为小于非空。 其次，比较字符串长度，并更长的字符串被认为更高版本。 第三，如果长度相等，则使用常规字符串比较。  
  
 一个<xref:System.Collections.Generic.List%601>的字符串创建并填充一个和示例的名称。 在两个组中，名称不按任何特定的排序顺序。 显示的列表，使用备用的比较器排序该，并再次显示列表。  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>方法重载然后用于搜索"Brachiosaurus"仅草食范围。 找不到字符串，并按位求补 (~ 中的运算符C#和 Visual C++，`Xor`在 Visual Basic 中的为-1) 返回负号<xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>方法用于插入新的字符串用作索引。  
  
 [!code-cpp[List\`1_SortSearchComparerRange#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparerRange#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparerRange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 0。  
  
- 或 - 
 <paramref name="count" /> 小于 0。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 和 <paramref name="count" /> 未在 <see cref="T:System.Collections.Generic.List`1" /> 中指定有效范围。  
  
- 或 - 
<paramref name="comparer" /> 的实现导致排序时出现错误。 例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> 为 <see langword="null" />，且默认比较器 <see cref="P:System.Collections.Generic.Comparer`1.Default" /> 找不到 <see cref="T:System.IComparable`1" /> 泛型接口或类型为 <paramref name="T" /> 的 <see cref="T:System.IComparable" /> 接口的实现。</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of T).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::Generic::ICollection&lt;T&gt;::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Collections.Generic.ICollection`1" /> 是否为只读。</summary>
        <value>如果 <see langword="true" /> 是只读的，则为 <see cref="T:System.Collections.Generic.ICollection`1" />；否则为 <see langword="false" />。  在 <see cref="T:System.Collections.Generic.List`1" /> 的默认实现中，此属性始终返回 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在创建只读集合后，该集合不允许添加、移除或修改元素。  
  
 集合是只读的只是一个集合与可防止修改集合; 的包装器因此，如果对基础集合进行更改，只读集合反映了这些更改。  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回循环访问集合的枚举数。</summary>
        <returns>可用于循环访问集合的 <see cref="T:System.Collections.Generic.IEnumerator`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach`语句的C#语言 (`for each`中C++，`For Each`在 Visual Basic 中) 隐藏了枚举器的复杂性。 因此，建议使用 `foreach`，而不是直接操作枚举数。  
  
 枚举器可用于读取集合中的数据，但不能用于修改基础集合。  
  
 最初，枚举数定位在集合中第一个元素的前面。 在此位置上，<xref:System.Collections.Generic.IEnumerator%601.Current%2A>未定义属性。 因此，您必须调用<xref:System.Collections.IEnumerator.MoveNext%2A>方法将枚举数前移到集合，然后再读取的值的第一个元素<xref:System.Collections.Generic.IEnumerator%601.Current%2A>。  
  
 <xref:System.Collections.Generic.IEnumerator%601.Current%2A>属性返回同一对象，直到<xref:System.Collections.IEnumerator.MoveNext%2A>调用。 <xref:System.Collections.IEnumerator.MoveNext%2A> 将 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> 设置为下一个元素。  
  
 如果<xref:System.Collections.IEnumerator.MoveNext%2A>越过集合，枚举器的末尾放置在集合中的最后一个元素的后面和<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`。 当枚举数位于此位置上，对后续调用<xref:System.Collections.IEnumerator.MoveNext%2A>还返回`false`。 如果最后一次调用到<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`，<xref:System.Collections.Generic.IEnumerator%601.Current%2A>是不确定的。 无法再次将 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> 设置为集合的第一个元素；必须改为创建新的枚举器实例。  
  
 只要集合保持不变，枚举数就保持有效。 如果进行了更改到集合中，例如添加、 修改或删除元素，该枚举数将失效且不可恢复，并且下次调用<xref:System.Collections.IEnumerator.MoveNext%2A>或<xref:System.Collections.IEnumerator.Reset%2A>引发<xref:System.InvalidOperationException>。  
  
 枚举数没有对集合的独占访问权；因此，从头到尾对一个集合进行枚举在本质上不是一个线程安全的过程。 若要确保枚举过程中的线程安全性，可以在整个枚举过程中锁定集合。  若要允许多个线程访问集合以进行读写操作，则必须实现自己的同步。  
  
 <xref:System.Collections.Generic?displayProperty=nameWithType> 命名空间中集合的默认实现是不同步的。  
  
 此方法为 o （1） 运算。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int arrayIndex) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">一维 <see cref="T:System.Array" />，它是从 <see cref="T:System.Collections.ICollection" /> 复制的元素的目标。 <see cref="T:System.Array" /> 必须具有从零开始的索引。</param>
        <param name="arrayIndex"><paramref name="array" /> 中从零开始的索引，从此处开始复制。</param>
        <summary>从特定的 <see cref="T:System.Collections.ICollection" /> 索引开始，将 <see cref="T:System.Array" /> 的元素复制到一个 <see cref="T:System.Array" /> 中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  如果源的类型<xref:System.Collections.ICollection>不能自动强制转换为目标的类型`array`的非泛型实现<xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType>引发<xref:System.InvalidCastException>，而泛型实现会引发<xref:System.ArgumentException>。  
  
 此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" /> 小于 0。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> 是多维的。  
  
- 或 - 
 <paramref name="array" /> 没有从零开始的索引。  
  
- 或 - 
源 <see cref="T:System.Collections.ICollection" /> 中的元素个数大于从 <paramref name="arrayIndex" /> 到目标 <paramref name="array" /> 末尾之间的可用空间。  
  
- 或 - 
无法自动将源 <see cref="T:System.Collections.ICollection" /> 的类型转换为目标 <paramref name="array" /> 的类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否同步对 <see cref="T:System.Collections.ICollection" /> 的访问（线程安全）。</summary>
        <value>如果对 <see langword="true" /> 的访问是同步的（线程安全），则为 <see cref="T:System.Collections.ICollection" />；否则为 <see langword="false" />。  在 <see cref="T:System.Collections.Generic.List`1" /> 的默认实现中，此属性始终返回 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic?displayProperty=nameWithType> 命名空间中集合的默认实现是不同步的。  
  
 枚举整个集合本质上不是一个线程安全的过程。  枚举与写访问的竞争的极少数情况下，可以锁定在整个枚举期间的集合。  若要允许多个线程访问集合以进行读写操作，则必须实现自己的同步。  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> 返回一个对象，可用于同步对<xref:System.Collections.ICollection>。 同步是所有线程访问集合之前都锁定此对象时才有效。  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取可用于同步对 <see cref="T:System.Collections.ICollection" /> 的访问的对象。</summary>
        <value>可用于同步对 <see cref="T:System.Collections.ICollection" /> 的访问的对象。  在 <see cref="T:System.Collections.Generic.List`1" /> 的默认实现中，此属性始终返回当前实例。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic?displayProperty=nameWithType> 命名空间中集合的默认实现是不同步的。  
  
 枚举整个集合本质上不是一个线程安全的过程。  若要确保枚举过程中的线程安全性，可以在整个枚举过程中锁定集合。  若要允许多个线程访问集合以进行读写操作，则必须实现自己的同步。  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> 返回一个对象，可用于同步对<xref:System.Collections.ICollection>。 同步是所有线程访问集合之前都锁定此对象时才有效。 下面的代码演示如何使用<xref:System.Collections.ICollection.SyncRoot%2A>属性C#， C++，和 Visual Basic。  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot)   
{  
    // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
    ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try   
{  
    Monitor::Enter(ic->SyncRoot);  
    // Access the collection.  
}  
finally   
{  
    Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回循环访问集合的枚举数。</summary>
        <returns>可用于循环访问集合的 <see cref="T:System.Collections.IEnumerator" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach`语句的C#语言 (`for each`中C++，`For Each`在 Visual Basic 中) 隐藏了枚举器的复杂性。 因此，建议使用 `foreach`，而不是直接操作枚举数。  
  
 枚举器可用于读取集合中的数据，但不能用于修改基础集合。  
  
 最初，枚举数定位在集合中第一个元素的前面。 <xref:System.Collections.IEnumerator.Reset%2A> 也会将枚举器放回此位置。  在此位置上，<xref:System.Collections.IEnumerator.Current%2A>未定义属性。 因此，您必须调用<xref:System.Collections.IEnumerator.MoveNext%2A>方法将枚举数前移到集合，然后再读取的值的第一个元素<xref:System.Collections.IEnumerator.Current%2A>。  
  
 <xref:System.Collections.IEnumerator.Current%2A>属性返回同一个对象，直到<xref:System.Collections.IEnumerator.MoveNext%2A>或<xref:System.Collections.IEnumerator.Reset%2A>调用。 <xref:System.Collections.IEnumerator.MoveNext%2A> 将 <xref:System.Collections.IEnumerator.Current%2A> 设置为下一个元素。  
  
 如果<xref:System.Collections.IEnumerator.MoveNext%2A>越过集合，枚举器的末尾放置在集合中的最后一个元素的后面和<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`。 当枚举数位于此位置上，对后续调用<xref:System.Collections.IEnumerator.MoveNext%2A>还返回`false`。 如果最后一次调用到<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`，<xref:System.Collections.IEnumerator.Current%2A>是不确定的。 若要再次将 <xref:System.Collections.IEnumerator.Current%2A> 设置为集合的第一个元素，可以调用 <xref:System.Collections.IEnumerator.Reset%2A> 并接着调用 <xref:System.Collections.IEnumerator.MoveNext%2A>。  
  
 只要集合保持不变，枚举数就保持有效。 如果进行了更改到集合中，例如添加、 修改或删除元素，该枚举数将失效且不可恢复，并且下次调用<xref:System.Collections.IEnumerator.MoveNext%2A>或<xref:System.Collections.IEnumerator.Reset%2A>引发<xref:System.InvalidOperationException>。  
  
 枚举数没有对集合的独占访问权；因此，从头到尾对一个集合进行枚举在本质上不是一个线程安全的过程。  若要确保枚举过程中的线程安全性，可以在整个枚举过程中锁定集合。  若要允许多个线程访问集合以进行读写操作，则必须实现自己的同步。  
  
 <xref:System.Collections.Generic?displayProperty=nameWithType> 命名空间中集合的默认实现是不同步的。  
  
 此方法为 o （1） 运算。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (item As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ item) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">要添加到 <see cref="T:System.Object" /> 的 <see cref="T:System.Collections.IList" />。</param>
        <summary>将某项添加到 <see cref="T:System.Collections.IList" /> 中。</summary>
        <returns>新元素的插入位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Collections.Generic.List%601.Count%2A>是小于<xref:System.Collections.Generic.List%601.Capacity%2A>，此方法为 o （1） 运算。 如果需要增加以容纳新元素的容量，此方法将成为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> 属于不能分配给 <see cref="T:System.Collections.IList" /> 的类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (item As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ item) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">要在 <see cref="T:System.Object" /> 中定位的 <see cref="T:System.Collections.IList" />。</param>
        <summary>确定 <see cref="T:System.Collections.IList" /> 是否包含特定值。</summary>
        <returns>如果在 <see langword="true" /> 中找到 <paramref name="item" />，则为 <see cref="T:System.Collections.IList" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可确定是否使用默认的相等比较的相等<xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>为`T`，列表中的值的类型。  
  
 此方法执行线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (item As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ item) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">要在 <see cref="T:System.Collections.IList" /> 中定位的对象。</param>
        <summary>确定 <see cref="T:System.Collections.IList" /> 中特定项的索引。</summary>
        <returns>如果在列表中找到，则为 <paramref name="item" /> 的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可确定是否使用默认的相等比较的相等<xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>为`T`，列表中的值的类型。  
  
 此方法执行线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> 属于不能分配给 <see cref="T:System.Collections.IList" /> 的类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, item As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ item) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">应插入 <paramref name="item" /> 的从零开始的索引。</param>
        <param name="item">要插入到 <see cref="T:System.Collections.IList" /> 中的对象。</param>
        <summary>在 <see cref="T:System.Collections.IList" /> 中的指定索引处插入一个项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 `index` 等于 <xref:System.Collections.IList> 中的项数，则将 `item` 追加到末尾。  
  
 此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 不是 <see cref="T:System.Collections.IList" /> 中的有效索引。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> 属于不能分配给 <see cref="T:System.Collections.IList" /> 的类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Collections.IList" /> 是否具有固定大小。</summary>
        <value>如果 <see langword="true" /> 具有固定大小，则为 <see cref="T:System.Collections.IList" />；否则为 <see langword="false" />。  在 <see cref="T:System.Collections.Generic.List`1" /> 的默认实现中，此属性始终返回 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 具有固定大小的集合在创建之后不能再添加或移除元素，但是允许修改现有元素。  
  
 具有固定大小的集合只是一个集合与防止添加和移除元素; 的包装器因此，如果在更改基础集合，包括添加或删除的元素，大小固定集合反映了这些更改。  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Collections.IList" /> 是否为只读。</summary>
        <value>如果 <see langword="true" /> 是只读的，则为 <see cref="T:System.Collections.IList" />；否则为 <see langword="false" />。  在 <see cref="T:System.Collections.Generic.List`1" /> 的默认实现中，此属性始终返回 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在创建只读集合后，该集合不允许添加、移除或修改元素。  
  
 集合是只读的只是一个集合与可防止修改集合; 的包装器因此，如果对基础集合进行更改，只读集合反映了这些更改。  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IList::Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要获取或设置的元素的从零开始的索引。</param>
        <summary>获取或设置指定索引处的元素。</summary>
        <value>指定索引处的元素。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 C# 语言[这](~/docs/csharp/language-reference/keywords/this.md)关键字来定义而不是实现索引器<xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A>属性。 Visual Basic 将 <xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A> 实现为默认属性，该属性提供相同的索引功能。  
  
 检索此属性的值是 o （1） 的操作;将属性设置也是 o （1） 操作。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 不是 <see cref="T:System.Collections.IList" /> 中的有效索引。</exception>
        <exception cref="T:System.ArgumentException">已设置属性，且 <paramref name="value" /> 属于不能对 <see cref="T:System.Collections.IList" /> 赋值的类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (item As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ item) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">要从 <see cref="T:System.Collections.IList" /> 中删除的对象。</param>
        <summary>从 <see cref="T:System.Collections.IList" /> 中移除特定对象的第一个匹配项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可确定是否使用默认的相等比较的相等<xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>为`T`，列表中的值的类型。  
  
 此方法执行线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> 属于不能分配给 <see cref="T:System.Collections.IList" /> 的类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="list.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将 <see cref="T:System.Collections.Generic.List`1" /> 的元素复制到新数组中。</summary>
        <returns>一个数组，它包含 <see cref="T:System.Collections.Generic.List`1" /> 的元素的副本。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用复制元素<xref:System.Array.Copy%2A?displayProperty=nameWithType>，这是 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
 此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Collections.Generic.List%601.ToArray%2A>方法和其他方法<xref:System.Collections.Generic.List%601>对范围进行操作的类。 在此示例中，末尾<xref:System.Collections.Generic.List%601.GetRange%2A>方法用于从列表中，从开始的索引位置 2 获取三个项。 <xref:System.Collections.Generic.List%601.ToArray%2A>方法调用所产生<xref:System.Collections.Generic.List%601>，创建三个元素的数组。 将显示数组的元素。  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberSignature Language="F#" Value="member this.TrimExcess : unit -&gt; unit" Usage="list.TrimExcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将容量设置为 <see cref="T:System.Collections.Generic.List`1" /> 中的实际元素数目（如果该数目小于某个阈值）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可用于最小化集合的内存开销如果任何新元素将不添加到集合。 重新分配和复制较大的成本<xref:System.Collections.Generic.List%601>但是，有时会很大，因此<xref:System.Collections.Generic.List%601.TrimExcess%2A>方法不会执行任何操作，如果列表为在多个容量的 90%。 这样可以避免产生相对较小增益的大型的重新分配费用。  
  
> [!NOTE]
>  90%的当前阈值可能会更改在将来的版本。  
  
 此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
 若要重置<xref:System.Collections.Generic.List%601>为其初始状态，请在调用<xref:System.Collections.Generic.List%601.Clear%2A>方法之前调用<xref:System.Collections.Generic.List%601.TrimExcess%2A>方法。 截去空<xref:System.Collections.Generic.List%601>的容量设置<xref:System.Collections.Generic.List%601>到默认容量。  
  
 也可以使用设置容量<xref:System.Collections.Generic.List%601.Capacity%2A>属性。  
  
   
  
## Examples  
 下面的示例演示如何检查的容量和计数<xref:System.Collections.Generic.List%601>，其中包含简单的业务对象，说明了如何使用<xref:System.Collections.Generic.List%601.TrimExcess%2A>方法以删除额外的容量。  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 下面的示例演示<xref:System.Collections.Generic.List%601.TrimExcess%2A>方法。 一些属性和方法的<xref:System.Collections.Generic.List%601>类用于添加、 插入和删除字符串的列表项。 然后<xref:System.Collections.Generic.List%601.TrimExcess%2A>方法用于减少容量以匹配计数，并<xref:System.Collections.Generic.List%601.Capacity%2A>和<xref:System.Collections.Generic.List%601.Count%2A>属性将显示。 如果未使用的容量小于 10%的总容量，列表将不具有已调整大小。 最后，将清除列表的内容。  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.Clear" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="TrueForAll">
      <MemberSignature Language="C#" Value="public bool TrueForAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrueForAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TrueForAll (match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrueForAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.TrueForAll : Predicate&lt;'T&gt; -&gt; bool" Usage="list.TrueForAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match"><see cref="T:System.Predicate`1" /> 委托，定义要据以检查元素的条件。</param>
        <summary>确定是否 <see cref="T:System.Collections.Generic.List`1" /> 中的每个元素都与指定的谓词所定义的条件相匹配。</summary>
        <returns>如果 <see cref="T:System.Collections.Generic.List`1" /> 中的每个元素都与指定的谓词所定义的条件相匹配，则为 <see langword="true" />；否则为 <see langword="false" />。 如果列表没有元素，则返回值为 <see langword="true" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>是返回的方法的委托`true`如果该对象传递给委托中定义的条件匹配。  当前元素<xref:System.Collections.Generic.List%601>逐个传递给<xref:System.Predicate%601>委托，并处理在委托返回时已停止`false`的任何元素。 元素的处理顺序，并且所有调用都都是单个线程上。  
  
 此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Collections.Generic.List%601.TrueForAll%2A>方法和其他几种方法使用<xref:System.Predicate%601>泛型委托。  
  
 一个<xref:System.Collections.Generic.List%601>的字符串创建，包含 8 个恐龙名称，其中 （位于位置 1 和 5） 两个以"saurus"结尾。 该示例还定义一个名为搜索谓词的方法`EndsWithSaurus`、，它接受字符串参数和返回一个布尔值，该值指示是否以"saurus"结尾的输入的字符串。  
  
 <xref:System.Collections.Generic.List%601.TrueForAll%2A>方法开始时，将每个元素传递给又从遍历列表`EndsWithSaurus`方法。 搜索将停止何时`EndsWithSaurus`方法将返回`false`。  
  
> [!NOTE]
>  在 C# 和 Visual Basic 中，它不需要创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中) 显式。 这些语言推断从上下文正确的委托，并自动创建。  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>