<Type Name="ClientScriptManager" FullName="System.Web.UI.ClientScriptManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f75d704bbe231919966e4fc5a123f6ed1bb202ac" /><Meta Name="ms.sourcegitcommit" Value="9a6da88bd5455e8274257ca7ad259b42f1de114f" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="05/22/2019" /><Meta Name="ms.locfileid" Value="66005935" /></Metadata><TypeSignature Language="C#" Value="public sealed class ClientScriptManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ClientScriptManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.ClientScriptManager" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ClientScriptManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ClientScriptManager sealed" />
  <TypeSignature Language="F#" Value="type ClientScriptManager = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>在 Web 应用程序中定义用于管理客户端脚本的方法。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager>类可用来管理客户端脚本并将其添加到 Web 应用程序。 可以获取对的引用<xref:System.Web.UI.ClientScriptManager>类派生<xref:System.Web.UI.Page.ClientScript%2A>属性的<xref:System.Web.UI.Page>对象。  
  
 您可以添加客户端脚本到 Web 页以声明方式通过在页面的 HTML 标记中包含该脚本。 但是，有些情况下需要动态添加客户端脚本。 若要动态添加脚本时，使用<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法，<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>方法，<xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>方法，或<xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A>方法，具体取决于何时以及如何你想要添加脚本。 有关详细信息，请参阅[如何：将客户端脚本动态添加到 ASP.NET 网页](https://msdn.microsoft.com/library/e89f1306-e43d-49ae-a66a-e18b71007666)。  
  
 <xref:System.Web.UI.ClientScriptManager>类唯一地标识脚本按的键<xref:System.String>和一个<xref:System.Type>。 具有相同的键和类型的脚本被视为重复项。 使用脚本类型有助于避免令人困惑的类似脚本从不同的用户可能正在使用的页上的控件。  
  
 <xref:System.Web.UI.ClientScriptManager>类可用于需要从客户端运行服务器代码，而不执行回发时所调用的情况的。 这称为执行的带回调到服务器。 在客户端回调中，客户端脚本函数将异步请求发送到 ASP.NET 网页。 网页上运行来处理回调的其常规生命周期的修改的版本。 使用<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>方法来获取的客户端函数的引用，在调用时，将启动针对服务器事件的客户端回调。 有关详细信息，请参阅[实现客户端回调而不回发](https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185)。  
  
> [!NOTE]
>  脚本回调将不工作较旧的浏览器中不支持文档对象模型 (DOM)，并且它们需要客户端上启用了 ECMAScript。 若要检查浏览器是否支持回调，请使用<xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A>属性，它是可通过访问<xref:System.Web.HttpRequest.Browser%2A>属性的内部 ASP.NET<xref:System.Web.HttpContext.Request%2A>对象。  
  
 使用<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>方法和<xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A>方法以定义客户端回发事件。 这些方法启用客户端脚本函数中，在调用，将导致服务器回发到页面。 客户端回发事件的不同于客户端回调在于 Web 页完成正常的生命周期处理客户端回发事件。  
  
> [!NOTE]
>  如果使用的<xref:System.Web.UI.WebControls.Button>控件和<xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A>属性设置为`false`，然后，可以使用<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>方法以返回客户端回发事件<xref:System.Web.UI.WebControls.Button>控件。  
  
 <xref:System.Web.UI.WebControls.Button.OnClientClick%2A>的属性<xref:System.Web.UI.WebControls.Button>控件，<xref:System.Web.UI.WebControls.ImageButton>控件，并<xref:System.Web.UI.WebControls.LinkButton>控件可用于运行客户端脚本。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法的<xref:System.Web.UI.ClientScriptManager>类。 页中定义两个客户端脚本： `PopupScript`，这将加载页面时，显示一条警告消息和`ButtonClickScript`，用于定义客户端处理程序的 HTML 按钮`onClick`事件。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.Page" />
    <altmember cref="P:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback" />
    <altmember cref="P:System.Web.Configuration.HttpCapabilitiesBase.SupportsXmlHttp" />
    <related type="Article" href="https://msdn.microsoft.com/library/13edb6b9-2dea-43c6-b8c1-a47207de19aa">在 ASP.NET Web Pages 中的客户端脚本</related>
    <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">客户端回调，而无需在 ASP.NET 页回发</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="GetCallbackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取一个对客户端函数的引用；调用该函数时，将启动一个对服务器事件的客户端回调。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : System.Web.UI.Control * string * string * string -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (control, argument, clientCallback, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">处理客户端回调的服务器 <see cref="T:System.Web.UI.Control" />。 该控件必须实现 <see cref="T:System.Web.UI.ICallbackEventHandler" /> 接口并提供 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 方法。</param>
        <param name="argument">从客户端脚本传递给服务器的一个参数 
 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 方法。</param>
        <param name="clientCallback">一个客户端事件处理程序的名称，该处理程序接收成功的服务器事件的结果。</param>
        <param name="context">启动回调之前在客户端计算的客户端脚本。 脚本的结果传回客户端事件处理程序。</param>
        <summary>获取一个对客户端函数的引用；调用该函数时，将启动一个对服务器事件的客户端回调。 此重载方法的客户端函数包含指定的控件、参数、客户端脚本和上下文。</summary>
        <returns>调用客户端回调的客户端函数的名称。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%28System.Web.UI.Control%2CSystem.String%2CSystem.String%2CSystem.String%29>方法执行的带回调到服务器的页面的常规生命周期的修改的版本。 有关详细信息，请参阅[实现客户端回调而不回发](https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185)。  
  
> [!NOTE]
>  当浏览器是 Microsoft Internet Explorer （版本 5.0 或更高版本） 时，脚本回调机制通过 Microsoft.XmlHttp COM 对象实现，并且需要在浏览器设置为运行 ActiveX 控件。 对于其他浏览器，使用 XMLHttpRequest 使用浏览器的本地文档对象模型 (DOM)。 若要检查浏览器是否支持客户端回调，请使用<xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A>属性。 若要检查浏览器是否支持通过 HTTP XML，请使用<xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsXmlHttp%2A>属性。 这两个属性都可以通过访问<xref:System.Web.HttpRequest.Browser%2A>属性的内部 ASP.NET<xref:System.Web.HttpContext.Request%2A>对象。  
  
 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>重载<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>方法执行的回调以同步方式使用 HTTP 上的 XML。 当数据以同步方式发送回调情形中，同步回调立即返回，并且不会阻止在浏览器。 没有两个同步回调可以在同一时间在浏览器中执行。 如果其中一个是当前处于挂起状态时触发的第二个同步回调，第二个同步回调取消第一个且仅在第二个回调会返回。  
  
 若要以异步方式发送数据，请使用采用的重载之一`useAsync`参数，它是一个布尔值，用于控制此行为。 在异步方案中可以有多个挂起的回调;但是，它们返回的顺序不保证按照启动时的顺序相匹配。  
  
 此外，此重载<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>方法指定无客户端函数以处理生成的错误条件的情况<xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A>方法。 若要指定客户端错误回调处理程序，请使用采用的重载之一`clientErrorCallback`参数。  
  
 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%28System.Web.UI.Control%2CSystem.String%2CSystem.String%2CSystem.String%29>方法采用一个可选的字符串`argument`参数并返回一个字符串。 若要在传递或接收多个值，连接中输入的值或字符串，将分别返回。  
  
> [!NOTE]
>  避免使用需要脚本回调操作期间更新的页或控件属性的实现中的视图状态。 如果属性是可以经受住页面请求，可以使用会话状态。  
  
   
  
## Examples  
 下面的代码示例演示如何使用两种重载<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>递增整数客户端回调情形中的方法。  
  
 两种回调机制都会显示出来;它们之间的区别是使用`context`参数。 一个`ReceiveServerData1`提供客户端回调函数则使用`context`参数。 与此相反，`ReceiveServerData2`中定义客户端回调函数`<script>`页上的块。 一个<xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A>方法是递增的值传递给它的服务器处理程序和<xref:System.Web.UI.ICallbackEventHandler.GetCallbackResult%2A>方法将返回以字符串形式递增的值。 如果<xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A>方法将返回错误，则`ProcessCallBackError`调用客户端函数。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/cs/getcallbackeventreference.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/vb/getcallbackeventreference.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">指定的 <see cref="T:System.Web.UI.Control" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">指定的 <see cref="T:System.Web.UI.Control" /> 未实现 <see cref="T:System.Web.UI.ICallbackEventHandler" /> 接口。</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">客户端回调，而无需在 ASP.NET 页回发</related>
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, bool useAsync);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : System.Web.UI.Control * string * string * string * bool -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (control, argument, clientCallback, context, useAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">处理客户端回调的服务器 <see cref="T:System.Web.UI.Control" />。 该控件必须实现 <see cref="T:System.Web.UI.ICallbackEventHandler" /> 接口并提供 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 方法。</param>
        <param name="argument">从客户端脚本传递给服务器的一个参数 
 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 方法。</param>
        <param name="clientCallback">一个客户端事件处理程序的名称，该处理程序接收成功的服务器事件的结果。</param>
        <param name="context">启动回调之前在客户端计算的客户端脚本。 脚本的结果传回客户端事件处理程序。</param>
        <param name="useAsync"><see langword="true" /> 表示异步执行回调；<see langword="false" /> 表示同步执行回调。</param>
        <summary>获取一个对客户端函数的引用；调用该函数时，将启动一个对服务器事件的客户端回调。 此重载方法的客户端函数包含指定的控件、参数、客户端脚本、上下文和布尔值。</summary>
        <returns>调用客户端回调的客户端函数的名称。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>方法要求`useAsync`参数，它允许您通过将值设置为以异步方式执行客户端回调`true`。 不需要此方法的重载版本`useAsync`参数将值设置为`false`默认情况下。  
  
 此方法的详细信息，请参阅用于重载备注<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">指定的 <see cref="T:System.Web.UI.Control" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">指定的 <see cref="T:System.Web.UI.Control" /> 未实现 <see cref="T:System.Web.UI.ICallbackEventHandler" /> 接口。</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">客户端回调，而无需在 ASP.NET 页回发</related>
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (string target, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(string target, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.String,System.String,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCallbackEventReference (target As String, argument As String, clientCallback As String, context As String, clientErrorCallback As String, useAsync As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::String ^ target, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, System::String ^ clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : string * string * string * string * string * bool -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (target, argument, clientCallback, context, clientErrorCallback, useAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="clientErrorCallback" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="target">处理客户端回调的服务器 <see cref="T:System.Web.UI.Control" /> 的名称。 该控件必须实现 <see cref="T:System.Web.UI.ICallbackEventHandler" /> 接口并提供 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 方法。</param>
        <param name="argument">从客户端脚本传递给服务器的一个参数 
 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 方法。</param>
        <param name="clientCallback">一个客户端事件处理程序的名称，该处理程序接收成功的服务器事件的结果。</param>
        <param name="context">启动回调之前在客户端计算的客户端脚本。 脚本的结果传回客户端事件处理程序。</param>
        <param name="clientErrorCallback">客户端事件处理程序的名称，该处理程序在服务器端事件处理程序出现错误时接收结果。</param>
        <param name="useAsync"><see langword="true" /> 表示异步执行回调；<see langword="false" /> 表示同步执行回调。</param>
        <summary>获取一个对客户端函数的引用；调用该函数时，将启动一个对服务器事件的客户端回调。 此重载方法的客户端函数包含指定的目标、参数、客户端脚本、上下文、错误处理程序和布尔值。</summary>
        <returns>调用客户端回调的客户端函数的名称。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>方法采用`target`字符串而不是参数<xref:System.Web.UI.Control>参数。 当你想要返回到一个字符串，包含以外的内容的回调时，请使用此重载<xref:System.Web.UI.Control.UniqueID%2A>的控件。  
  
 此外，此重载<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>方法要求`useAsync`和一个`clientErrorCallback`参数。 `useAsync`参数，可通过将值设置为以异步方式执行客户端回调`true`。 不需要此方法的重载版本`useAsync`参数将值设置为`false`默认情况下。 `clientErrorCallback`参数，可定义如果，则调用的客户端函数的名称服务器的处理程序，<xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A>方法，将返回错误。 不需要此方法的重载版本`clientErrorCallback`参数将值设置为 null。  
  
 此方法的详细信息，请参阅用于重载备注<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>方法。  
  
   
  
## Examples  
 下面的代码示例演示如何使用两种重载<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>递增整数客户端回调情形中的方法。  
  
 两种回调机制都会显示出来;它们之间的区别是使用`context`参数。 一个`ReceiveServerData1`提供客户端回调函数则使用`context`参数。 与此相反，`ReceiveServerData2`中定义客户端回调函数`<script>`页上的块。 一个<xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A>方法是递增的值传递给它的服务器处理程序和<xref:System.Web.UI.ICallbackEventHandler.GetCallbackResult%2A>方法将返回以字符串形式递增的值。 如果<xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A>方法将返回错误，则客户端函数`ProcessCallBackError`调用。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/cs/getcallbackeventreference.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/vb/getcallbackeventreference.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <altmember cref="P:System.Web.UI.Control.UniqueID" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">客户端回调，而无需在 ASP.NET 页回发</related>
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, System::String ^ clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : System.Web.UI.Control * string * string * string * string * bool -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (control, argument, clientCallback, context, clientErrorCallback, useAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="clientErrorCallback" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">处理客户端回调的服务器 <see cref="T:System.Web.UI.Control" />。 该控件必须实现 <see cref="T:System.Web.UI.ICallbackEventHandler" /> 接口并提供 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 方法。</param>
        <param name="argument">从客户端脚本传递给服务器的 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 方法的参数。</param>
        <param name="clientCallback">一个客户端事件处理程序的名称，该处理程序接收成功的服务器事件的结果。</param>
        <param name="context">启动回调之前在客户端计算的客户端脚本。 脚本的结果传回客户端事件处理程序。</param>
        <param name="clientErrorCallback">客户端事件处理程序的名称，该处理程序在服务器端事件处理程序出现错误时接收结果。</param>
        <param name="useAsync"><see langword="true" /> 表示异步执行回调；<see langword="false" /> 表示同步执行回调。</param>
        <summary>获取一个对客户端函数的引用；调用该函数时，将启动一个对服务器事件的客户端回调。 此重载方法的客户端函数包含指定的控件、参数、客户端脚本、上下文、错误处理程序和布尔值。</summary>
        <returns>调用客户端回调的客户端函数的名称。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>方法要求`useAsync`和一个`clientErrorCallback`参数。 `useAsync`参数，可通过将值设置为以异步方式执行客户端回调`true`。 不需要此方法的重载版本`useAsync`参数将值设置为`false`默认情况下。 `clientErrorCallback`参数，可定义如果，则调用的客户端函数的名称的服务器处理程序 (<xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A>方法) 将返回错误。 不需要此方法的重载版本`clientErrorCallback`参数将值设置为 null。  
  
 此方法的详细信息，请参阅用于重载备注<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">指定的 <see cref="T:System.Web.UI.Control" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">指定的 <see cref="T:System.Web.UI.Control" /> 未实现 <see cref="T:System.Web.UI.ICallbackEventHandler" /> 接口。</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">客户端回调，而无需在 ASP.NET 页回发</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackClientHyperlink">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取一个引用，并将 <see langword="javascript:" /> 追加到引用的开始处，用于在客户端事件中回发到服务器。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientHyperlink(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackClientHyperlink : System.Web.UI.Control * string -&gt; string" Usage="clientScriptManager.GetPostBackClientHyperlink (control, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">处理回发的服务器控件。</param>
        <param name="argument">传递给服务器控件的参数。</param>
        <summary>获取一个引用，并在其开头附加 <see langword="javascript:" />，可以在客户端事件中使用该引用，并将该引用与指定的事件参数一起使用，以便回发到指定控件的服务器。</summary>
        <returns>一个字符串，表示对包含目标控件的 ID 和事件参数的回发函数的 JavaScript 调用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>方法需要处理回发来实现的控件<xref:System.Web.UI.IPostBackEventHandler>接口。 若要实现<xref:System.Web.UI.IPostBackEventHandler>接口<xref:System.Web.UI.Page>，使用指令。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A>方法。 自定义控件`MyControl`，实现<xref:System.Web.UI.IPostBackEventHandler>接口。 单击页面上的 HTML 定位点元素时，<xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A>调用自定义控件的方法。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreferencecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreferencevb.aspx#1)]  
  
 下面的代码示例具有相同的功能与前面的一个，而不是自定义控件，只不过<xref:System.Web.UI.Page>类实现<xref:System.Web.UI.IPostBackEventHandler>接口。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreference2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreference2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientHyperlink(System::Web::UI::Control ^ control, System::String ^ argument, bool registerForEventValidation);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackClientHyperlink : System.Web.UI.Control * string * bool -&gt; string" Usage="clientScriptManager.GetPostBackClientHyperlink (control, argument, registerForEventValidation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">处理回发的服务器控件。</param>
        <param name="argument">传递给服务器控件的参数。</param>
        <param name="registerForEventValidation"><see langword="true" /> 表示为验证注册回发事件；<see langword="false" /> 表示不为验证注册回发事件。</param>
        <summary>获取一个引用，并在其开头附加 <see langword="javascript:" />，该引用可用于在客户端事件中回发到指定控件的服务器，回发时使用指定的事件参数和一个指示是否为事件验证注册该回发的布尔值。</summary>
        <returns>一个字符串，表示对包含目标控件的 ID 和事件参数的回发函数的 JavaScript 调用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>方法需要处理回发来实现的控件<xref:System.Web.UI.IPostBackEventHandler>接口。 若要实现<xref:System.Web.UI.IPostBackEventHandler>接口<xref:System.Web.UI.Page>，使用指令。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一个可以在客户端事件中使用的字符串，以便回发到服务器。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.PostBackOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.PostBackOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.PostBackOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackEventReference (options As PostBackOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::PostBackOptions ^ options);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.PostBackOptions -&gt; string" Usage="clientScriptManager.GetPostBackEventReference options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
      </Parameters>
      <Docs>
        <param name="options">定义回发的 <see cref="T:System.Web.UI.PostBackOptions" />。</param>
        <summary>返回一个可以在客户端事件中使用的字符串，以便回发到服务器。 由指定的 <see cref="T:System.Web.UI.PostBackOptions" /> 实例定义的字符串。</summary>
        <returns>一个字符串，当被视为客户端脚本时，它将启动客户端回发。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要实现<xref:System.Web.UI.IPostBackEventHandler>接口<xref:System.Web.UI.Page>，使用指令。  
  
 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>方法可用于<xref:System.Web.UI.WebControls.Button>控制何时<xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A>属性是`false`。 在此方案中，<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>方法将返回客户端回发事件<xref:System.Web.UI.WebControls.Button>控件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="T:System.Web.UI.PostBackOptions" /> 参数为 <see langword="null" /></exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <altmember cref="T:System.Web.UI.WebControls.Button" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">客户端回调，而无需在 ASP.NET 页回发</related>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.Control * string -&gt; string" Usage="clientScriptManager.GetPostBackEventReference (control, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">在服务器上处理回发的服务器 <see cref="T:System.Web.UI.Control" />。</param>
        <param name="argument">要传递给处理回发的控件的可选参数字符串。</param>
        <summary>返回一个可以在客户端事件中使用的字符串，以便回发到服务器。 该引用字符串由处理回发的指定控件和一个附加事件信息的字符串参数定义。</summary>
        <returns>一个字符串，将其视为客户端脚本时，将启动回发。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要实现<xref:System.Web.UI.IPostBackEventHandler>接口<xref:System.Web.UI.Page>，使用指令。  
  
 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>方法可用于<xref:System.Web.UI.WebControls.Button>控制何时<xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A>属性是`false`。 在此方案中，<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>方法将返回客户端回发事件<xref:System.Web.UI.WebControls.Button>控件。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>方法。 自定义控件`MyControl`，实现<xref:System.Web.UI.IPostBackEventHandler>接口。 单击页面上的按钮时，<xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A>调用自定义控件的方法。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreferencecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreferencevb.aspx#1)]  
  
 下面的代码示例具有相同的功能与前面的一个，而不是自定义控件，只不过<xref:System.Web.UI.Page>类实现<xref:System.Web.UI.IPostBackEventHandler>接口。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreference2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreference2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">指定的 <see cref="T:System.Web.UI.Control" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">客户端回调，而无需在 ASP.NET 页回发</related>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.PostBackOptions options, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.PostBackOptions options, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.PostBackOptions,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackEventReference (options As PostBackOptions, registerForEventValidation As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::PostBackOptions ^ options, bool registerForEventValidation);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.PostBackOptions * bool -&gt; string" Usage="clientScriptManager.GetPostBackEventReference (options, registerForEventValidation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="options">定义回发的 <see cref="T:System.Web.UI.PostBackOptions" />。</param>
        <param name="registerForEventValidation"><see langword="true" /> 表示为验证注册事件引用；否则为 <see langword="false" />。</param>
        <summary>返回一个可以在客户端事件中使用的字符串，以便回发到服务器。 由指定的 <see cref="T:System.Web.UI.PostBackOptions" /> 对象定义的字符串。 可选择为验证注册事件引用。</summary>
        <returns>一个字符串，当被视为客户端脚本时，它将启动客户端回发。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要实现<xref:System.Web.UI.IPostBackEventHandler>接口<xref:System.Web.UI.Page>对象，请使用该指令。  
  
 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>方法可用于<xref:System.Web.UI.WebControls.Button>控制何时<xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A>属性是`false`。 在此方案中，<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>方法将返回客户端回发事件<xref:System.Web.UI.WebControls.Button>控件。  
  
 如果`registerForEventValidation`是`true`，则<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%28System.Web.UI.PostBackOptions%2CSystem.Boolean%29>方法调用<xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%28System.String%2CSystem.String%29>方法以向表示生成事件的客户端控件的唯一控件 ID 注册事件引用以进行验证。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="T:System.Web.UI.PostBackOptions" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <altmember cref="T:System.Web.UI.WebControls.Button" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">客户端回调，而无需在 ASP.NET 页回发</related>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, bool registerForEventValidation);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.Control * string * bool -&gt; string" Usage="clientScriptManager.GetPostBackEventReference (control, argument, registerForEventValidation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">在服务器上处理回发的服务器 <see cref="T:System.Web.UI.Control" />。</param>
        <param name="argument">传递给 <paramref name="control" /> 的可选参数的字符串。</param>
        <param name="registerForEventValidation"><see langword="true" /> 表示为验证注册事件引用；否则为 <see langword="false" />。</param>
        <summary>返回一个在客户端事件中使用的字符串，以便回发到服务器。 该引用字符串由处理回发的指定控件和一个附加事件信息的字符串参数定义。 可选择为验证注册事件引用。</summary>
        <returns>一个字符串，将其视为客户端脚本时，将启动回发。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要实现<xref:System.Web.UI.IPostBackEventHandler>接口<xref:System.Web.UI.Page>，使用指令。  
  
 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>方法可用于<xref:System.Web.UI.WebControls.Button>控制何时<xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A>属性是`false`。 在此方案中，<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>方法将返回客户端回发事件<xref:System.Web.UI.WebControls.Button>控件。  
  
 如果`registerForEventValidation`为 true，<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%28System.Web.UI.PostBackOptions%2CSystem.Boolean%29>方法调用<xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%28System.String%2CSystem.String%29>方法以向表示生成事件的客户端控件的唯一控件 ID 注册事件引用以进行验证。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">指定的 <see cref="T:System.Web.UI.Control" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">客户端回调，而无需在 ASP.NET 页回发</related>
      </Docs>
    </Member>
    <Member MemberName="GetWebResourceUrl">
      <MemberSignature Language="C#" Value="public string GetWebResourceUrl (Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetWebResourceUrl(class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetWebResourceUrl(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetWebResourceUrl(Type ^ type, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="member this.GetWebResourceUrl : Type * string -&gt; string" Usage="clientScriptManager.GetWebResourceUrl (type, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">资源类型。</param>
        <param name="resourceName">程序集中资源的完全限定名称。</param>
        <summary>获取对程序集内资源的 URL 引用。</summary>
        <returns>对资源的 URL 引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A>方法将返回到程序集中嵌入的资源的 URL 引用。 返回的引用不是 URL 编码。 资源可以是脚本文件、 图像或任何静态文件。 指定基于将访问资源的对象的类型。  
  
 由其类型和名称唯一标识注册到页面的 Web 资源。 可以向页注册与给定的类型和名称对一个资源。 尝试注册已注册的资源不会创建重复的已注册的资源。  
  
 <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A>结合使用方法<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A>的方法来访问资源嵌入在程序集中。 应用程序中使用的资源的详细信息，请参阅[ASP.NET Web Page Resources Overview](https://msdn.microsoft.com/library/0936b3b2-9e6e-4abe-9c06-364efef9dbbd)。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A>方法。 *类型*在此示例中的参数设置为包含资源的程序集中的类的类型。 `resourceName`参数指定了资源，其中包括默认命名空间的完全限定路径。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/clientscriptwebresource.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/clientscriptwebresource.aspx#1)]  
  
 下面的代码示例演示如何以编程方式应用<xref:System.Web.UI.WebResourceAttribute>元数据特性标记会提供服务的资源的程序集。 使用默认命名空间设置为编译的类库中的以下类`Samples.AspNet.CS.Controls`或`Samples.AspNet.VB.Controls`，取决于您使用何种语言。  
  
 [!code-csharp[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/resource.cs#2)]
 [!code-vb[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/resource.vb#2)]  
  
 此示例需要名为的 JavaScript 文件`Script_include.js`。 .Js 文件是包含在程序集中嵌入的资源`ClientScriptResourceLabel`对象。 如果使用的 Visual Studio 中，在类库项目的属性窗口中，设置**生成操作**到**嵌入的资源**选中的脚本文件。 如果您正在编译的库在命令行，使用[/resource](~/docs/csharp/language-reference/compiler-options/resource-compiler-option.md)交换机嵌入资源。  
  
```  
function DoClick() {Form1.Message.value='Text from resource script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Web 资源类型为 <see langword="null" />。

- 或 -

Web 资源名称为 <see langword="null" />。  
  
或 
Web 资源名称长度为零。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptResource(System.Type,System.String)" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
        <altmember cref="T:System.Web.Handlers.AssemblyResourceLoader" />
        <related type="Article" href="https://msdn.microsoft.com/library/0936b3b2-9e6e-4abe-9c06-364efef9dbbd">ASP.NET 网页资源概述</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5212666e-98ab-47e4-a497-b5545ab15c7f">/resource （输出到嵌入资源文件） （C# 编译器选项）</related>
        <related type="Article" href="https://msdn.microsoft.com/library/eee2f227-91f2-4f2b-a9d6-1c51c5320858">/resource (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsClientScriptBlockRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>确定 <see cref="T:System.Web.UI.Page" /> 对象是否注册了客户端脚本块。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptBlockRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptBlockRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptBlockRegistered : string -&gt; bool" Usage="clientScriptManager.IsClientScriptBlockRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">要搜索的客户端脚本块的键。</param>
        <summary>使用指定键确定 <see cref="T:System.Web.UI.Page" /> 对象是否注册了客户端脚本块。</summary>
        <returns>如果注册了客户端脚本块，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法之前调用<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法可避免注册重复的脚本。 这一点尤其重要，如果该脚本需要大量的服务器资源来创建。  
  
 由它的键和其类型唯一标识客户端脚本。 具有相同的键和类型的脚本被视为重复项。  
  
 此重载<xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A>方法调用的重载的同时`key`和一个`type`与类型参数设置为<xref:System.Web.UI.Page>对象  
  
   
  
## Examples  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb2.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptBlockRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptBlockRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsClientScriptBlockRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要搜索的客户端脚本块的类型。</param>
        <param name="key">要搜索的客户端脚本块的键。</param>
        <summary>使用键和类型确定 <see cref="T:System.Web.UI.Page" /> 对象是否注册了客户端脚本块。</summary>
        <returns>如果注册了客户端脚本块，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法之前调用<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法可避免注册重复的脚本。 这一点尤其重要，如果该脚本需要大量的服务器资源来创建。  
  
 由它的键和其类型唯一标识客户端脚本。 具有相同的键和类型的脚本被视为重复项。 指定基于将访问资源的对象的类型。 例如，使用时`Page`实例访问该资源，则指定`Page`类型。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A>方法。 请注意，是否逻辑来检查现有的客户端脚本块被移除，则在呈现的页面的 HTML 源代码中不会两个重复的客户端脚本，因为<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法检查是否有重复项。 检查的好处是减少不必要的计算。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">客户端脚本类型为 <see langword="null" />。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsClientScriptIncludeRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>确定 <see cref="T:System.Web.UI.Page" /> 对象是否注册了客户端脚本包含。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsClientScriptIncludeRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptIncludeRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptIncludeRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptIncludeRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptIncludeRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptIncludeRegistered : string -&gt; bool" Usage="clientScriptManager.IsClientScriptIncludeRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">要搜索的客户端脚本包含的键。</param>
        <summary>使用指定键确定 <see cref="T:System.Web.UI.Page" /> 对象是否注册了客户端脚本包含。</summary>
        <returns>如果注册了客户端脚本包含，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法之前调用<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>方法可避免注册重复的脚本。 这一点尤其重要，如果该脚本需要大量的服务器资源来创建。  
  
 客户端脚本包含它的键和其类型由唯一标识。 具有相同的键和类型的脚本被视为重复项。  
  
 此重载<xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A>方法调用的重载的同时`key`和一个`type`与类型参数设置为<xref:System.Web.UI.Page>对象。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptIncludeRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptIncludeRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptIncludeRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptIncludeRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptIncludeRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsClientScriptIncludeRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要搜索的客户端脚本包含的类型。</param>
        <param name="key">要搜索的客户端脚本包含的键。</param>
        <summary>使用键和类型确定 <see cref="T:System.Web.UI.Page" /> 对象是否注册了客户端脚本包含。</summary>
        <returns>如果注册了客户端脚本包含，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法之前调用<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>方法可避免注册重复的客户端脚本包含。 这一点尤其重要，如果该脚本需要大量的服务器资源来创建。  
  
 客户端脚本包含它的键和其类型由唯一标识。 具有相同的键和类型的脚本被视为重复项。 指定基于将访问资源的对象的类型。 例如，当使用页实例访问的资源，你指定`Page`类型。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered%2A>方法。 请注意，是否用于检查现有的客户端脚本包含的逻辑被移除，则在呈现的页面的 HTML 源代码中不会两个重复的客户端脚本，因为<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>方法检查是否有重复项。 检查的好处是减少不必要的计算。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/cs/clientscriptincludes.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/vb/clientscriptincludes.aspx#1)]  
  
 此示例需要名为的 JavaScript 文件`Script_include.js`，包含以下内容：  
  
```  
function DoClick() {Form1.Message.value='Text from include script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">客户端脚本包含类型为 <see langword="null" />。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsOnSubmitStatementRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>确定 <see cref="T:System.Web.UI.Page" /> 对象是否注册了 OnSubmit 语句。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsOnSubmitStatementRegistered">
      <MemberSignature Language="C#" Value="public bool IsOnSubmitStatementRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOnSubmitStatementRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsOnSubmitStatementRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOnSubmitStatementRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsOnSubmitStatementRegistered : string -&gt; bool" Usage="clientScriptManager.IsOnSubmitStatementRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">要搜索的 OnSubmit 语句的键。</param>
        <summary>确定 <see cref="T:System.Web.UI.Page" /> 对象是否使用指定键注册了 OnSubmit 语句。</summary>
        <returns>如果已注册 OnSubmit 语句，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法之前调用<xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A>方法可避免注册重复的 OnSubmit 语句。 这一点尤其重要，如果该语句需要大量的服务器资源来创建。  
  
 由它的键和其类型唯一标识一个语句。 语句具有相同的键和类型被视为重复项。  
  
 此重载<xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A>方法调用的重载的同时`key`和一个`type`与类型参数设置为<xref:System.Web.UI.Page>对象  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.Type,System.String)" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsOnSubmitStatementRegistered">
      <MemberSignature Language="C#" Value="public bool IsOnSubmitStatementRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOnSubmitStatementRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOnSubmitStatementRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsOnSubmitStatementRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsOnSubmitStatementRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要搜索的 OnSubmit 语句的类型。</param>
        <param name="key">要搜索的 OnSubmit 语句的键。</param>
        <summary>确定 <see cref="T:System.Web.UI.Page" /> 对象是否使用指定的键和类型注册了 OnSubmit 语句。</summary>
        <returns>如果已注册 OnSubmit 语句，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法之前调用<xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A>方法可避免注册重复的语句。 这一点尤其重要，如果该语句需要大量的服务器资源来创建。  
  
 由它的键和其类型唯一标识一个语句。 语句具有相同的键和类型被视为重复项。 指定基于将访问资源的对象的类型。 例如，使用时`Page`实例访问该资源，则指定`Page`类型。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A>方法。 名为的脚本`OnSubmitScript`注册<xref:System.Web.UI.Page>，以便当调用相应的脚本提交页面的窗体。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/cs/clientscriptonsubmit.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/vb/clientscriptonsubmit.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">OnSubmit 语句的类型为 <see langword="null" />。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.String)" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsStartupScriptRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>确定 <see cref="T:System.Web.UI.Page" /> 对象是否注册了启动脚本。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsStartupScriptRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsStartupScriptRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsStartupScriptRegistered : string -&gt; bool" Usage="clientScriptManager.IsStartupScriptRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">要搜索的启动脚本的键。</param>
        <summary>使用指定键确定 <see cref="T:System.Web.UI.Page" /> 对象是否注册了启动脚本。</summary>
        <returns>如果注册了启动脚本，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法之前调用<xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>方法可避免注册重复的脚本。 这一点尤其重要，如果该脚本需要大量的服务器资源来创建。  
  
 由它的键和其类型唯一标识启动脚本。 具有相同的键和类型的脚本被视为重复项。  
  
 此重载<xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A>方法将调用接受两个字符串的重载`key`和一个`type`与类型参数设置为<xref:System.Web.UI.Page>对象  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterStartupScript" />
      </Docs>
    </Member>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsStartupScriptRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsStartupScriptRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsStartupScriptRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要搜索的启动脚本的类型。</param>
        <param name="key">要搜索的启动脚本的键。</param>
        <summary>使用指定键和类型确定 <see cref="T:System.Web.UI.Page" /> 对象是否注册了启动脚本。</summary>
        <returns>如果注册了启动脚本，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法之前调用<xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>方法可避免注册重复的脚本。 这一点尤其重要，如果该脚本需要大量的服务器资源来创建。  
  
 由它的键和其类型唯一地标识客户端启动脚本。 具有相同的键和类型的脚本被视为重复项。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A>方法。 请注意，是否逻辑来检查是否有现有的启动脚本块被移除，则在呈现的页面的 HTML 源代码中不会两个重复的启动脚本，因为<xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>方法检查是否有重复项。 检查的好处是减少不必要的计算。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">该启动脚本类型为 <see langword="null" />。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterStartupScript" />
      </Docs>
    </Member>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public void RegisterArrayDeclaration (string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterArrayDeclaration(string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterArrayDeclaration (arrayName As String, arrayValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterArrayDeclaration(System::String ^ arrayName, System::String ^ arrayValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterArrayDeclaration : string * string -&gt; unit" Usage="clientScriptManager.RegisterArrayDeclaration (arrayName, arrayValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="arrayName">要注册的数组名。</param>
        <param name="arrayValue">要注册的一个或多个数组值。</param>
        <summary>使用数组名称和数组值向 <see cref="T:System.Web.UI.Page" /> 对象注册 JavaScript 数组声明。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A>检查以确定是否已注册的数组存在中指定的名称与同名`arrayName`参数，如果是这样，将添加中指定的值`arrayValue`参数。 由于基础存储机制基于<xref:System.Collections.ArrayList>，允许重复项。 如果具有相同的名称的已注册数组`arrayName`参数不存在，则创建它及其包含的值`arrayValue`参数添加到它。  
  
 如果你想在生成的 JavaScript 数组内的字符串文本，包括单引号 （'） 引起来或转义的双引号引起来 (\\") 中`arrayValue`参数。 值`arrayValue`参数应为单个元素。 如果多个值需要添加到数组，请使用多个调用<xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A>方法。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A>和<xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A>方法。 该示例注册数组和一个隐藏的值并定义`OnClick`事件的`<input>`按钮要计算总和的两个值的数组和隐藏的值。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/cs/clientscriptregisterarray.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/vb/clientscriptregisterarray.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="arrayName" /> 为 <see langword="null" />。</exception>
        <altmember cref="Overload:System.String.Split" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptBlock">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向 <see cref="T:System.Web.UI.Page" /> 对象注册客户端脚本。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptBlock (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptBlock(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptBlock(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptBlock : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptBlock (type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要注册的客户端脚本的类型。</param>
        <param name="key">要注册的客户端脚本的键。</param>
        <param name="script">要注册的客户端脚本文本。</param>
        <summary>使用类型、键和脚本文本向 <see cref="T:System.Web.UI.Page" /> 对象注册客户端脚本。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由它的键和其类型唯一标识客户端脚本。 具有相同的键和类型的脚本被视为重复项。 使用给定的类型和密钥对的只有一个脚本可以向页注册。 尝试注册已注册的脚本不会创建重复的脚本。  
  
 调用<xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A>方法以确定是否使用给定的键和类型对的客户端脚本是否已注册并避免不必要地尝试添加脚本。  
  
 中的此重载<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法，您必须确保中提供的脚本`script`参数包装在`<script>`元素块。  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法将脚本块添加到呈现的页的顶部。 脚本块不保证可输出中的注册的顺序。 如果脚本块的顺序很重要，使用<xref:System.Text.StringBuilder>对象，以便将脚本收集在一个字符串，并全部放在单个客户端脚本块然后注册它们。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager12#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager12/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager12#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager12/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptBlock (Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptBlock(class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptBlock(Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptBlock : Type * string * string * bool -&gt; unit" Usage="clientScriptManager.RegisterClientScriptBlock (type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">要注册的客户端脚本的类型。</param>
        <param name="key">要注册的客户端脚本的键。</param>
        <param name="script">要注册的客户端脚本文本。</param>
        <param name="addScriptTags">指示是否添加脚本标记的布尔值。</param>
        <summary>使用类型、键、脚本文本和指示是否添加脚本标记的布尔值向 <see cref="T:System.Web.UI.Page" /> 对象注册客户端脚本。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由它的键和其类型唯一标识客户端脚本。 具有相同的键和类型的脚本被视为重复项。 使用给定的类型和密钥对的只有一个脚本可以向页注册。 尝试注册已注册的脚本不会创建重复的脚本。  
  
 调用<xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A>方法，以确定是否已注册给定的键和类型对客户端脚本。 这样可以避免不必要地尝试添加脚本。  
  
 中的此重载<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法，您可以指示在提供的脚本是否`script`参数用括`<script>`元素块的方法是使用`addScriptTags`参数。 设置`addScriptTags`到`true`指示将自动添加脚本标记。  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法将脚本块添加到呈现的页的顶部。 脚本块不保证可输出中的注册的顺序。 如果脚本块的顺序很重要，使用<xref:System.Text.StringBuilder>对象，以便将脚本收集在一个字符串，并全部放在单个客户端脚本块然后注册它们。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法。 请注意，`addScriptTags`参数设置为`true`所以的开始和结束脚本标记不包含`script`参数。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">客户端脚本块类型为 <see langword="null" />。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptInclude">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向 <see cref="T:System.Web.UI.Page" /> 对象注册客户端脚本包含。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptInclude (string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptInclude(string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterClientScriptInclude (key As String, url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptInclude(System::String ^ key, System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptInclude : string * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptInclude (key, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">要注册的客户端脚本包含的键。</param>
        <param name="url">要注册的客户端脚本包含的 URL。</param>
        <summary>使用让客户端能够调用脚本的键和 URL 向 <see cref="T:System.Web.UI.Page" /> 对象注册客户端脚本。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 客户端脚本包含它的键和其类型由唯一标识。 具有相同的键和类型的脚本被视为重复项。 使用给定的类型和密钥对的只有一个脚本可以向页注册。 尝试注册已注册的脚本不会创建重复的脚本。  
  
 调用<xref:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered%2A>方法，以确定是否客户端脚本包含具有给定的键和类型对已注册，从而避免不必要地尝试添加脚本。  
  
> [!NOTE]
>  若要解决的客户端 URL，请使用<xref:System.Web.UI.Control.ResolveClientUrl%2A>方法。 此方法使用在其调用它的 URL 路径解析的上下文。  
  
 此重载<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>方法调用的重载`key`即`URL`，和一个`type`参数。  
  
 该方法在呈现的页的顶部添加一个脚本块。  
  
   
  
## Examples  
 有关相关信息，包括语法、 用法和示例，请参阅<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.Type,System.String,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptInclude (Type type, string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptInclude(class System.Type type, string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptInclude(Type ^ type, System::String ^ key, System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptInclude : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptInclude (type, key, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要注册的客户端脚本包含的类型。</param>
        <param name="key">要注册的客户端脚本包含的键。</param>
        <param name="url">要注册的客户端脚本包含的 URL。</param>
        <summary>使用类型、键和 URL 向 <see cref="T:System.Web.UI.Page" /> 对象注册客户端脚本包含。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>方法采用*密钥*并*url*参数来确定该脚本，以及一个`type`参数来指定客户端脚本的标识包括。 指定基于将访问资源的对象的类型。 例如，使用时`Page`实例访问该资源，则指定`Page`类型。  
  
> [!NOTE]
>  若要解决的客户端 URL，请使用<xref:System.Web.UI.Control.ResolveClientUrl%2A>方法。 此方法使用在其调用它的 URL 路径解析的上下文。  
  
 此方法将呈现的页的顶部添加一个脚本块。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>方法。 请注意，是否检查现有的客户端脚本包含的逻辑会被删除，仍不会有重复的客户端脚本中呈现的页面因为<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>方法检查是否有重复项。 检查的好处是减少不必要的计算。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/cs/clientscriptincludes.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/vb/clientscriptincludes.aspx#1)]  
  
 此示例需要名包含以下内容的 JavaScript 文件：  
  
```  
function DoClick() {Form1.Message.value='Text from include script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">客户端脚本包含类型为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">URL 为 <see langword="null" />。  
  
或 
URL 为空。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.String,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptResource">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptResource (Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptResource(class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptResource(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptResource(Type ^ type, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptResource : Type * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptResource (type, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要注册的客户端脚本资源的类型。</param>
        <param name="resourceName">要注册的客户端脚本资源的名称。</param>
        <summary>使用类型和资源名向 <see cref="T:System.Web.UI.Page" /> 对象注册客户端脚本资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A>通过 WebResource.axd HTTP 处理程序程序集中访问已编译的资源时使用方法。 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A>方法注册的脚本<xref:System.Web.UI.Page>对象，并可以防止重复脚本。 此方法会包装包含的资源 URL 的内容`<script>`元素块。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A>方法。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/clientscriptwebresource.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/clientscriptwebresource.aspx#1)]  
  
 下面的代码示例演示如何以编程方式应用<xref:System.Web.UI.WebResourceAttribute>元数据特性标记会提供服务的资源的程序集。  
  
 [!code-csharp[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/resource.cs#2)]
 [!code-vb[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/resource.vb#2)]  
  
 此示例需要名为的 JavaScript 文件`Script_include.js`，包含以下内容：  
  
```  
function DoClick() {Form1.Message.value='Text from resource script.'}  
```  
  
 编译`Script_include.js`文件中的资源作为`Samples.AspNet.CS.Controls`所属的程序集`ClientScriptResourceLabel`类。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">客户端资源类型为 <see langword="null" />。

- 或 -

客户端资源名称为 <see langword="null" />。  
  
或 
客户端资源名称长度为零。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetWebResourceUrl(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
        <altmember cref="T:System.Web.Handlers.AssemblyResourceLoader" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterExpandoAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将名称/值对注册为指定控件的自定义 (expando) 特性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public void RegisterExpandoAttribute (string controlId, string attributeName, string attributeValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterExpandoAttribute(string controlId, string attributeName, string attributeValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExpandoAttribute (controlId As String, attributeName As String, attributeValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterExpandoAttribute(System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterExpandoAttribute : string * string * string -&gt; unit" Usage="clientScriptManager.RegisterExpandoAttribute (controlId, attributeName, attributeValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="controlId">页中包含自定义特性的 <see cref="T:System.Web.UI.Control" />。</param>
        <param name="attributeName">要注册的自定义特性的名称。</param>
        <param name="attributeValue">自定义特性的值。</param>
        <summary>将名称/值对注册为给定了控件 ID、特性名和特性值的指定控件的自定义 (expando) 特性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A>方法将名称/值对注册上指定的自定义 (expando) 特性<xref:System.Web.UI.Control>。 Expando 属性是动态设置从 JavaScript 来保持呈现的控件的标记的 XHTML 兼容性。 引号和自定义 (expando) 特性的值中的反斜杠进行转义。 如果不希望进行转义引号和反斜杠，调用<xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A>重载方法，并设置`encode`参数`false`。  
  
 如果找不到 expando 属性或找不到要添加到 expando 属性的控件，仍然发出客户端脚本，但它不会影响该控件。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.JScript.Expando" />
      </Docs>
    </Member>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public void RegisterExpandoAttribute (string controlId, string attributeName, string attributeValue, bool encode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterExpandoAttribute(string controlId, string attributeName, string attributeValue, bool encode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExpandoAttribute (controlId As String, attributeName As String, attributeValue As String, encode As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterExpandoAttribute(System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue, bool encode);" />
      <MemberSignature Language="F#" Value="member this.RegisterExpandoAttribute : string * string * string * bool -&gt; unit" Usage="clientScriptManager.RegisterExpandoAttribute (controlId, attributeName, attributeValue, encode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
        <Parameter Name="encode" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="controlId">页中包含自定义特性的 <see cref="T:System.Web.UI.Control" />。</param>
        <param name="attributeName">要注册的自定义特性的名称。</param>
        <param name="attributeValue">自定义特性的值。</param>
        <param name="encode">指示是否对要注册的自定义特性进行编码布尔值。</param>
        <summary>在给定了控件 ID、特性名称、特性值以及指示是否对特性值进行编码的布尔值的情况下，将名称/值对注册为指定控件的自定义 (expando) 特性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A>方法将名称/值对注册上指定的自定义 (expando) 特性<xref:System.Web.UI.Control>。 Expando 属性是动态设置从 JavaScript 来保持呈现的控件的标记的 XHTML 兼容性。 设置`encode`参数`true`如果需要进行转义引号和反斜杠中 expando 属性的值。  
  
 如果找不到 expando 属性或找不到要添加到 expando 属性的控件，仍然发出客户端脚本，但它不会影响该控件。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A>方法的<xref:System.Web.UI.ClientScriptManager>类。 在呈现的页设置的客户端脚本`title`属性的`<span>`元素。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager6#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager6/cs/clientscriptexpando.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager6#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager6/vb/clientscriptexpando.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.JScript.Expando" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterForEventValidation">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>为验证注册事件引用。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (string uniqueId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(string uniqueId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (uniqueId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::String ^ uniqueId);" />
      <MemberSignature Language="F#" Value="member this.RegisterForEventValidation : string -&gt; unit" Usage="clientScriptManager.RegisterForEventValidation uniqueId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">表示生成事件的客户端控件的唯一 ID。</param>
        <summary>使用唯一控件 ID（表示生成事件的客户端控件）注册事件引用以进行验证。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详细信息和示例，请参阅<xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A>方法。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A>方法和<xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A>方法，以注册用于验证，以及如何验证回调源自于该页面的回调。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/eventvalidation2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/eventvalidation2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (System.Web.UI.PostBackOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(class System.Web.UI.PostBackOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.Web.UI.PostBackOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (options As PostBackOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::Web::UI::PostBackOptions ^ options);" />
      <MemberSignature Language="F#" Value="member this.RegisterForEventValidation : System.Web.UI.PostBackOptions -&gt; unit" Usage="clientScriptManager.RegisterForEventValidation options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
      </Parameters>
      <Docs>
        <param name="options"><see cref="T:System.Web.UI.PostBackOptions" /> 对象指定生成客户端 JavaScript 以启动回发事件的方式。</param>
        <summary>通过 <see cref="T:System.Web.UI.PostBackOptions" /> 为验证注册事件引用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详细信息和示例，请参阅<xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A>方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.ValidateEvent" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (string uniqueId, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(string uniqueId, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (uniqueId As String, argument As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::String ^ uniqueId, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.RegisterForEventValidation : string * string -&gt; unit" Usage="clientScriptManager.RegisterForEventValidation (uniqueId, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">表示生成事件的客户端控件的唯一 ID。</param>
        <param name="argument">随客户端事件传递的事件参数。</param>
        <summary>使用唯一控件 ID 和事件参数（表示生成事件的客户端控件）注册事件引用以进行验证。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示了如何使用<xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A>方法和<xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A>方法来注册一个回调以进行验证和验证回调源自于该页面。 若要提高在示例中所示的验证，可以修改验证`argument`参数来包含特定于如标识或角色的用户信息  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/EventValidationCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/EventValidationVB.aspx#1)]  
  
 下面的代码示例演示了如何使用<xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A>方法来注册一个回调以进行验证。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager10#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager10/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager10#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager10/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在调用 <see cref="M:System.Web.UI.Page.Render(System.Web.UI.HtmlTextWriter)" /> 方法之前调用此方法。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String,System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/18fc94c9-56fc-46c3-9f29-7358f18667df">客户端回调与验证实现示例</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public void RegisterHiddenField (string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterHiddenField(string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterHiddenField(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterHiddenField (hiddenFieldName As String, hiddenFieldInitialValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterHiddenField(System::String ^ hiddenFieldName, System::String ^ hiddenFieldInitialValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterHiddenField : string * string -&gt; unit" Usage="clientScriptManager.RegisterHiddenField (hiddenFieldName, hiddenFieldInitialValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="hiddenFieldName">要注册的隐藏字段的名称。</param>
        <param name="hiddenFieldInitialValue">要注册的字段的初始值。</param>
        <summary>向 <see cref="T:System.Web.UI.Page" /> 对象注册一个隐藏值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A>方法创建一个隐藏`<input>`上呈现的 HTML 页面元素。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A>和<xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A>方法。 该示例注册数组和一个隐藏的值并定义`OnClick`事件的`<input>`按钮要计算总和的两个值的数组和隐藏的值。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/cs/clientscriptregisterarray.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/vb/clientscriptregisterarray.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="hiddenFieldName" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.WebControls.HiddenField" />
      </Docs>
    </Member>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public void RegisterOnSubmitStatement (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterOnSubmitStatement(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterOnSubmitStatement(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterOnSubmitStatement : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterOnSubmitStatement (type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要注册的 OnSubmit 语句的类型。</param>
        <param name="key">要注册的 OnSubmit 语句的键。</param>
        <param name="script">要注册的 OnSubmit 语句的脚本文本。</param>
        <summary>使用类型、键和脚本文本向 <see cref="T:System.Web.UI.Page" /> 对象注册 OnSubmit 语句。 该语句在提交 <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> 时执行。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由它的键和其类型唯一标识的 OnSubmit 语句。 语句具有相同的键和类型被视为重复项。 使用给定的类型和密钥对的只有一条语句可以向页注册。 尝试注册已注册的语句不会创建重复的语句。  
  
 调用<xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A>方法以确定是否使用给定的键和类型对已注册的 OnSubmit 语句并避免不必要地尝试添加脚本。  
  
 `script`参数的<xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A>方法可以包含多个脚本命令，只要正确使用分号 （;） 分隔。  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A>添加页面提交，并使你有机会取消提交之前执行的脚本。  
  
 有关 HTML 窗体上的详细信息和`OnSubmit`属性，请参阅[World Wide Web 联合会 (W3C) 网站](https://go.microsoft.com/fwlink/?linkid=37125)。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A>方法。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/cs/clientscriptonsubmit.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/vb/clientscriptonsubmit.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlForm" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterStartupScript">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向 <see cref="T:System.Web.UI.Page" /> 对象注册启动脚本。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public void RegisterStartupScript (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterStartupScript(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterStartupScript(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterStartupScript : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterStartupScript (type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要注册的启动脚本的类型。</param>
        <param name="key">要注册的启动脚本的键。</param>
        <param name="script">要注册的启动脚本文本。</param>
        <summary>使用类型、键和脚本文本向 <see cref="T:System.Web.UI.Page" /> 对象注册启动脚本。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由它的键和其类型唯一标识客户端脚本。 具有相同的键和类型的脚本被视为重复项。 使用给定的类型和密钥对的只有一个脚本可以向页注册。 尝试注册已注册的脚本不会创建重复的脚本。  
  
 调用<xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A>方法以确定是否使用给定的键和类型对的启动脚本是否已注册并避免不必要地尝试添加脚本。  
  
 中的此重载<xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>方法，您必须确保中提供的脚本`script`具有包装参数`<script>`元素块。  
  
 通过添加脚本块<xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>方法执行时在页面完成加载，但之前的页<xref:System.Web.UI.Control.OnLoad%2A>引发事件。 脚本块不保证可输出中的注册的顺序。 如果脚本块的顺序很重要，使用<xref:System.Text.StringBuilder>对象，以便将脚本收集在一个字符串，并全部放在单个客户端脚本块然后注册它们。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>方法。 请注意，中包含的开始和结束脚本标记`script`参数。 若要让的脚本标记添加基于其他参数的设置，请参阅<xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>方法。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager11#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager11/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager11#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager11/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public void RegisterStartupScript (Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterStartupScript(class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterStartupScript(Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="member this.RegisterStartupScript : Type * string * string * bool -&gt; unit" Usage="clientScriptManager.RegisterStartupScript (type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">要注册的启动脚本的类型。</param>
        <param name="key">要注册的启动脚本的键。</param>
        <param name="script">要注册的启动脚本文本。</param>
        <param name="addScriptTags">指示是否添加脚本标记的布尔值。</param>
        <summary>使用类型、键、脚本文本和指示是否添加脚本标记的布尔值向 <see cref="T:System.Web.UI.Page" /> 对象注册启动脚本。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由它的键和其类型唯一标识启动脚本。 具有相同的键和类型的脚本被视为重复项。 使用给定的类型和密钥对的只有一个脚本可以向页注册。 尝试注册已注册的脚本不会创建重复的脚本。  
  
 调用<xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A>方法以确定是否使用给定的键和类型对的启动脚本是否已注册并避免不必要地尝试添加脚本。  
  
 中的此重载<xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>方法，您可以指示在提供的脚本是否`script`参数用括`<script>`元素块的方法是使用`addScriptTags`参数。 设置`addScriptTags`到`true`指示将自动添加脚本标记。  
  
 通过添加脚本块<xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>方法执行时在页面完成加载，但之前的页<xref:System.Web.UI.Control.OnLoad%2A>引发事件。 脚本块不保证可输出中的注册的顺序。 如果脚本块的顺序很重要，使用<xref:System.Text.StringBuilder>对象，以便将脚本收集在一个字符串，并全部放在单个客户端脚本块然后注册它们。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>方法。 请注意，`addScriptTags`参数设置为`false`所以的开始和结束脚本标记包含`script`参数。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String)" />
        <altmember cref="F:System.Web.UI.HtmlTextWriterTag.Script" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ValidateEvent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>验证客户端事件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ValidateEvent">
      <MemberSignature Language="C#" Value="public void ValidateEvent (string uniqueId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateEvent(string uniqueId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateEvent (uniqueId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateEvent(System::String ^ uniqueId);" />
      <MemberSignature Language="F#" Value="member this.ValidateEvent : string -&gt; unit" Usage="clientScriptManager.ValidateEvent uniqueId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">表示生成事件的客户端控件的唯一 ID。</param>
        <summary>验证使用 <see cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" /> 方法为事件验证注册的客户端事件。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ValidateEvent">
      <MemberSignature Language="C#" Value="public void ValidateEvent (string uniqueId, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateEvent(string uniqueId, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateEvent (uniqueId As String, argument As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateEvent(System::String ^ uniqueId, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.ValidateEvent : string * string -&gt; unit" Usage="clientScriptManager.ValidateEvent (uniqueId, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">表示生成事件的客户端控件的唯一 ID。</param>
        <param name="argument">随客户端事件传递的事件参数。</param>
        <summary>验证使用 <see cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" /> 方法为事件验证注册的客户端事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示了如何使用<xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A>方法和<xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A>方法来注册一个回调以进行验证和验证回调源自于该页面。 若要提高如下所示的验证，可以修改验证`argument`参数来包含特定于如标识或角色的用户信息  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/EventValidationCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/EventValidationVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="uniqueId" /> 为 <see langword="null" /> 或空字符串 ("")。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>