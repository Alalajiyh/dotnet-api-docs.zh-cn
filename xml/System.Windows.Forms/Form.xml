<Type Name="Form" FullName="System.Windows.Forms.Form">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1024be78e07eaac8ff253703c7282179a5b5aea2" /><Meta Name="ms.sourcegitcommit" Value="9a6da88bd5455e8274257ca7ad259b42f1de114f" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="05/22/2019" /><Meta Name="ms.locfileid" Value="66008743" /></Metadata><TypeSignature Language="C#" Value="public class Form : System.Windows.Forms.ContainerControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Form extends System.Windows.Forms.ContainerControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Form" />
  <TypeSignature Language="VB.NET" Value="Public Class Form&#xA;Inherits ContainerControl" />
  <TypeSignature Language="C++ CLI" Value="public ref class Form : System::Windows::Forms::ContainerControl" />
  <TypeSignature Language="F#" Value="type Form = class&#xA;    inherit ContainerControl" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.ContainerControl</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Load")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.FormDocumentDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.ComponentModel.Design.IRootDesigner))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignerCategory("Form")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignTimeVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.ComponentModel.InitializationEvent("Load")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Windows.Forms.Control.TopLevel")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.FormDocumentDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.ComponentModel.Design.IRootDesigner))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.FormDocumentDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.ComponentModel.Design.IRootDesigner))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDispatch)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示组成应用程序的用户界面的窗口或对话框。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一个<xref:System.Windows.Forms.Form>是显示在应用程序中的任何窗口的表示形式。 <xref:System.Windows.Forms.Form>类可用于创建标准、 工具，无边距和浮动窗口。 此外可以使用<xref:System.Windows.Forms.Form>类，以创建模式对话框之类的窗口。 一种特殊的窗体中，多文档界面 (MDI) 窗体，可以包含其他调用 MDI 子窗体的窗体。 通过设置来创建的 MDI 窗体<xref:System.Windows.Forms.Form.IsMdiContainer%2A>属性设置为`true`。 通过设置创建 MDI 子窗体<xref:System.Windows.Forms.Form.MdiParent%2A>到将包含子窗体的 MDI 父窗体的属性。  
  
 使用中的可用属性<xref:System.Windows.Forms.Form>类，您可以确定要创建窗口或对话框中的外观、 大小、 颜色和窗口管理功能。 <xref:System.Windows.Forms.Control.Text%2A>属性可以在标题栏中指定的窗口的标题。 <xref:System.Windows.Forms.Form.Size%2A>和<xref:System.Windows.Forms.Form.DesktopLocation%2A>属性，您可以在显示时定义的大小和窗口的位置。 可以使用<xref:System.Windows.Forms.Control.ForeColor%2A>要更改的所有控件的默认前景色的颜色属性放置在窗体上。 <xref:System.Windows.Forms.Form.FormBorderStyle%2A>， <xref:System.Windows.Forms.Form.MinimizeBox%2A>，和<xref:System.Windows.Forms.Form.MaximizeBox%2A>属性可以控制是否在窗体可以最小化、 最大化，或在运行时调整大小。  
  
 除了属性外，您可以使用类的方法来操作窗体。 例如，可以使用<xref:System.Windows.Forms.Form.ShowDialog%2A>方法来显示一个窗体作为模式对话框。 可以使用<xref:System.Windows.Forms.Form.SetDesktopLocation%2A>方法以在桌面上定位该窗体。  
  
 事件的<xref:System.Windows.Forms.Form>类可用于对窗体上执行的操作做出响应。 可以使用<xref:System.Windows.Forms.Form.Activated>事件执行操作，例如更新时激活窗体的窗体控件中显示的数据。  
  
 您可以使用窗体作为起始类在应用程序中上来将调用的方法`Main`类中。 在`Main`方法添加代码以创建和显示窗体。 您还需要添加`STAThread`属性为`Main`使窗体以运行方法。 当启动窗体关闭时，应用程序也将关闭。  
  
 如果您设置<xref:System.Windows.Forms.Control.Enabled%2A>属性设置为`false`之前<xref:System.Windows.Forms.Form>可见 (例如，设置<xref:System.Windows.Forms.Control.Enabled%2A>中为 false[!INCLUDE[TLA#tla_visualstu](~/includes/tlasharptla-visualstu-md.md)]设计器)，则最小化、 最大化、 关闭、 和的系统按钮，保持启用状态。 如果您设置<xref:System.Windows.Forms.Control.Enabled%2A>到`false`后<xref:System.Windows.Forms.Form>可见 （例如，Load 事件发生时），则禁用此按钮。  
  
   
  
## Examples  
 下面的代码示例创建的新实例<xref:System.Windows.Forms.Form>，并调用<xref:System.Windows.Forms.Form.ShowDialog%2A>窗体显示为对话框中的方法。 该示例设置<xref:System.Windows.Forms.Form.FormBorderStyle%2A>， <xref:System.Windows.Forms.Form.AcceptButton%2A>， <xref:System.Windows.Forms.Form.CancelButton%2A>， <xref:System.Windows.Forms.Form.MinimizeBox%2A>， <xref:System.Windows.Forms.Form.MaximizeBox%2A>，并<xref:System.Windows.Forms.Form.StartPosition%2A>属性以更改到对话框的外观和功能的窗体。 此示例还使用<xref:System.Windows.Forms.Form.ControlCollection.Add%2A>窗体的方法<xref:System.Windows.Forms.Control.Controls%2A>集合来添加两个<xref:System.Windows.Forms.Button>控件。 该示例使用<xref:System.Windows.Forms.Form.HelpButton%2A>属性对话框中的标题栏中显示帮助按钮。  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/599faf75-13cf-49cc-ad3c-255545e5cb97">多文档界面 (MDI) 应用程序</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Form ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Form();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.Forms.Form" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 窗体的默认大小为 300 像素高和 300 像素宽。  
  
   
  
## Examples  
 下面的代码示例创建的新实例<xref:System.Windows.Forms.Form>，并调用<xref:System.Windows.Forms.Form.ShowDialog%2A>窗体显示为对话框中的方法。 该示例设置<xref:System.Windows.Forms.Form.FormBorderStyle%2A>， <xref:System.Windows.Forms.Form.AcceptButton%2A>， <xref:System.Windows.Forms.Form.CancelButton%2A>， <xref:System.Windows.Forms.Form.MinimizeBox%2A>， <xref:System.Windows.Forms.Form.MaximizeBox%2A>，并<xref:System.Windows.Forms.Form.StartPosition%2A>属性以更改到对话框的外观和功能的窗体。 该示例还将使用<xref:System.Windows.Forms.Form.ControlCollection.Add%2A>窗体的方法<xref:System.Windows.Forms.Control.Controls%2A>集合来添加两个<xref:System.Windows.Forms.Button>控件。 该示例使用<xref:System.Windows.Forms.Form.HelpButton%2A>属性对话框中的标题栏中显示帮助按钮。  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptButton">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.IButtonControl AcceptButton { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.IButtonControl AcceptButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AcceptButton" />
      <MemberSignature Language="VB.NET" Value="Public Property AcceptButton As IButtonControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::IButtonControl ^ AcceptButton { System::Windows::Forms::IButtonControl ^ get(); void set(System::Windows::Forms::IButtonControl ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AcceptButton : System.Windows.Forms.IButtonControl with get, set" Usage="System.Windows.Forms.Form.AcceptButton" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.IButtonControl</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当用户按 Enter 键时所单击的窗体上的按钮。</summary>
        <value><see cref="T:System.Windows.Forms.IButtonControl" />，表示要用作窗体的“接受”按钮的按钮。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性可以指定发生在用户在应用程序中按 ENTER 键时的默认操作。 分配给此属性的按钮必须是<xref:System.Windows.Forms.IButtonControl>的当前窗体上或位于当前窗体上的容器中。  
  
 可以使用此属性以允许用户快速通过允许他们只需按 ENTER 键，将完成而不是手动单击接受按钮使用其鼠标导航的简单窗体。  
  
 如果当前选定的控件在窗体上截获 ENTER 键，并对其进行处理，可能不能激活接受按钮。 例如，多行文本框控件允许选择要在控件中插入新行字符时按下 ENTER 键。  
  
   
  
## Examples  
 下面的代码示例创建的新实例<xref:System.Windows.Forms.Form>，并调用<xref:System.Windows.Forms.Form.ShowDialog%2A>窗体显示为对话框中的方法。 该示例设置<xref:System.Windows.Forms.Form.FormBorderStyle%2A>， <xref:System.Windows.Forms.Form.AcceptButton%2A>， <xref:System.Windows.Forms.Form.CancelButton%2A>， <xref:System.Windows.Forms.Form.MinimizeBox%2A>， <xref:System.Windows.Forms.Form.MaximizeBox%2A>，并<xref:System.Windows.Forms.Form.StartPosition%2A>属性以更改到对话框的外观和功能的窗体。 此示例还使用<xref:System.Windows.Forms.Form.ControlCollection.Add%2A>窗体的方法<xref:System.Windows.Forms.Control.Controls%2A>集合来添加两个<xref:System.Windows.Forms.Button>控件。 该示例使用<xref:System.Windows.Forms.Form.HelpButton%2A>属性对话框中的标题栏中显示帮助按钮。  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.CancelButton" />
        <altmember cref="T:System.Windows.Forms.IButtonControl" />
      </Docs>
    </Member>
    <Member MemberName="Activate">
      <MemberSignature Language="C#" Value="public void Activate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Activate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Activate" />
      <MemberSignature Language="VB.NET" Value="Public Sub Activate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Activate();" />
      <MemberSignature Language="F#" Value="member this.Activate : unit -&gt; unit" Usage="form.Activate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>激活窗体并给予它焦点。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 激活窗体将它置于顶层如果这是活动的应用程序，或如果这不是活动的应用程序，它会闪烁窗口标题。 该窗体必须可见才能产生任何影响此方法。 若要确定活动窗体应用程序中的，使用<xref:System.Windows.Forms.Form.ActiveForm%2A>属性或<xref:System.Windows.Forms.Form.ActiveMdiChild%2A>属性如果在窗体中的多文档界面 (MDI) 应用程序。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.Form.SetDesktopLocation%2A>，<xref:System.Windows.Forms.Form.Load>和<xref:System.Windows.Forms.Form.Activate%2A>成员。 若要运行该示例，请将以下代码粘贴在一个称为窗体`Form1`包含一个按钮调用`Button1`并将两个`Label`控件称为`Label1`和`Label2`。  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">用于更改焦点。 关联枚举：<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />。</permission>
        <altmember cref="P:System.Windows.Forms.Form.ActiveForm" />
        <altmember cref="P:System.Windows.Forms.Form.ActiveMdiChild" />
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Activated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberSignature Language="F#" Value="member this.Activated : EventHandler " Usage="member this.Activated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当使用代码激活或用户激活窗体时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  当应用程序处于活动状态，并且具有多个窗体时，活动窗体是具有输入焦点的窗体。 不可见的窗体不能为活动窗体。 若要激活可见的窗体的最简单方法是单击它，或使用相应的键盘组合。  
  
 若要使用代码在运行时激活窗体，调用<xref:System.Windows.Forms.Form.Activate%2A>方法。 此事件可用于任务，例如更新基于窗体的数据时不激活该窗体所做更改窗体的内容。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.Form.SetDesktopLocation%2A>， <xref:System.Windows.Forms.Form.Closed>， <xref:System.Windows.Forms.Form.Load>， <xref:System.Windows.Forms.Form.Activated>，和<xref:System.Windows.Forms.Form.Activate%2A>成员。 若要运行该示例，请将以下代码粘贴在名为 Form1 包含窗体<xref:System.Windows.Forms.Button>称为`Button1`并将两个<xref:System.Windows.Forms.Label>控件称为`Label1`和`Label2`。  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="ActivateMdiChild">
      <MemberSignature Language="C#" Value="protected void ActivateMdiChild (System.Windows.Forms.Form form);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ActivateMdiChild(class System.Windows.Forms.Form form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ActivateMdiChild(System.Windows.Forms.Form)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ActivateMdiChild(System::Windows::Forms::Form ^ form);" />
      <MemberSignature Language="F#" Value="member this.ActivateMdiChild : System.Windows.Forms.Form -&gt; unit" Usage="form.ActivateMdiChild form" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="form">要激活的子窗体。</param>
        <summary>激活窗体的 MDI 子级。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`form`参数已是活动的 MDI 子窗体，则<xref:System.Windows.Forms.Form.ActivateMdiChild%2A>方法仅返回。 如果`form`不是`null`，则设置为活动的 MDI 子窗体。  
  
 是否`form`参数是`null`与否，<xref:System.Windows.Forms.Form.ActivateMdiChild%2A>引发<xref:System.Windows.Forms.Form.MdiChildActivate>事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.ActiveMdiChild" />
        <altmember cref="P:System.Windows.Forms.Form.ActiveForm" />
        <altmember cref="E:System.Windows.Forms.Form.MdiChildActivate" />
      </Docs>
    </Member>
    <Member MemberName="ActiveForm">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Form ActiveForm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.Form ActiveForm" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ActiveForm" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ActiveForm As Form" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::Form ^ ActiveForm { System::Windows::Forms::Form ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ActiveForm : System.Windows.Forms.Form" Usage="System.Windows.Forms.Form.ActiveForm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此应用程序的当前活动窗体。</summary>
        <value><see cref="T:System.Windows.Forms.Form" />，表示当前活动窗体，或者如果没有活动窗体，则为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可用于获取对当前活动窗体在窗体或其控件上执行操作的引用。  
  
 如果你的应用程序的多文档界面 (MDI) 应用程序，请使用<xref:System.Windows.Forms.Form.ActiveMdiChild%2A>属性来获取当前处于活动状态的 MDI 子窗体。  
  
   
  
## Examples  
 下面的代码示例获取活动窗体，并禁用窗体上的所有控件。 该示例使用<xref:System.Windows.Forms.Control.Controls%2A>要循环访问每个控件在窗体上并禁用这些控件的窗体的集合。  
  
 [!code-cpp[Classic Form.ActiveForm Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ActiveForm Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ActiveForm Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ActiveForm Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ActiveForm Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ActiveForm Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">用于请求窗体。 关联枚举：<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />。</permission>
        <altmember cref="P:System.Windows.Forms.Form.ActiveMdiChild" />
      </Docs>
    </Member>
    <Member MemberName="ActiveMdiChild">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form ActiveMdiChild { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form ActiveMdiChild" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ActiveMdiChild" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActiveMdiChild As Form" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Form ^ ActiveMdiChild { System::Windows::Forms::Form ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ActiveMdiChild : System.Windows.Forms.Form" Usage="System.Windows.Forms.Form.ActiveMdiChild" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前活动的多文档界面 (MDI) 子窗口。</summary>
        <value>返回表示当前活动的 MDI 子窗口的 <see cref="T:System.Windows.Forms.Form" />，或者如果当前没有子窗口，则返回 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可用于确定是否有任何 MDI 子窗体 MDI 应用程序中打开。 此方法还可用于从其 MDI 父窗体或从另一种形式显示在你的应用程序中执行的 MDI 子窗口上的操作。  
  
 如果当前活动窗体不是 MDI 子窗体，则可以使用<xref:System.Windows.Forms.Form.ActiveForm%2A>属性来获取对它的引用。  
  
   
  
## Examples  
 下面的代码示例获取对活动的 MDI 子窗体，并循环访问所有的引用<xref:System.Windows.Forms.TextBox>控件在窗体上的重置其<xref:System.Windows.Forms.TextBoxBase.Text%2A>属性。 此示例要求已创建的 MDI 父窗体，此方法调用进行了从 MDI 父窗体。  
  
 [!code-cpp[Classic Form.ActiveMdiChild Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ActiveMdiChild Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ActiveMdiChild Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ActiveMdiChild Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ActiveMdiChild Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ActiveMdiChild Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.ActiveForm" />
      </Docs>
    </Member>
    <Member MemberName="AddOwnedForm">
      <MemberSignature Language="C#" Value="public void AddOwnedForm (System.Windows.Forms.Form ownedForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOwnedForm(class System.Windows.Forms.Form ownedForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.AddOwnedForm(System.Windows.Forms.Form)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddOwnedForm (ownedForm As Form)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddOwnedForm(System::Windows::Forms::Form ^ ownedForm);" />
      <MemberSignature Language="F#" Value="member this.AddOwnedForm : System.Windows.Forms.Form -&gt; unit" Usage="form.AddOwnedForm ownedForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownedForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="ownedForm">此窗体将拥有的 <see cref="T:System.Windows.Forms.Form" />。</param>
        <summary>向此窗体添加附属窗体。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 分配给所有者窗体在窗体将保持被拥有直到<xref:System.Windows.Forms.Form.RemoveOwnedForm%2A>调用方法。 此外可以通过设置拥有的另一个窗体<xref:System.Windows.Forms.Form.Owner%2A>属性对其所有者窗体的引用。  
  
 当窗体拥有的另一种形式时，它已关闭或隐藏与所有者窗体。 例如，考虑名为窗体`Form2`归名为窗体`Form1`。 如果`Form1`已关闭或最小化`Form2`也会关闭或隐藏。 附属窗体也永远不会显示在其所有者窗体后面。 可以使用如查找 windows 附属窗体和替换 windows，不应在选择所有者窗体时显示在所有者窗体。  
  
> [!NOTE]
>  如果窗体多文档界面 (MDI) 父窗体，此属性将返回所有显示除了当前任何 MDI 子窗体的窗体打开。 若要获取在 MDI 父窗体中打开的 MDI 子窗体，请使用<xref:System.Windows.Forms.Form.MdiChildren%2A>属性。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.Form.AddOwnedForm%2A>窗体显示为另一个窗体的附属窗体的方法。 附属窗体显示后，你可以尽量减小其所有者窗体和附属窗体将与其降到最低。 该示例需要在示例代码从另一个事件或窗体的方法调用。  
  
 [!code-cpp[Form.AddOwnedForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.AddOwnedForm/CPP/form1.cpp#1)]
 [!code-csharp[Form.AddOwnedForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.AddOwnedForm/CS/form1.cs#1)]
 [!code-vb[Form.AddOwnedForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.AddOwnedForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.OwnedForms" />
        <altmember cref="M:System.Windows.Forms.Form.RemoveOwnedForm(System.Windows.Forms.Form)" />
        <altmember cref="P:System.Windows.Forms.Form.Owner" />
      </Docs>
    </Member>
    <Member MemberName="AdjustFormScrollbars">
      <MemberSignature Language="C#" Value="protected override void AdjustFormScrollbars (bool displayScrollbars);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void AdjustFormScrollbars(bool displayScrollbars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.AdjustFormScrollbars(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub AdjustFormScrollbars (displayScrollbars As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void AdjustFormScrollbars(bool displayScrollbars);" />
      <MemberSignature Language="F#" Value="override this.AdjustFormScrollbars : bool -&gt; unit" Usage="form.AdjustFormScrollbars displayScrollbars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="displayScrollbars" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="displayScrollbars">如果显示滚动条，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>根据当前控件位置和当前所选控件调整容器中的滚动条。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowTransparency">
      <MemberSignature Language="C#" Value="public bool AllowTransparency { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowTransparency" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AllowTransparency" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowTransparency As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowTransparency { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowTransparency : bool with get, set" Usage="System.Windows.Forms.Form.AllowTransparency" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示能否调整窗体的不透明度。</summary>
        <value>如果可以更改窗体的不透明度，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性自动设置为`true`如果`Opacity`发生更改。 当窗体的不透明度设置使用`Opacity`属性，该窗体将在窗体上的对象进行分层。 如果您设置<xref:System.Windows.Forms.Form.AllowTransparency%2A>属性设置为`false`窗体不会在分层的模式下，这将提高的窗体显示性能。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAutoScaling">
      <MemberSignature Language="C#" Value="protected void ApplyAutoScaling ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ApplyAutoScaling() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ApplyAutoScaling" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ApplyAutoScaling ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ApplyAutoScaling();" />
      <MemberSignature Language="F#" Value="member this.ApplyAutoScaling : unit -&gt; unit" Usage="form.ApplyAutoScaling " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Obsolete("This method has been deprecated. Use the ApplyAutoScaling method instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>根据 <see cref="P:System.Windows.Forms.Form.AutoScaleBaseSize" /> 属性的当前值和当前字体的大小来调整窗体大小。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可确定使用的值的窗体大小<xref:System.Windows.Forms.Form.AutoScaleBaseSize%2A>属性和<xref:System.Windows.Forms.Form.Size%2A>返回值<xref:System.Windows.Forms.Form.GetAutoScaleSize%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoScale">
      <MemberSignature Language="C#" Value="public bool AutoScale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoScale" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoScale" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoScale As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoScale { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoScale : bool with get, set" Usage="System.Windows.Forms.Form.AutoScale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated. Use the AutoScaleMode property instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示窗体是否调整其大小以适合该窗体上使用的字体高度，以及是否缩放其控件。</summary>
        <value>如果窗体根据分配给它的当前字体自动缩放本身及其控件，则为 <see langword="true" />；否则，为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Windows.Forms.Form.AutoScale%2A>已过时，已保留用于向后兼容。 未过时的替代项为 <xref:System.Windows.Forms.ContainerControl.AutoScaleMode%2A?displayProperty=nameWithType>。 有关自动缩放的详细信息，请参阅[在 Windows 窗体中的自动缩放](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md)。  
  
 可以使用此属性以允许你的窗体和自动调整其控件基于该字体中的更改。 这可以是应用程序的字体可能会增加或减少基于通过 Windows 使用为指定的语言中很有用。  
  
 若要获取将自动在窗体的大小，使用刻度<xref:System.Windows.Forms.Form.AutoScaleBaseSize%2A>属性。 如果你想要确定大小在窗体将自动调整为根据特定的字体，使用<xref:System.Windows.Forms.Form.GetAutoScaleSize%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoScaleBaseSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Size AutoScaleBaseSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size AutoScaleBaseSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoScaleBaseSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AutoScaleBaseSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Size AutoScaleBaseSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.AutoScaleBaseSize : System.Drawing.Size with get, set" Usage="System.Windows.Forms.Form.AutoScaleBaseSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于自动缩放窗体的基大小。</summary>
        <value><see cref="T:System.Drawing.Size" />，表示此窗体用于自动缩放的基大小。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  此成员已保留用于向后兼容。 有关自动缩放的详细信息，请参阅[在 Windows 窗体中的自动缩放](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md)。  
  
 值<xref:System.Windows.Forms.Form.AutoScaleBaseSize%2A>属性在窗体显示时用来计算在窗体的刻度因子。 自动缩放基大小用于窗体作为基准与系统的字体大小之间的比较来确定多少缩放窗体时使用自动缩放。 如果你想要确定大小窗体将自动调整为根据特定的字体，使用<xref:System.Windows.Forms.Form.GetAutoScaleSize%2A>方法。  
  
> [!NOTE]
>  最初创建窗体时使用此属性的值。 后设置该属性，它不能更改。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.AutoScale" />
        <altmember cref="M:System.Windows.Forms.Form.GetAutoScaleSize(System.Drawing.Font)" />
      </Docs>
    </Member>
    <Member MemberName="AutoScroll">
      <MemberSignature Language="C#" Value="public override bool AutoScroll { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoScroll" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoScroll" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AutoScroll As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoScroll { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoScroll : bool with get, set" Usage="System.Windows.Forms.Form.AutoScroll" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示窗体是否启用自动滚动。</summary>
        <value>若要在窗体上启用自动滚动，为 <see langword="true" />；否则，为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此属性设置为`true`，如果窗体的客户端区域外定位任何控件在窗体上显示滚动条。 此外，当自动滚动时，窗体的工作区自动滚动，以使具有输入焦点的控件可见。  
  
 可以使用此属性以防止用户丢失其视频分辨率设置为较低的分辨率时查看控件的功能。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.Form.AutoScroll%2A>属性以启用显示的控件超出窗体的工作区。 该示例创建一个新窗体并添加<xref:System.Windows.Forms.Button>到窗体控件。 <xref:System.Windows.Forms.Button>控件是超出新窗体的工作区。 <xref:System.Windows.Forms.Form.AutoScroll%2A>属性设置为 true，则窗体，使用户能够向下滚动到控件中显示滚动条。 此示例需要在此示例中定义的方法从另一种形式的事件处理程序或其他方法中调用。  
  
 [!code-cpp[Form.AutoScroll#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.AutoScroll/CPP/form1.cpp#1)]
 [!code-csharp[Form.AutoScroll#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.AutoScroll/CS/form1.cs#1)]
 [!code-vb[Form.AutoScroll#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.AutoScroll/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSize">
      <MemberSignature Language="C#" Value="public override bool AutoSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AutoSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoSize { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoSize : bool with get, set" Usage="System.Windows.Forms.Form.AutoSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Visible)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>根据 <see cref="P:System.Windows.Forms.Form.AutoSizeMode" /> 的设置调整窗体的大小。</summary>
        <value>如果窗体将自动调整大小，则为 <see langword="true" />；如果必须手动调整大小，则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Windows.Forms.Form.AutoSize%2A>强制窗体调整大小以适合其内容。  
  
 窗体不会自动调整大小，在 Visual Studio 窗体设计器中，而不考虑的值<xref:System.Windows.Forms.Form.AutoSize%2A>和<xref:System.Windows.Forms.Form.AutoSizeMode%2A>属性。 在窗体正确调整自身大小在运行时根据这两个属性的值。 与之相反，自定义<xref:System.Windows.Forms.UserControl>自动调整自身大小在设计时和运行时。  
  
 使用时<xref:System.Windows.Forms.Form.AutoSize%2A>，则<xref:System.Windows.Forms.Control.MinimumSize%2A>并<xref:System.Windows.Forms.Control.MaximumSize%2A>属性会遵循，但当前值<xref:System.Windows.Forms.Control.Size%2A>属性将被忽略。 使用<xref:System.Windows.Forms.Form.AutoSize%2A>并<xref:System.Windows.Forms.Form.AutoSizeMode%2A>还会呈现<xref:System.Windows.Forms.Form.AutoScroll%2A>变得多余，因为没有办法缩小要隐藏其包含的控件视图中的窗体的属性。  
  
 请参阅<xref:System.Windows.Forms.AutoSizeMode>窗体行为时的方式的信息的枚举<xref:System.Windows.Forms.Form.AutoSize%2A>是`true`。  
  
   
  
## Examples  
 下面的代码示例显示了创建使用自动调整大小以适合其内容的代码的窗体。 当运行时，窗体显示<xref:System.Windows.Forms.Label>、 一个<xref:System.Windows.Forms.TextBox>用于输入 URL，和一个<xref:System.Windows.Forms.Button>为在用户的默认 Web 浏览器显示该 URL。 代码示例使用<xref:System.Windows.Forms.FlowLayoutPanel>进行布局所包含控制一个接一个。 它还设置<xref:System.Windows.Forms.Control.AutoSize%2A>和<xref:System.Windows.Forms.AutoSizeMode>以放大或缩小以适合其窗体的内容。  
  
 [!code-csharp[Form.AutoSize#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.AutoSize/CS/Form1.cs#1)]
 [!code-vb[Form.AutoSize#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.AutoSize/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AutoSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AutoSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.AutoSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AutoSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ AutoSizeChanged;" />
      <MemberSignature Language="F#" Value="member this.AutoSizeChanged : EventHandler " Usage="member this.AutoSizeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 <see cref="P:System.Windows.Forms.Form.AutoSize" /> 属性更改时发生。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSizeMode">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.AutoSizeMode AutoSizeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AutoSizeMode AutoSizeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoSizeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoSizeMode As AutoSizeMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::AutoSizeMode AutoSizeMode { System::Windows::Forms::AutoSizeMode get(); void set(System::Windows::Forms::AutoSizeMode value); };" />
      <MemberSignature Language="F#" Value="member this.AutoSizeMode : System.Windows.Forms.AutoSizeMode with get, set" Usage="System.Windows.Forms.Form.AutoSizeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AutoSizeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置窗体自动调整自身大小的模式。</summary>
        <value><see cref="T:System.Windows.Forms.AutoSizeMode" /> 枚举值。 默认值为 <see cref="F:System.Windows.Forms.AutoSizeMode.GrowOnly" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置<xref:System.Windows.Forms.Form.AutoSizeMode%2A>属性的新值后，窗体会再次进行布局。  
  
 窗体不会自动调整大小，在 Visual Studio 窗体设计器中，而不考虑的值<xref:System.Windows.Forms.Form.AutoSize%2A>和<xref:System.Windows.Forms.Form.AutoSizeMode%2A>属性。 在窗体正确调整自身大小在运行时根据这两个属性的值。 与之相反，自定义<xref:System.Windows.Forms.UserControl>自动调整自身大小在设计时和运行时。  
  
   
  
## Examples  
 下面的代码示例显示了创建使用自动调整大小以适合其内容的代码的窗体。 当运行时，窗体显示<xref:System.Windows.Forms.Label>、 一个<xref:System.Windows.Forms.TextBox>用于输入 URL，和一个<xref:System.Windows.Forms.Button>为在用户的默认 Web 浏览器显示该 URL。 代码示例使用<xref:System.Windows.Forms.FlowLayoutPanel>进行布局所包含控制一个接一个。 它还设置<xref:System.Windows.Forms.Control.AutoSize%2A>和<xref:System.Windows.Forms.AutoSizeMode>以放大或缩小以适合其窗体的内容。  
  
 [!code-csharp[Form.AutoSize#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.AutoSize/CS/Form1.cs#1)]
 [!code-vb[Form.AutoSize#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.AutoSize/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">该值不是有效的 <see cref="T:System.Windows.Forms.AutoSizeMode" /> 值。</exception>
        <altmember cref="T:System.Windows.Forms.AutoSizeMode" />
        <altmember cref="P:System.Windows.Forms.Form.AutoSize" />
        <altmember cref="M:System.Windows.Forms.Form.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="AutoValidate">
      <MemberSignature Language="C#" Value="public override System.Windows.Forms.AutoValidate AutoValidate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AutoValidate AutoValidate" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoValidate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AutoValidate As AutoValidate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::AutoValidate AutoValidate { System::Windows::Forms::AutoValidate get(); void set(System::Windows::Forms::AutoValidate value); };" />
      <MemberSignature Language="F#" Value="member this.AutoValidate : System.Windows.Forms.AutoValidate with get, set" Usage="System.Windows.Forms.Form.AutoValidate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AutoValidate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示当焦点更改时是否自动验证此容器内的控件。</summary>
        <value>指示焦点更改时是否隐式验证所含控件的 <see cref="T:System.Windows.Forms.AutoValidate" /> 枚举值。 默认值为“继承”。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoValidate" />
      </Docs>
    </Member>
    <Member MemberName="AutoValidateChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AutoValidateChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AutoValidateChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.AutoValidateChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AutoValidateChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ AutoValidateChanged;" />
      <MemberSignature Language="F#" Value="member this.AutoValidateChanged : EventHandler " Usage="member this.AutoValidateChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 <see cref="P:System.Windows.Forms.Form.AutoValidate" /> 属性更改时发生。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BackColor">
      <MemberSignature Language="C#" Value="public override System.Drawing.Color BackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color BackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.BackColor" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color BackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.BackColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.Form.BackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置控件的背景色。</summary>
        <value>表示控件背景色的 <see cref="T:System.Drawing.Color" />。 默认为 <see cref="P:System.Windows.Forms.Control.DefaultBackColor" /> 属性的值。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.BackColor" />
      </Docs>
    </Member>
    <Member MemberName="CancelButton">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.IButtonControl CancelButton { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.IButtonControl CancelButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.CancelButton" />
      <MemberSignature Language="VB.NET" Value="Public Property CancelButton As IButtonControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::IButtonControl ^ CancelButton { System::Windows::Forms::IButtonControl ^ get(); void set(System::Windows::Forms::IButtonControl ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CancelButton : System.Windows.Forms.IButtonControl with get, set" Usage="System.Windows.Forms.Form.CancelButton" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.IButtonControl</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当用户按 Esc 键时单击的按钮控件。</summary>
        <value><see cref="T:System.Windows.Forms.IButtonControl" />，表示窗体的“取消”按钮。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 窗体的取消按钮是每次用户按 ESC 键单击的按钮控件。 分配给此属性的按钮必须是<xref:System.Windows.Forms.IButtonControl>的当前窗体上或位于当前窗体上的容器中。  
  
 此属性可以指定出现在用户在应用程序中按 ESC 键时的默认操作。 可以使用此属性以允许用户快速通过允许他们只需按 ESC 键关闭窗口而不提交更改，而不是手动单击取消按钮使用其鼠标导航的简单窗体。  
  
 <xref:System.Windows.Forms.Form.CancelButton%2A> 可能无法工作如果另一个控件在窗体上的截获 ESC 键。 例如，如果你有<xref:System.Windows.Forms.ComboBox>ESC 将关闭窗体上打开，<xref:System.Windows.Forms.ComboBox>而不是关闭该窗体。  
  
 <xref:System.Windows.Forms.IButtonControl>分配给对象<xref:System.Windows.Forms.Form.CancelButton%2A>必须在窗体上可见，否则按 ESC 键会产生任何效果。  
  
   
  
## Examples  
 下面的代码示例创建的新实例<xref:System.Windows.Forms.Form>，并调用<xref:System.Windows.Forms.Form.ShowDialog%2A>窗体显示为对话框中的方法。 该示例设置<xref:System.Windows.Forms.Form.FormBorderStyle%2A>， <xref:System.Windows.Forms.Form.AcceptButton%2A>， <xref:System.Windows.Forms.Form.CancelButton%2A>， <xref:System.Windows.Forms.Form.MinimizeBox%2A>， <xref:System.Windows.Forms.Form.MaximizeBox%2A>，并<xref:System.Windows.Forms.Form.StartPosition%2A>属性以更改到对话框的外观和功能的窗体。 此示例还使用<xref:System.Windows.Forms.Form.ControlCollection.Add%2A>窗体的方法<xref:System.Windows.Forms.Control.Controls%2A>集合来添加两个<xref:System.Windows.Forms.Button>控件。 该示例使用<xref:System.Windows.Forms.Form.HelpButton%2A>属性对话框中的标题栏中显示帮助按钮。  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.AcceptButton" />
        <altmember cref="T:System.Windows.Forms.IButtonControl" />
      </Docs>
    </Member>
    <Member MemberName="CenterToParent">
      <MemberSignature Language="C#" Value="protected void CenterToParent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void CenterToParent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.CenterToParent" />
      <MemberSignature Language="VB.NET" Value="Protected Sub CenterToParent ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void CenterToParent();" />
      <MemberSignature Language="F#" Value="member this.CenterToParent : unit -&gt; unit" Usage="form.CenterToParent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使窗体在父窗体边界内居中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不要调用<xref:System.Windows.Forms.Form.CenterToParent%2A>在代码中直接的方法。 与此相反，设置<xref:System.Windows.Forms.Form.StartPosition%2A>属性设置为<xref:System.Windows.Forms.FormStartPosition.CenterParent>。  
  
 如果窗体或对话框为顶级，则<xref:System.Windows.Forms.Form.CenterToParent%2A>中心相对于屏幕或桌面上窗体。  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Forms.FormStartPosition.CenterParent" />
        <altmember cref="M:System.Windows.Forms.Form.CenterToScreen" />
      </Docs>
    </Member>
    <Member MemberName="CenterToScreen">
      <MemberSignature Language="C#" Value="protected void CenterToScreen ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void CenterToScreen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.CenterToScreen" />
      <MemberSignature Language="VB.NET" Value="Protected Sub CenterToScreen ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void CenterToScreen();" />
      <MemberSignature Language="F#" Value="member this.CenterToScreen : unit -&gt; unit" Usage="form.CenterToScreen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使窗体在当前屏幕上居中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 请勿在代码中直接调用此。 与此相反，设置<xref:System.Windows.Forms.Form.StartPosition%2A>属性设置为<xref:System.Windows.Forms.FormStartPosition.CenterScreen>。  
  
 <xref:System.Windows.Forms.Form.CenterToScreen%2A>方法使用以下优先级列表以确定用于 center 窗体的屏幕：  
  
1.  <xref:System.Windows.Forms.Form.Owner%2A>窗体的属性。  
  
2.  HWND 窗体的所有者。  
  
3.  在屏幕当前具有鼠标光标。  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Forms.FormStartPosition.CenterScreen" />
        <altmember cref="P:System.Windows.Forms.Form.Owner" />
      </Docs>
    </Member>
    <Member MemberName="ClientSize">
      <MemberSignature Language="C#" Value="public System.Drawing.Size ClientSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size ClientSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ClientSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size ClientSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.ClientSize : System.Drawing.Size with get, set" Usage="System.Windows.Forms.Form.ClientSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Visible)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置窗体工作区的大小。</summary>
        <value><see cref="T:System.Drawing.Size" />，表示窗体工作区的大小。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 窗体的工作区的大小为窗体不包括边框和标题栏的大小。 窗体的工作区是在窗体中放置控件的位置的区域。 此属性可用于执行图形操作时，或大小调整和定位控件在窗体上的时，获取正确的尺寸。 若要获取整个窗体大小，请使用<xref:System.Windows.Forms.Form.Size%2A>属性，或使用单独的属性<xref:System.Windows.Forms.Control.Height%2A>和<xref:System.Windows.Forms.Control.Width%2A>。  
  
> [!NOTE]
>  当前不能绑定到使用应用程序设置此属性。 应用程序设置的详细信息，请参阅[应用程序设置概述](~/docs/framework/winforms/advanced/application-settings-overview.md)。  
  
   
  
## Examples  
 下面的代码示例创建的事件处理程序<xref:System.Windows.Forms.Control.Resize>窗体的事件。 事件处理程序使用<xref:System.Windows.Forms.Form.ClientSize%2A>要使窗体的属性<xref:System.Windows.Forms.Button>控件命名为`button1`填充窗体的整个工作区。  
  
 [!code-cpp[Classic Form.ClientSize Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ClientSize Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ClientSize Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ClientSize Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ClientSize Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ClientSize Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.Size" />
        <altmember cref="P:System.Windows.Forms.Control.Height" />
        <altmember cref="P:System.Windows.Forms.Control.Width" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="form.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>关闭窗体。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 关闭窗体后，在对象中创建的所有资源都关闭和释放该窗体。 可以通过处理防止在运行时关闭窗体<xref:System.Windows.Forms.Form.Closing>事件，并设置<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>属性的<xref:System.ComponentModel.CancelEventArgs>作为参数传递给事件处理程序。 如果你在关闭窗体应用程序的启动窗体，你的应用程序结束。  
  
 两个条件时窗体上未被释放`Close`时 （1） 它是多文档界面 (MDI) 应用程序的一部分和窗体不可见; 并且 （2） 您显示了窗体使用<xref:System.Windows.Forms.Form.ShowDialog%2A>。 在这些情况下，你将需要调用<xref:System.Windows.Forms.Form.Dispose%2A>手动将标记的所有垃圾回收的窗体的控件。  
  
> [!NOTE]
>  当<xref:System.Windows.Forms.Form.Close%2A>上调用方法<xref:System.Windows.Forms.Form>显示为无模式窗口，则不能调用<xref:System.Windows.Forms.Control.Show%2A>方法使窗体可见，因为已释放窗体的资源。 若要隐藏窗体，然后将其可见，请使用<xref:System.Windows.Forms.Control.Hide%2A?displayProperty=nameWithType>方法。  
  
> [!CAUTION]
>  早于[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]2.0 中，<xref:System.Windows.Forms.Form.Closed?displayProperty=nameWithType>并<xref:System.Windows.Forms.Form.Closing?displayProperty=nameWithType>事件不是时引发<xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType>方法调用以退出应用程序。 如果必须在上述任一事件必须执行的验证代码，则应调用<xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType>单独之前，调用每个打开的窗体的方法<xref:System.Windows.Forms.Application.Exit%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在创建句柄时关闭了窗体。</exception>
        <exception cref="T:System.ObjectDisposedException">当 <see cref="E:System.Windows.Forms.Form.Activated" /> 设置为 <see cref="P:System.Windows.Forms.Form.WindowState" /> 时，无法从 <see cref="F:System.Windows.Forms.FormWindowState.Maximized" /> 事件调用此方法。</exception>
        <altmember cref="P:System.ComponentModel.CancelEventArgs.Cancel" />
        <altmember cref="E:System.Windows.Forms.Form.Closing" />
        <altmember cref="T:System.Windows.Forms.CloseReason" />
      </Docs>
    </Member>
    <Member MemberName="Closed">
      <MemberSignature Language="C#" Value="public event EventHandler Closed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Closed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Closed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Closed;" />
      <MemberSignature Language="F#" Value="member this.Closed : EventHandler " Usage="member this.Closed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>关闭窗体时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.Closed>事件是.NET Framework 2.0 版中已过时; 请使用<xref:System.Windows.Forms.Form.FormClosed>事件相反。  
  
 此事件发生在由用户或通过关闭窗体之后<xref:System.Windows.Forms.Form.Close%2A>窗体的方法。 若要阻止关闭窗体，处理<xref:System.Windows.Forms.Form.Closing>事件并设置<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>的属性<xref:System.ComponentModel.CancelEventArgs>传递给事件处理程序`true`。  
  
 若要执行任务，如释放资源窗体使用并保存在窗体中输入信息或更新其父窗体，可以使用此事件。  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.Closed?displayProperty=nameWithType>并<xref:System.Windows.Forms.Form.Closing?displayProperty=nameWithType>不是事件时引发<xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType>方法调用以退出应用程序。 如果必须在上述任一事件必须执行的验证代码，则应调用<xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType>单独之前，调用每个打开的窗体的方法<xref:System.Windows.Forms.Application.Exit%2A>方法。  
  
 如果窗体是 MDI 父窗体中， <xref:System.Windows.Forms.Form.Closing> MDI 父窗体之前引发事件的所有 MDI 子窗体<xref:System.Windows.Forms.Form.Closing>引发事件。 此外，<xref:System.Windows.Forms.Form.Closed>之前，将引发事件的所有 MDI 子窗体<xref:System.Windows.Forms.Form.Closed>引发 MDI 父窗体。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.Form.SetDesktopLocation%2A>， <xref:System.Windows.Forms.Form.Closed>， <xref:System.Windows.Forms.Form.Load>， <xref:System.Windows.Forms.Form.Activated>，和<xref:System.Windows.Forms.Form.Activate%2A>成员。 若要运行该示例，请将以下代码粘贴在一个称为窗体`Form1`包含<xref:System.Windows.Forms.Button>称为`Button1`并将两个<xref:System.Windows.Forms.Label>控件称为`Label1`和`Label2`。  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
        <altmember cref="M:System.Windows.Forms.Form.OnClosed(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.Form.Load" />
      </Docs>
    </Member>
    <Member MemberName="Closing">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler Closing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler Closing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Closing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closing As CancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CancelEventHandler ^ Closing;" />
      <MemberSignature Language="F#" Value="member this.Closing : System.ComponentModel.CancelEventHandler " Usage="member this.Closing : System.ComponentModel.CancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>关闭窗体时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.Closing>事件是.NET Framework 2.0 版中已过时; 请使用<xref:System.Windows.Forms.Form.FormClosing>事件相反。  
  
 <xref:System.Windows.Forms.Form.Closing>事件会出现在窗体正在关闭。 关闭窗体，该对象中的所有资源将都释放并且释放该窗体。 如果取消此事件，窗体保持打开状态。 若要取消窗体的闭包，请设置<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>的属性<xref:System.ComponentModel.CancelEventArgs>传递给事件处理程序`true`。  
  
 当窗体显示为模式对话框中时，单击**关闭**按钮 （与窗体的右上角的 X 按钮） 后，窗体会被隐藏，<xref:System.Windows.Forms.Form.DialogResult%2A>属性设置为`DialogResult.Cancel`。 可以重写的值分配给<xref:System.Windows.Forms.Form.DialogResult%2A>属性在用户单击时**关闭**通过设置按钮<xref:System.Windows.Forms.Form.DialogResult%2A>中的事件处理程序属性<xref:System.Windows.Forms.Form.Closing>窗体的事件。  
  
> [!NOTE]
>  当<xref:System.Windows.Forms.Form.Close%2A>上调用方法<xref:System.Windows.Forms.Form>显示为无模式窗口，则不能调用<xref:System.Windows.Forms.Control.Show%2A>方法使窗体可见，因为已释放窗体的资源。 若要隐藏窗体，然后将其可见，请使用<xref:System.Windows.Forms.Control.Hide%2A?displayProperty=nameWithType>方法。  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.Closed?displayProperty=nameWithType>并<xref:System.Windows.Forms.Form.Closing?displayProperty=nameWithType>不是事件时引发<xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType>方法调用以退出应用程序。 如果必须在上述任一事件必须执行的验证代码，则应调用<xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType>单独之前，调用每个打开的窗体的方法<xref:System.Windows.Forms.Application.Exit%2A>方法。  
  
 如果窗体是 MDI 父窗体中， <xref:System.Windows.Forms.Form.Closing> MDI 父窗体之前引发事件的所有 MDI 子窗体<xref:System.Windows.Forms.Form.Closing>引发事件。 此外，<xref:System.Windows.Forms.Form.Closed>之前，将引发事件的所有 MDI 子窗体<xref:System.Windows.Forms.Form.Closed>引发 MDI 父窗体。 正在取消<xref:System.Windows.Forms.Form.Closing>MDI 子窗体的事件不会阻止<xref:System.Windows.Forms.Form.Closing>引发 MDI 父窗体的事件。 但是，取消该事件将设置为`true`<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>属性的<xref:System.ComponentModel.CancelEventArgs>，作为参数传递到父窗体。 若要强制所有 MDI 父和子窗体关闭，请设置<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>属性设置为`false`在 MDI 父窗体。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Windows.Forms.Form.Closing>若要测试中的文本<xref:System.Windows.Forms.TextBox>已更改。 如果是，用户询问是否要将所做的更改保存到文件。  
  
 [!code-cpp[Form.Closing#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Closing/CPP/form1.cpp#1)]
 [!code-csharp[Form.Closing#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Closing/CS/form1.cs#1)]
 [!code-vb[Form.Closing#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Closing/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
        <altmember cref="M:System.Windows.Forms.Form.OnClosing(System.ComponentModel.CancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="ControlBox">
      <MemberSignature Language="C#" Value="public bool ControlBox { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ControlBox" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ControlBox" />
      <MemberSignature Language="VB.NET" Value="Public Property ControlBox As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ControlBox { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ControlBox : bool with get, set" Usage="System.Windows.Forms.Form.ControlBox" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示在该窗体的标题栏中是否显示控件框。</summary>
        <value><see langword="true" /> 如果窗体的窗体; 右上角显示控件框否则为<see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Windows.Forms.Form.ControlBox%2A>属性设置为`true`中的标题栏的右上角显示控件框。 控制框中可以包含最小化、 最大化，和另外帮助按钮，对关闭按钮。 有关`ControlBox`属性以产生任何影响，还必须设置窗体的<xref:System.Windows.Forms.Form.FormBorderStyle%2A>属性设置为<xref:System.Windows.Forms.FormBorderStyle.FixedSingle?displayProperty=nameWithType>， <xref:System.Windows.Forms.FormBorderStyle.Sizable?displayProperty=nameWithType>， <xref:System.Windows.Forms.FormBorderStyle.Fixed3D?displayProperty=nameWithType>，或<xref:System.Windows.Forms.FormBorderStyle.FixedDialog?displayProperty=nameWithType>。  
  
 如果您设置<xref:System.Windows.Forms.Form.ControlBox%2A>到`false`并且还设置<xref:System.Windows.Forms.Form.Location%2A>属性，<xref:System.Windows.Forms.Form.Size%2A>窗体的属性不会更新以反映已隐藏的窗体非工作区。 若要解决此问题，请将更改的代码放<xref:System.Windows.Forms.Form.Location%2A>中的属性<xref:System.Windows.Forms.Control.HandleCreated>事件处理程序。  
  
> [!NOTE]
>  如果设置为`false`，则<xref:System.Windows.Forms.Form.ControlBox%2A>属性在创建时的最大化显示的多文档界面 (MDI) 子窗体上无效。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Windows.Forms.Form.ControlBox%2A>， <xref:System.Windows.Forms.Form.FormBorderStyle%2A>， <xref:System.Windows.Forms.Form.MaximizeBox%2A>， <xref:System.Windows.Forms.Form.MinimizeBox%2A>，和<xref:System.Windows.Forms.Form.StartPosition%2A>属性，以创建不具有任何边框或标题中的窗体。 在此示例中创建的窗体无法用于创建应用程序的初始屏幕。 该示例需要示例的方法是在窗体类中定义并在初始化窗体时调用。  
  
 [!code-cpp[Classic Form.ControlBox Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ControlBox Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ControlBox Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ControlBox Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ControlBox Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ControlBox Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MaximizeBox" />
        <altmember cref="P:System.Windows.Forms.Form.MinimizeBox" />
        <altmember cref="P:System.Windows.Forms.Form.ShowIcon" />
        <altmember cref="P:System.Windows.Forms.Form.FormBorderStyle" />
        <altmember cref="P:System.Windows.Forms.Form.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="CreateControlsInstance">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.Control.ControlCollection CreateControlsInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Forms.Control/ControlCollection CreateControlsInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.CreateControlsInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateControlsInstance () As Control.ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Forms::Control::ControlCollection ^ CreateControlsInstance();" />
      <MemberSignature Language="F#" Value="override this.CreateControlsInstance : unit -&gt; System.Windows.Forms.Control.ControlCollection" Usage="form.CreateControlsInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control+ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为控件创建控件集合的新实例。</summary>
        <returns>分配给控件的 <see cref="T:System.Windows.Forms.Control.ControlCollection" /> 的新实例。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControlsInstance" />
      </Docs>
    </Member>
    <Member MemberName="CreateHandle">
      <MemberSignature Language="C#" Value="protected override void CreateHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CreateHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.CreateHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CreateHandle ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CreateHandle();" />
      <MemberSignature Language="F#" Value="override this.CreateHandle : unit -&gt; unit" Usage="form.CreateHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为窗体创建句柄。 如果派生类重写了该函数，它必须调用基实现。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Windows.Forms.Form" /> 的句柄已创建。</exception>
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.CreateParams" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CreateParams As CreateParams" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::CreateParams ^ CreateParams { System::Windows::Forms::CreateParams ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateParams : System.Windows.Forms.CreateParams" Usage="System.Windows.Forms.Form.CreateParams" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取创建控件句柄时所需要的创建参数。</summary>
        <value><see cref="T:System.Windows.Forms.CreateParams" />，包含创建控件的句柄时所需的创建参数。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.ContainerControl.CreateParams" />
      </Docs>
    </Member>
    <Member MemberName="Deactivate">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivate;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivate" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Deactivate" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deactivate As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivate;" />
      <MemberSignature Language="F#" Value="member this.Deactivate : EventHandler " Usage="member this.Deactivate : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当窗体失去焦点并不再是活动窗体时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件可用于执行任务，例如已停用窗体的数据更新应用程序中的另一个窗口。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何将此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Form.Deactivate>事件。 此报告可帮助您了解事件发生的并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑更换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或将消息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.Form>名为`Form1`。 然后，确保事件处理程序相关联<xref:System.Windows.Forms.Form.Deactivate>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#393](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#393)]
 [!code-vb[System.Windows.Forms.EventExamples#393](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#393)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Form.Activated" />
        <altmember cref="M:System.Windows.Forms.Form.Activate" />
        <altmember cref="M:System.Windows.Forms.Form.OnDeactivate(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DefaultImeMode">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.ImeMode DefaultImeMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode DefaultImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DefaultImeMode" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultImeMode As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::ImeMode DefaultImeMode { System::Windows::Forms::ImeMode get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultImeMode : System.Windows.Forms.ImeMode" Usage="System.Windows.Forms.Form.DefaultImeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取控件支持的默认输入法编辑器 (IME) 模式。</summary>
        <value><see cref="T:System.Windows.Forms.ImeMode" /> 值之一。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 输入的法编辑器 (IME) 是一个程序，使用户能够使用标准键盘输入复杂字符和符号，如日本汉字字符。  
  
 在中实现<xref:System.Windows.Forms.Form>类，此属性始终返回<xref:System.Windows.Forms.ImeMode.NoControl?displayProperty=nameWithType>值。 此属性的值分配给<xref:System.Windows.Forms.Control.ImeMode%2A?displayProperty=nameWithType>属性。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.ImeMode" />
      </Docs>
    </Member>
    <Member MemberName="DefaultSize">
      <MemberSignature Language="C#" Value="protected override System.Drawing.Size DefaultSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DefaultSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultSize : System.Drawing.Size" Usage="System.Windows.Forms.Form.DefaultSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取控件的默认大小。</summary>
        <value>控件的默认 <see cref="T:System.Drawing.Size" />。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.DefaultSize" />
      </Docs>
    </Member>
    <Member MemberName="DefWndProc">
      <MemberSignature Language="C#" Value="protected override void DefWndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void DefWndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.DefWndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub DefWndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void DefWndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="override this.DefWndProc :  -&gt; unit" Usage="form.DefWndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">要处理的 Windows <see cref="T:System.Windows.Forms.Message" />。</param>
        <summary>向默认窗口过程发送指定消息。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.DefWndProc(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
    <Member MemberName="DesktopBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle DesktopBounds { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle DesktopBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DesktopBounds" />
      <MemberSignature Language="VB.NET" Value="Public Property DesktopBounds As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle DesktopBounds { System::Drawing::Rectangle get(); void set(System::Drawing::Rectangle value); };" />
      <MemberSignature Language="F#" Value="member this.DesktopBounds : System.Drawing.Rectangle with get, set" Usage="System.Windows.Forms.Form.DesktopBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 Windows 桌面上窗体的大小和位置。</summary>
        <value><see cref="T:System.Drawing.Rectangle" />，它使用桌面坐标表示 Windows 桌面上窗体的边界。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 桌面坐标相对于屏幕，其中不包括任务栏的工作区。 在桌面的坐标系统是基于像素的。 如果你的应用程序正在运行的多个监视器系统上，在窗体的坐标是组合桌面的坐标。  
  
 此属性可用于调整大小和在 Windows 桌面上的位置相对于其他窗体或应用程序的窗体。  
  
   
  
## Examples  
 下面的代码示例设置的大小和窗体的位置，以便该窗体是距左边框的顶部的桌面的桌面到 50 个像素。 此示例需要在窗体类定义方法。  
  
 [!code-cpp[Classic Form.DesktopBounds Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.DesktopBounds Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.DesktopBounds Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.DesktopBounds Example/CS/source.cs#1)]
 [!code-vb[Classic Form.DesktopBounds Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.DesktopBounds Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.DesktopLocation" />
      </Docs>
    </Member>
    <Member MemberName="DesktopLocation">
      <MemberSignature Language="C#" Value="public System.Drawing.Point DesktopLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point DesktopLocation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DesktopLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property DesktopLocation As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Point DesktopLocation { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberSignature Language="F#" Value="member this.DesktopLocation : System.Drawing.Point with get, set" Usage="System.Windows.Forms.Form.DesktopLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 Windows 桌面上窗体的位置。</summary>
        <value><see cref="T:System.Drawing.Point" />，表示桌面上窗体的位置。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 桌面坐标相对于屏幕，其中不包括任务栏的工作区。 在桌面的坐标系统是基于像素。 如果你的应用程序正在运行的多监视器系统上，在窗体的坐标是组合桌面的坐标。  
  
 此属性可用于在 Windows 桌面上的位置相对于其他窗体和应用程序窗体。  
  
 如果您调用<xref:System.Windows.Forms.Form.SetDesktopLocation%2A>方法之前调用<xref:System.Windows.Forms.Form.Show%2A>方法中，你的窗体将定位在其默认位置，由操作系统决定。 有关窗口定位的详细信息，请参阅上的 MSDN library 中的"窗口功能"文档"窗口大小和位置"部分http://msdn.microsoft.com/library。  
  
 如果您调用<xref:System.Windows.Forms.Form.SetDesktopLocation%2A>后调用<xref:System.Windows.Forms.Form.Show%2A>，窗体将定位在指定的位置。  
  
   
  
## Examples  
 下面的代码示例设置窗体的位置，以便该窗体是距顶部的桌面的桌面和 100 像素的左边框。 此示例需要窗体类中定义了方法。  
  
 [!code-cpp[Classic Form.DesktopLocation Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.DesktopLocation Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.DesktopLocation Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.DesktopLocation Example/CS/source.cs#1)]
 [!code-vb[Classic Form.DesktopLocation Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.DesktopLocation Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.DesktopBounds" />
      </Docs>
    </Member>
    <Member MemberName="DialogResult">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DialogResult DialogResult { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.DialogResult DialogResult" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DialogResult" />
      <MemberSignature Language="VB.NET" Value="Public Property DialogResult As DialogResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::DialogResult DialogResult { System::Windows::Forms::DialogResult get(); void set(System::Windows::Forms::DialogResult value); };" />
      <MemberSignature Language="F#" Value="member this.DialogResult : System.Windows.Forms.DialogResult with get, set" Usage="System.Windows.Forms.Form.DialogResult" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DialogResult</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置窗体的对话框结果。</summary>
        <value><see cref="T:System.Windows.Forms.DialogResult" />，表示当窗体用作对话框时该窗体的结果。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 窗体的对话框结果是显示为模式对话框时从窗体返回的值。 如果窗体显示为一个对话框，则此属性中的值设置<xref:System.Windows.Forms.DialogResult>枚举设置窗体的对话框结果值、 隐藏模式对话框，并将控制权返回给调用窗体。 此属性通常由设置<xref:System.Windows.Forms.Button.DialogResult%2A>属性的<xref:System.Windows.Forms.Button>窗体上的控件。 当用户单击<xref:System.Windows.Forms.Button>控制分配给的值<xref:System.Windows.Forms.Button.DialogResult%2A>的属性<xref:System.Windows.Forms.Button>分配给<xref:System.Windows.Forms.Form.DialogResult%2A>窗体的属性。  
  
 当窗体显示为模式对话框中时，单击**关闭**按钮 （与窗体的右上角的 X 按钮） 后，窗体会被隐藏，<xref:System.Windows.Forms.Form.DialogResult%2A>属性设置为`DialogResult.Cancel`。 <xref:System.Windows.Forms.Form.Close%2A>方法时不会自动调用用户单击**关闭**按钮的对话框中设置的值或<xref:System.Windows.Forms.Form.DialogResult%2A>属性。 相反，在窗体处于隐藏状态，而无需创建新实例对话框的可再次显示。 由于此行为，必须调用<xref:System.Windows.Forms.Control.Dispose%2A>窗体时应用程序不再需要在窗体的方法。  
  
 此属性可用于确定如何正确处理在对话框中执行的操作以关闭对话框。  
  
> [!NOTE]
>  可以重写的值分配给<xref:System.Windows.Forms.Form.DialogResult%2A>属性在用户单击时**关闭**通过设置按钮<xref:System.Windows.Forms.Form.DialogResult%2A>中的事件处理程序属性<xref:System.Windows.Forms.Form.Closing>窗体的事件。  
  
> [!NOTE]
>  如果<xref:System.Windows.Forms.Form>将显示一个无模式窗口，返回的值为<xref:System.Windows.Forms.Form.DialogResult%2A>属性可能不返回值分配给窗体，因为窗体关闭时自动释放窗体的资源。  
  
   
  
## Examples  
 下面的代码示例显示一个窗体作为一个对话框并显示消息框，该值指示是否通过引用来单击窗体的确定或取消按钮<xref:System.Windows.Forms.Form.DialogResult%2A>窗体的属性。  
  
 [!code-cpp[Classic Form.DialogResult Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.DialogResult Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.DialogResult Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.DialogResult Example/CS/source.cs#1)]
 [!code-vb[Classic Form.DialogResult Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.DialogResult Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">指定值不在有效值范围内。</exception>
        <altmember cref="T:System.Windows.Forms.DialogResult" />
        <altmember cref="P:System.Windows.Forms.Button.DialogResult" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="form.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> 表示释放托管资源和非托管资源；<see langword="false" /> 表示仅释放非托管资源。</param>
        <summary>处置由 <see cref="T:System.Windows.Forms.Form" /> 占用的资源（内存除外）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法由公共`Dispose`方法和<xref:System.Object.Finalize%2A>方法。 `Dispose` 调用受保护`Dispose(Boolean)`方法替换`disposing`参数设置为`true`。 <xref:System.Object.Finalize%2A> 调用`Dispose`与`disposing`设置为`false`。  
  
 当 `disposing` 参数为 `true` 时，此方法释放该 <xref:System.Windows.Forms.Form> 引用的、由任何托管对象持有的全部资源。 此方法调用每个引用对象的 `Dispose` 方法。  
  
 <xref:System.Windows.Forms.Form.Dispose%2A> 如果使用显示窗体将自动调用<xref:System.Windows.Forms.Form.Show%2A>方法。 如果另一种方法，如<xref:System.Windows.Forms.Form.ShowDialog%2A>使用时，或根本永远不会显示窗体，必须调用<xref:System.Windows.Forms.Form.Dispose%2A>自己应用程序中。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> 可以由其他对象多次调用。 重写 <see langword="Dispose(Boolean)" /> 时，请注意不要引用在以前调用 <see langword="Dispose" /> 时已释放的对象。 有关如何实现详细信息<see langword="Dispose(Boolean)" />，请参阅[实现 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。  
  
有关详细信息<see langword="Dispose" />并<see cref="M:System.Object.Finalize" />，请参阅[清理了非托管资源](~/docs/standard/garbage-collection/unmanaged.md)并[重写 Finalize 方法](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100))。</para></block>
      </Docs>
    </Member>
    <Member MemberName="DpiChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DpiChangedEventHandler DpiChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DpiChangedEventHandler DpiChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.DpiChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChanged As DpiChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DpiChangedEventHandler ^ DpiChanged;" />
      <MemberSignature Language="F#" Value="member this.DpiChanged : System.Windows.Forms.DpiChangedEventHandler " Usage="member this.DpiChanged : System.Windows.Forms.DpiChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DpiChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当前显示窗体的显示设备上的 DPI 设置更改时发生。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FormBorderStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.FormBorderStyle FormBorderStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.FormBorderStyle FormBorderStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.FormBorderStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FormBorderStyle As FormBorderStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::FormBorderStyle FormBorderStyle { System::Windows::Forms::FormBorderStyle get(); void set(System::Windows::Forms::FormBorderStyle value); };" />
      <MemberSignature Language="F#" Value="member this.FormBorderStyle : System.Windows.Forms.FormBorderStyle with get, set" Usage="System.Windows.Forms.Form.FormBorderStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-504)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormBorderStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置窗体的边框样式。</summary>
        <value><see cref="T:System.Windows.Forms.FormBorderStyle" />，表示要为窗体显示的边框样式。 默认值为 <see langword="FormBorderStyle.Sizable" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在窗体的边框样式确定的外边缘的窗体的显示方式。 除了更改窗体的边框显示，某些边框样式阻止窗体的大小。 例如，`FormBorderStyle.FixedDialog`边框样式更改为对话框的窗体的边框，并阻止窗体在正调整大小。 大小或窗体的标题栏区域的可用性，还会影响的边框样式。  
  
> [!NOTE]
>  与<xref:System.Windows.Forms.FormBorderStyle.Sizable>样式，就无法调整大小窗口下面某个最小值，即使已设置<xref:System.Windows.Forms.Form.ControlBox%2A>到`false`并分配到一个零长度字符串<xref:System.Windows.Forms.Form.Text%2A>。 解决此问题的工作，请考虑使用<xref:System.Windows.Forms.FormBorderStyle.SizableToolWindow>改为设置样式。  
  
   
  
## Examples  
 下面的代码示例创建的新实例<xref:System.Windows.Forms.Form>，并调用<xref:System.Windows.Forms.Form.ShowDialog%2A>窗体显示为对话框中的方法。 该示例设置<xref:System.Windows.Forms.Form.FormBorderStyle%2A>， <xref:System.Windows.Forms.Form.AcceptButton%2A>， <xref:System.Windows.Forms.Form.CancelButton%2A>， <xref:System.Windows.Forms.Form.MinimizeBox%2A>， <xref:System.Windows.Forms.Form.MaximizeBox%2A>，并<xref:System.Windows.Forms.Form.StartPosition%2A>属性以更改到对话框的外观和功能的窗体。 此示例还使用<xref:System.Windows.Forms.Form.ControlCollection.Add%2A>窗体的方法<xref:System.Windows.Forms.Control.Controls%2A>集合来添加两个<xref:System.Windows.Forms.Button>控件。 该示例使用<xref:System.Windows.Forms.Form.HelpButton%2A>属性对话框中的标题栏中显示帮助按钮。  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">指定值不在有效值范围内。</exception>
        <altmember cref="T:System.Windows.Forms.FormBorderStyle" />
      </Docs>
    </Member>
    <Member MemberName="FormClosed">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.FormClosedEventHandler FormClosed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.FormClosedEventHandler FormClosed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.FormClosed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FormClosed As FormClosedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::FormClosedEventHandler ^ FormClosed;" />
      <MemberSignature Language="F#" Value="member this.FormClosed : System.Windows.Forms.FormClosedEventHandler " Usage="member this.FormClosed : System.Windows.Forms.FormClosedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormClosedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>关闭窗体后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.FormClosed>事件发生在由用户或通过关闭窗体之后<xref:System.Windows.Forms.Form.Close%2A>方法或<xref:System.Windows.Forms.Application.Exit%2A>方法的<xref:System.Windows.Forms.Application>类。 若要阻止关闭窗体，处理<xref:System.Windows.Forms.Form.FormClosing>事件并设置<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>的属性<xref:System.ComponentModel.CancelEventArgs>传递给事件处理程序`true`。  
  
 若要执行任务，如释放资源窗体使用并保存在窗体中输入信息或更新其父窗体，可以使用此事件。  
  
 如果窗体是多文档界面 (MDI) 父窗体<xref:System.Windows.Forms.Form.FormClosing>MDI 父窗体之前引发事件的所有 MDI 子窗体<xref:System.Windows.Forms.Form.FormClosing>引发事件。 同样，<xref:System.Windows.Forms.Form.FormClosed>之前，将引发事件的所有 MDI 子窗体<xref:System.Windows.Forms.Form.FormClosed>引发 MDI 父窗体。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何将此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Form.FormClosed>事件。 此报告可帮助您了解事件发生的并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑更换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或将消息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.Form>名为`Form1`。 然后，确保事件处理程序相关联<xref:System.Windows.Forms.Form.FormClosed>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#395](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#395)]
 [!code-vb[System.Windows.Forms.EventExamples#395](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#395)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
        <altmember cref="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.Close" />
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
        <altmember cref="E:System.Windows.Forms.Form.FormClosing" />
        <altmember cref="E:System.Windows.Forms.Form.Load" />
        <altmember cref="E:System.Windows.Forms.Form.Shown" />
        <altmember cref="T:System.Windows.Forms.CloseReason" />
      </Docs>
    </Member>
    <Member MemberName="FormClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.FormClosingEventHandler FormClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.FormClosingEventHandler FormClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.FormClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FormClosing As FormClosingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::FormClosingEventHandler ^ FormClosing;" />
      <MemberSignature Language="F#" Value="member this.FormClosing : System.Windows.Forms.FormClosingEventHandler " Usage="member this.FormClosing : System.Windows.Forms.FormClosingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormClosingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>关闭窗体前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.FormClosing>事件会出现在窗体正在关闭。 关闭窗体时，它将被释放，释放与表单关联的所有资源。 如果取消此事件，窗体保持打开状态。 若要取消窗体的闭包，请设置<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>的属性<xref:System.Windows.Forms.FormClosingEventArgs>传递给事件处理程序`true`。  
  
 当窗体显示为模式对话框中时，单击**关闭**按钮 （与窗体的右上角的 X 按钮） 后，窗体会被隐藏，<xref:System.Windows.Forms.Form.DialogResult%2A>属性设置为`DialogResult.Cancel`。 可以重写的值分配给<xref:System.Windows.Forms.Form.DialogResult%2A>属性在用户单击时**关闭**通过设置按钮<xref:System.Windows.Forms.Form.DialogResult%2A>中的事件处理程序属性<xref:System.Windows.Forms.Form.FormClosing>窗体的事件。  
  
> [!NOTE]
>  当<xref:System.Windows.Forms.Form.Close%2A>上调用方法<xref:System.Windows.Forms.Form>显示为无模式窗口，则不能调用<xref:System.Windows.Forms.Control.Show%2A>方法使窗体可见，因为已释放窗体的资源。 若要隐藏窗体，然后将其可见，请使用<xref:System.Windows.Forms.Control.Hide%2A>方法。  
  
 如果窗体是多文档界面 (MDI) 父窗体<xref:System.Windows.Forms.Form.FormClosing>MDI 父窗体之前引发事件的所有 MDI 子窗体<xref:System.Windows.Forms.Form.FormClosing>引发事件。 同样，<xref:System.Windows.Forms.Form.FormClosed>之前，将引发事件的所有 MDI 子窗体<xref:System.Windows.Forms.Form.FormClosed>引发 MDI 父窗体。 正在取消<xref:System.Windows.Forms.Form.FormClosing>MDI 子窗体的事件不会阻止<xref:System.Windows.Forms.Form.FormClosing>引发 MDI 父窗体的事件。 但是，取消该事件将设置为`true`<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>属性的<xref:System.Windows.Forms.FormClosingEventArgs>作为参数传递到父窗体的类。 若要强制所有 MDI 父和子窗体关闭，请设置<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>属性设置为`false`在 MDI 父窗体。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何将此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Form.FormClosing>事件。 此报告可帮助您了解事件发生的并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑更换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或将消息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.Form>名为`Form1`。 然后，确保事件处理程序相关联<xref:System.Windows.Forms.Form.FormClosing>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#394](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#394)]
 [!code-vb[System.Windows.Forms.EventExamples#394](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#394)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
        <altmember cref="M:System.Windows.Forms.Form.Close" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
        <altmember cref="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Form.FormClosed" />
        <altmember cref="E:System.Windows.Forms.Form.Load" />
        <altmember cref="E:System.Windows.Forms.Form.Shown" />
        <altmember cref="T:System.Windows.Forms.CloseReason" />
      </Docs>
    </Member>
    <Member MemberName="GetAutoScaleSize">
      <MemberSignature Language="C#" Value="public static System.Drawing.SizeF GetAutoScaleSize (System.Drawing.Font font);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Drawing.SizeF GetAutoScaleSize(class System.Drawing.Font font) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.GetAutoScaleSize(System.Drawing.Font)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::SizeF GetAutoScaleSize(System::Drawing::Font ^ font);" />
      <MemberSignature Language="F#" Value="static member GetAutoScaleSize : System.Drawing.Font -&gt; System.Drawing.SizeF" Usage="System.Windows.Forms.Form.GetAutoScaleSize font" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Obsolete("This method has been deprecated. Use the AutoScaleDimensions property instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="font" Type="System.Drawing.Font" />
      </Parameters>
      <Docs>
        <param name="font"><see cref="T:System.Drawing.Font" />，表示确定窗体的自动缩放基大小的字体。</param>
        <summary>获取根据指定的字体自动缩放窗体时的大小。</summary>
        <returns><see cref="T:System.Drawing.SizeF" />，表示窗体的自动缩放大小。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Windows.Forms.Form.GetAutoScaleSize%2A>方法是已过时的.net Framework 2.0 版。 此成员已保留用于向后兼容。 有关自动缩放的详细信息，请参阅[在 Windows 窗体中的自动缩放](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md)。  
  
 此方法可用于确定窗体将字体应用于窗体之前将自动缩放到特定字体的大小。 如果你想要确定大小窗体是自动缩放为根据当前分配给窗体的字体，请使用<xref:System.Windows.Forms.Form.AutoScaleBaseSize%2A>属性。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.AutoScaleBaseSize" />
      </Docs>
    </Member>
    <Member MemberName="GetScaledBounds">
      <MemberSignature Language="C#" Value="protected override System.Drawing.Rectangle GetScaledBounds (System.Drawing.Rectangle bounds, System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Drawing.Rectangle GetScaledBounds(valuetype System.Drawing.Rectangle bounds, valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetScaledBounds (bounds As Rectangle, factor As SizeF, specified As BoundsSpecified) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Drawing::Rectangle GetScaledBounds(System::Drawing::Rectangle bounds, System::Drawing::SizeF factor, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="override this.GetScaledBounds : System.Drawing.Rectangle * System.Drawing.SizeF * System.Windows.Forms.BoundsSpecified -&gt; System.Drawing.Rectangle" Usage="form.GetScaledBounds (bounds, factor, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bounds" Type="System.Drawing.Rectangle" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="factor" Type="System.Drawing.SizeF" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" Index="2" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="bounds">指定要在显示器边界中检索的区域的 <see cref="T:System.Drawing.Rectangle" />。</param>
        <param name="factor">控件边界的高度和宽度。</param>
        <param name="specified"><see cref="T:System.Windows.Forms.BoundsSpecified" /> 值之一，指定在定义控件大小和位置时要使用的控件边界。</param>
        <summary>检索缩放控件时的边界。</summary>
        <returns>一个表示控件缩放边界的 <see cref="T:System.Drawing.Rectangle" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      </Docs>
    </Member>
    <Member MemberName="HelpButton">
      <MemberSignature Language="C#" Value="public bool HelpButton { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HelpButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.HelpButton" />
      <MemberSignature Language="VB.NET" Value="Public Property HelpButton As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HelpButton { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.HelpButton : bool with get, set" Usage="System.Windows.Forms.Form.HelpButton" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否应在窗体的标题框中显示“帮助”按钮。</summary>
        <value>如果为 <see langword="true" />，则在窗体的标题栏中显示“帮助”按钮；否则，为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当此属性设置为`true`，用问号的小按钮的左侧的标题栏中显示**关闭**按钮。 可以使用此按钮以显示有关你的应用程序的帮助。 可以创建的事件处理程序<xref:System.Windows.Forms.Control.HelpRequested>事件，以单击窗体的帮助按钮时向用户显示的帮助信息。  

若要显示帮助按钮，窗体的值<xref:System.Windows.Forms.Form.ControlBox>属性必须为`true`，其默认值。 <xref:System.Windows.Forms.Form.ControlBox>属性确定是否在标题栏的右上角包含最大化按钮、 最小化按钮、 帮助按钮和关闭按钮等控件。 此外，还必须设置窗体的<xref:System.Windows.Forms.Form.FormBorderStyle%2A>属性设置为<xref:System.Windows.Forms.FormBorderStyle.FixedSingle?displayProperty=nameWithType>， <xref:System.Windows.Forms.FormBorderStyle.Sizable?displayProperty=nameWithType>， <xref:System.Windows.Forms.FormBorderStyle.Fixed3D?displayProperty=nameWithType>，或<xref:System.Windows.Forms.FormBorderStyle.FixedDialog?displayProperty=nameWithType>。  


> [!IMPORTANT]
>  值<xref:System.Windows.Forms.Form.HelpButton%2A>如果忽略属性**最大化**或**最小化**显示按钮。  
  
   
  
## Examples  
 下面的代码示例创建的新实例<xref:System.Windows.Forms.Form>，并调用<xref:System.Windows.Forms.Form.ShowDialog%2A>窗体显示为对话框中的方法。 该示例设置<xref:System.Windows.Forms.Form.FormBorderStyle%2A>， <xref:System.Windows.Forms.Form.AcceptButton%2A>， <xref:System.Windows.Forms.Form.CancelButton%2A>， <xref:System.Windows.Forms.Form.MinimizeBox%2A>， <xref:System.Windows.Forms.Form.MaximizeBox%2A>，并<xref:System.Windows.Forms.Form.StartPosition%2A>属性以更改到对话框的外观和功能的窗体。 此示例还使用<xref:System.Windows.Forms.Form.ControlCollection.Add%2A>窗体的方法<xref:System.Windows.Forms.Control.Controls%2A>集合来添加两个<xref:System.Windows.Forms.Button>控件。 该示例使用<xref:System.Windows.Forms.Form.HelpButton%2A>属性对话框中的标题栏中显示帮助按钮。  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MinimizeBox" />
        <altmember cref="P:System.Windows.Forms.Form.MaximizeBox" />
        <altmember cref="P:System.Windows.Forms.Form.ControlBox" />
        <altmember cref="E:System.Windows.Forms.Form.HelpButtonClicked" />
      </Docs>
    </Member>
    <Member MemberName="HelpButtonClicked">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler HelpButtonClicked;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler HelpButtonClicked" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.HelpButtonClicked" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HelpButtonClicked As CancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CancelEventHandler ^ HelpButtonClicked;" />
      <MemberSignature Language="F#" Value="member this.HelpButtonClicked : System.ComponentModel.CancelEventHandler " Usage="member this.HelpButtonClicked : System.ComponentModel.CancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>单击“帮助”按钮时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.HelpButtonClicked>事件发生时**帮助**单击窗体的标题栏中的按钮。 **帮助**按钮显示时<xref:System.Windows.Forms.Form.HelpButton%2A>属性设置为`true`。 <xref:System.Windows.Forms.Form.HelpButtonClicked> 可以取消。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何将此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Form.HelpButtonClicked>事件。 此报告可帮助您了解事件发生的并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑更换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或将消息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.Form>名为`Form1`。 然后，确保事件处理程序相关联<xref:System.Windows.Forms.Form.HelpButtonClicked>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#388](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#388)]
 [!code-vb[System.Windows.Forms.EventExamples#388](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#388)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.HelpButton" />
        <altmember cref="P:System.Windows.Forms.Form.ControlBox" />
        <altmember cref="M:System.Windows.Forms.Form.OnHelpButtonClicked(System.ComponentModel.CancelEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.HelpRequested" />
      </Docs>
    </Member>
    <Member MemberName="Icon">
      <MemberSignature Language="C#" Value="public System.Drawing.Icon Icon { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Icon Icon" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Icon" />
      <MemberSignature Language="VB.NET" Value="Public Property Icon As Icon" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Icon ^ Icon { System::Drawing::Icon ^ get(); void set(System::Drawing::Icon ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Icon : System.Drawing.Icon with get, set" Usage="System.Windows.Forms.Form.Icon" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Icon</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置窗体的图标。</summary>
        <value><see cref="T:System.Drawing.Icon" />，表示窗体的图标。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 窗体的图标将指定表示的窗体的窗体的控件框中显示的图标以及在任务栏中的图片。  
  
 此属性不会影响如果<xref:System.Windows.Forms.Form.FormBorderStyle%2A>设置为<xref:System.Windows.Forms.FormBorderStyle.FixedDialog>。 在这种情况下，窗体将不显示一个图标。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.ControlBox" />
      </Docs>
    </Member>
    <Member MemberName="InputLanguageChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.InputLanguageChangedEventHandler InputLanguageChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.InputLanguageChangedEventHandler InputLanguageChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.InputLanguageChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event InputLanguageChanged As InputLanguageChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::InputLanguageChangedEventHandler ^ InputLanguageChanged;" />
      <MemberSignature Language="F#" Value="member this.InputLanguageChanged : System.Windows.Forms.InputLanguageChangedEventHandler " Usage="member this.InputLanguageChanged : System.Windows.Forms.InputLanguageChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguageChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>更改窗体的输入语言后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件可用于对窗体的外观和基于窗体的输入语言所做更改的文本进行更改。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何将此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Form.InputLanguageChanged>事件。 此报告可帮助您了解事件发生的并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑更换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或将消息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.Form>名为`Form1`。 然后，确保事件处理程序相关联<xref:System.Windows.Forms.Form.InputLanguageChanged>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#400](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#400)]
 [!code-vb[System.Windows.Forms.EventExamples#400](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#400)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Form.InputLanguageChanging" />
        <altmember cref="M:System.Windows.Forms.Form.OnInputLanguageChanged(System.Windows.Forms.InputLanguageChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InputLanguageChanging">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.InputLanguageChangingEventHandler InputLanguageChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.InputLanguageChangingEventHandler InputLanguageChanging" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.InputLanguageChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event InputLanguageChanging As InputLanguageChangingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::InputLanguageChangingEventHandler ^ InputLanguageChanging;" />
      <MemberSignature Language="F#" Value="member this.InputLanguageChanging : System.Windows.Forms.InputLanguageChangingEventHandler " Usage="member this.InputLanguageChanging : System.Windows.Forms.InputLanguageChangingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguageChangingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当用户尝试更改窗体的输入语言时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 窗体的输入语言的更改之前，将发生此事件。 可以通过设置取消语言更改<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>的属性<xref:System.Windows.Forms.InputLanguageChangingEventArgs>传递给事件处理程序`false`。 如果取消该事件，则不会更改输入的语言。 此事件可用于确定请求的输入的语言的更改是否适合你的应用程序。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何将此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Form.InputLanguageChanging>事件。 此报告可帮助您了解事件发生的并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑更换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或将消息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.Form>名为`Form1`。 然后，确保事件处理程序相关联<xref:System.Windows.Forms.Form.InputLanguageChanging>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#401](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#401)]
 [!code-vb[System.Windows.Forms.EventExamples#401](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#401)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Form.InputLanguageChanged" />
        <altmember cref="M:System.Windows.Forms.Form.OnInputLanguageChanging(System.Windows.Forms.InputLanguageChangingEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="IsMdiChild">
      <MemberSignature Language="C#" Value="public bool IsMdiChild { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMdiChild" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.IsMdiChild" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMdiChild As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMdiChild { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMdiChild : bool" Usage="System.Windows.Forms.Form.IsMdiChild" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示窗体是否为多文档界面 (MDI) 子窗体。</summary>
        <value>如果该窗体是 MDI 子窗体，则为 <see langword="true" />；否则，为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在运行时，MDI 子窗体显示在 MDI 父窗体的工作区中。 可以最大化、 最小化，并移到 MDI 父窗体中的 MDI 子窗体。 若要创建的 MDI 子窗体，将分配<xref:System.Windows.Forms.Form>，将为到 MDI 父窗体<xref:System.Windows.Forms.Form.MdiParent%2A>子窗体的属性。 可以使用<xref:System.Windows.Forms.Form.IsMdiContainer%2A>属性来确定窗体是 MDI 父窗体。  
  
 可以使用<xref:System.Windows.Forms.Form.IsMdiChild%2A>属性来确定由方法或属性返回的窗体是 MDI 子窗体或对话框之类的应用程序中的标准窗体。  
  
> [!NOTE]
>  所有 MDI 子窗体都具有可调整边框，控件菜单框中，并最小化并**最大化**按钮，而不考虑的设置<xref:System.Windows.Forms.Form.FormBorderStyle%2A>， <xref:System.Windows.Forms.Form.ControlBox%2A>， <xref:System.Windows.Forms.Form.MinimizeBox%2A>，并<xref:System.Windows.Forms.Form.MaximizeBox%2A>属性。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MdiParent" />
        <altmember cref="P:System.Windows.Forms.Form.MdiChildren" />
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
      </Docs>
    </Member>
    <Member MemberName="IsMdiContainer">
      <MemberSignature Language="C#" Value="public bool IsMdiContainer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMdiContainer" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.IsMdiContainer" />
      <MemberSignature Language="VB.NET" Value="Public Property IsMdiContainer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMdiContainer { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsMdiContainer : bool with get, set" Usage="System.Windows.Forms.Form.IsMdiContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示窗体是否为多文档界面 (MDI) 子窗体的容器。</summary>
        <value>如果该窗体是 MDI 子窗体的容器，则为 <see langword="true" />；否则，为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性更改为 MDI 父窗体的显示和窗体的行为。 当此属性设置为`true`，窗体显示凸起边框具有凹下的工作区。 分配给父窗体的所有 MDI 子窗体将都显示在其工作区内。  
  
 当关闭 MDI 父窗体时， <xref:System.Windows.Forms.Form.Closing> MDI 父窗体之前引发事件的所有 MDI 子窗体<xref:System.Windows.Forms.Form.Closing>引发事件。 此外，<xref:System.Windows.Forms.Form.Closed>之前，将引发事件的所有 MDI 子窗体<xref:System.Windows.Forms.Form.Closed>引发 MDI 父窗体。  
  
> [!NOTE]
>  如果有两个<xref:System.Windows.Forms.MenuStrip>上设置的 MDI 子窗体控件<xref:System.Windows.Forms.Form.IsMdiContainer%2A>到`true`父窗体将仅其中一个的内容合并<xref:System.Windows.Forms.MenuStrip>控件。 使用<xref:System.Windows.Forms.ToolStripManager.Merge%2A>合并的其他子内容<xref:System.Windows.Forms.MenuStrip>MDI 父窗体上的控件。  
  
   
  
## Examples  
 下面的代码示例演示了如何使用<xref:System.Windows.Forms.Form.IsMdiContainer%2A>属性，以及更改`BackColor`MDI 窗体的属性。 若要运行此示例中，将新窗体中粘贴以下代码。  
  
 [!code-csharp[System.Windows.Forms.MdiClientExample#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MdiClientExample/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.MdiClientExample#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MdiClientExample/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiChild" />
        <altmember cref="P:System.Windows.Forms.Form.MdiParent" />
        <altmember cref="P:System.Windows.Forms.Form.MdiChildren" />
      </Docs>
    </Member>
    <Member MemberName="IsRestrictedWindow">
      <MemberSignature Language="C#" Value="public bool IsRestrictedWindow { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRestrictedWindow" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.IsRestrictedWindow" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsRestrictedWindow As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsRestrictedWindow { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsRestrictedWindow : bool" Usage="System.Windows.Forms.Form.IsRestrictedWindow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示窗体是否可以不受限制地使用所有窗口和用户输入事件。</summary>
        <value>如果窗体有限制，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.IsRestrictedWindow%2A>属性确定是否<xref:System.Security.Permissions.UIPermissionWindow.AllWindows>授予权限。 此属性在窗体的构造函数中的运行时设置，并在窗体的生存期内缓存。 在部分信任环境中运行的 Windows 窗体应用程序不能绕过此检查，因为公共语言运行时可确保，在部分信任情况下始终调用父构造函数。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyPreview">
      <MemberSignature Language="C#" Value="public bool KeyPreview { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeyPreview" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.KeyPreview" />
      <MemberSignature Language="VB.NET" Value="Public Property KeyPreview As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeyPreview { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.KeyPreview : bool with get, set" Usage="System.Windows.Forms.Form.KeyPreview" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示在将键事件传递到具有焦点的控件前，窗体是否将接收此键事件。</summary>
        <value>如果窗体将接收所有键事件，则为 <see langword="true" />；如果窗体上当前选定控件接收键事件，则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当此属性设置为`true`，在窗体将接收所有<xref:System.Windows.Forms.Control.KeyPress>， <xref:System.Windows.Forms.Control.KeyDown>，和<xref:System.Windows.Forms.Control.KeyUp>事件。 窗体的事件处理程序已完成处理按键后，键击然后指派给具有焦点的控件。 例如，如果<xref:System.Windows.Forms.Form.KeyPreview%2A>属性设置为`true`和当前选择的控件是<xref:System.Windows.Forms.TextBox>后由窗体的事件处理程序处理击键、<xref:System.Windows.Forms.TextBox>控件将接收已按下的键。 若要仅在窗体级别处理键盘事件，并且不允许控件接收键盘事件，将设置<xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A?displayProperty=nameWithType>在窗体中的属性<xref:System.Windows.Forms.Control.KeyPress>事件处理程序`true`。  
  
 此属性可用于处理大多数击键中你的应用程序并可以处理键击或调用相应的控件以处理击键。 例如，当应用程序使用功能键，您可能想要处理的键击在窗体级别，而无需为每个控件都可能会收到键击事件编写代码。  
  
> [!NOTE]
>  如果窗体没有任何可见或启用控件，它自动接收所有键盘事件。  
  
> [!NOTE]
>  在窗体上的控件可能进行编程，以取消它接收任何击键。 由于控件永远不会将这些击键发送到窗体中，在窗体将不会看到它们而不考虑的设置<xref:System.Windows.Forms.Form.KeyPreview%2A>。  
  
   
  
## Examples  
 下面的代码示例演示如何设置窗体的<xref:System.Windows.Forms.Form.KeyPreview%2A>属性为 true，并且处理窗体级别的关键事件。 若要运行该示例，请在空白的窗体中粘贴以下代码。  
  
 [!code-cpp[System.Windows.Forms.ProcessMnemonic#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.ProcessMnemonic#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.ProcessMnemonic#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="LayoutMdi">
      <MemberSignature Language="C#" Value="public void LayoutMdi (System.Windows.Forms.MdiLayout value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LayoutMdi(valuetype System.Windows.Forms.MdiLayout value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.LayoutMdi(System.Windows.Forms.MdiLayout)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LayoutMdi (value As MdiLayout)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LayoutMdi(System::Windows::Forms::MdiLayout value);" />
      <MemberSignature Language="F#" Value="member this.LayoutMdi : System.Windows.Forms.MdiLayout -&gt; unit" Usage="form.LayoutMdi value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.MdiLayout" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Windows.Forms.MdiLayout" /> 值之一，定义 MDI 子窗体的布局。</param>
        <summary>在 MDI 父窗体内排列多文档界面 (MDI) 子窗体。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可用于在 MDI 父窗体，以便更易于导航和操作的 MDI 子窗体中排列 MDI 子窗体。 MDI 子窗体可以平铺水平、 垂直，级联，或者显示为 MDI 父窗体内的图标。  
  
   
  
## Examples  
 下面的代码示例显示在 MDI 应用程序的父窗体的窗口菜单的菜单项的事件处理程序。 每个事件处理程序会调用<xref:System.Windows.Forms.Form.LayoutMdi%2A>排列任何子窗体的方法是在应用程序中当前打开。  
  
 [!code-cpp[Classic Form.LayoutMdi Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.LayoutMdi Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.LayoutMdi Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.LayoutMdi Example/CS/source.cs#1)]
 [!code-vb[Classic Form.LayoutMdi Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.LayoutMdi Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MdiLayout" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public event EventHandler Load;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Load" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Load" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Load As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Load;" />
      <MemberSignature Language="F#" Value="member this.Load : EventHandler " Usage="member this.Load : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在第一次显示窗体前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件可用于执行任务，例如窗体使用的资源分配。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.Form.SetDesktopLocation%2A>， <xref:System.Windows.Forms.Form.Load>， <xref:System.Windows.Forms.Form.Activated>，和<xref:System.Windows.Forms.Form.Activate%2A>成员。 若要运行该示例，请将以下代码粘贴在一个称为窗体`Form1`包含<xref:System.Windows.Forms.Button>称为`Button1`并将两个<xref:System.Windows.Forms.Label>控件称为`Label1`和`Label2`。  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.Close" />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public System.Drawing.Point Location { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point Location" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Location" />
      <MemberSignature Language="VB.NET" Value="Public Property Location As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Point Location { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberSignature Language="F#" Value="member this.Location : System.Drawing.Point with get, set" Usage="System.Windows.Forms.Form.Location" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置以屏幕坐标表示的代表 <see cref="T:System.Windows.Forms.Form" /> 左上角的 <see cref="T:System.Drawing.Point" />。</summary>
        <value>以屏幕坐标表示的代表 <see cref="T:System.Drawing.Point" /> 左上角的 <see cref="T:System.Windows.Forms.Form" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Point> 是一种结构，这意味着它是值类型。 如果访问中的属性<xref:System.Drawing.Point>，返回属性的副本。 因此，若要更改<xref:System.Drawing.Point.X%2A>或<xref:System.Drawing.Point.Y%2A>的属性<xref:System.Drawing.Point>从返回<xref:System.Windows.Forms.Control.Location%2A>属性将不会影响<xref:System.Windows.Forms.Control.Left%2A>， <xref:System.Windows.Forms.Control.Right%2A>， <xref:System.Windows.Forms.Control.Top%2A>，或<xref:System.Windows.Forms.Control.Bottom%2A>属性值<xref:System.Windows.Forms.Form>. 若要调整这些属性，分别设置每个属性值，或设置<xref:System.Windows.Forms.Form.Location%2A>具有一个新属性<xref:System.Drawing.Point>。  
  
 <xref:System.Windows.Forms.Form.Location%2A>属性获取或设置<xref:System.Windows.Forms.Control.Location%2A>的属性<xref:System.Windows.Forms.Control>基类，并设置<xref:System.ComponentModel.SettingsBindableAttribute.Bindable%2A>属性设置为`true`。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Form" />
        <altmember cref="T:System.Windows.Forms.ContainerControl" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
      </Docs>
    </Member>
    <Member MemberName="MainMenuStrip">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MenuStrip MainMenuStrip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.MenuStrip MainMenuStrip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MainMenuStrip" />
      <MemberSignature Language="VB.NET" Value="Public Property MainMenuStrip As MenuStrip" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::MenuStrip ^ MainMenuStrip { System::Windows::Forms::MenuStrip ^ get(); void set(System::Windows::Forms::MenuStrip ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MainMenuStrip : System.Windows.Forms.MenuStrip with get, set" Usage="System.Windows.Forms.Form.MainMenuStrip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.ReferenceConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuStrip</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置窗体的主菜单容器。</summary>
        <value><see cref="T:System.Windows.Forms.MenuStrip" /> 表示窗体菜单结构的容器。 默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 除了设置之外<xref:System.Windows.Forms.Form.MainMenuStrip%2A>属性，您必须<xref:System.Windows.Forms.Control.ControlCollection.Add%2A><xref:System.Windows.Forms.MenuStrip>控制对<xref:System.Windows.Forms.Control.Controls%2A>窗体的集合。  
  
 <xref:System.Windows.Forms.MenuStrip>类取代<xref:System.Windows.Forms.MainMenu>在以前版本的.NET Framework 类。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MenuStrip" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
      </Docs>
    </Member>
    <Member MemberName="Margin">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Padding Margin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding Margin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Margin" />
      <MemberSignature Language="VB.NET" Value="Public Property Margin As Padding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Padding Margin { System::Windows::Forms::Padding get(); void set(System::Windows::Forms::Padding value); };" />
      <MemberSignature Language="F#" Value="member this.Margin : System.Windows.Forms.Padding with get, set" Usage="System.Windows.Forms.Form.Margin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置控件之间的空间。</summary>
        <value>表示控件之间的空间的值。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MarginChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MarginChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MarginChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MarginChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MarginChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MarginChanged;" />
      <MemberSignature Language="F#" Value="member this.MarginChanged : EventHandler " Usage="member this.MarginChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 <see cref="P:System.Windows.Forms.Form.Margin" /> 属性更改时发生。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximizeBox">
      <MemberSignature Language="C#" Value="public bool MaximizeBox { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MaximizeBox" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MaximizeBox" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximizeBox As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MaximizeBox { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MaximizeBox : bool with get, set" Usage="System.Windows.Forms.Form.MaximizeBox" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否在窗体的标题栏中显示“最大化”按钮。</summary>
        <value><see langword="true" /> 若要显示**最大化**按钮窗体; 否则为<see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

 一个**最大化**按钮使用户可将其放大到全屏幕大小的窗口。 若要显示**最大化**按钮，窗体的值<xref:System.Windows.Forms.Form.ControlBox>属性必须为`true`，其默认值。  <xref:System.Windows.Forms.Form.ControlBox>属性确定是否在标题栏的右上角包含最大化按钮、 最小化按钮、 帮助按钮和关闭按钮等控件。 此外，还必须设置窗体的<xref:System.Windows.Forms.Form.FormBorderStyle%2A>属性设置为<xref:System.Windows.Forms.FormBorderStyle.FixedSingle?displayProperty=nameWithType>， <xref:System.Windows.Forms.FormBorderStyle.Sizable?displayProperty=nameWithType>， <xref:System.Windows.Forms.FormBorderStyle.Fixed3D?displayProperty=nameWithType>，或<xref:System.Windows.Forms.FormBorderStyle.FixedDialog?displayProperty=nameWithType>。  
  
 一个**最大化**时窗口最大化按钮将自动成为还原按钮。 最小化或还原窗口将自动更改还原按钮返回到**最大化**按钮。  
  
> [!NOTE]
>  在运行时最大化窗体生成<xref:System.Windows.Forms.Control.Resize>事件。 <xref:System.Windows.Forms.Form.WindowState%2A>属性反映在窗口的当前状态。 如果您设置<xref:System.Windows.Forms.Form.WindowState%2A>属性设置为`FormWindowState.Maximized`，独立于任何设置是在起作用的窗体最大化<xref:System.Windows.Forms.Form.MaximizeBox%2A>和<xref:System.Windows.Forms.Form.FormBorderStyle%2A>属性。  
  
   
  
## Examples  
 下面的代码示例创建的新实例<xref:System.Windows.Forms.Form>，并调用<xref:System.Windows.Forms.Form.ShowDialog%2A>窗体显示为对话框中的方法。 该示例设置<xref:System.Windows.Forms.Form.FormBorderStyle%2A>， <xref:System.Windows.Forms.Form.AcceptButton%2A>， <xref:System.Windows.Forms.Form.CancelButton%2A>， <xref:System.Windows.Forms.Form.MinimizeBox%2A>， <xref:System.Windows.Forms.Form.MaximizeBox%2A>，并<xref:System.Windows.Forms.Form.StartPosition%2A>属性以更改到对话框的外观和功能的窗体。 此示例还使用<xref:System.Windows.Forms.Form.ControlCollection.Add%2A>窗体的方法<xref:System.Windows.Forms.Control.Controls%2A>集合来添加两个<xref:System.Windows.Forms.Button>控件。 该示例使用<xref:System.Windows.Forms.Form.HelpButton%2A>属性对话框中的标题栏中显示帮助按钮。  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MinimizeBox" />
        <altmember cref="P:System.Windows.Forms.Form.ControlBox" />
      </Docs>
    </Member>
    <Member MemberName="MaximizedBounds">
      <MemberSignature Language="C#" Value="protected System.Drawing.Rectangle MaximizedBounds { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle MaximizedBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MaximizedBounds" />
      <MemberSignature Language="VB.NET" Value="Protected Property MaximizedBounds As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Drawing::Rectangle MaximizedBounds { System::Drawing::Rectangle get(); void set(System::Drawing::Rectangle value); };" />
      <MemberSignature Language="F#" Value="member this.MaximizedBounds : System.Drawing.Rectangle with get, set" Usage="System.Windows.Forms.Form.MaximizedBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置窗体最大化后的大小。</summary>
        <value><see cref="T:System.Drawing.Rectangle" />，表示窗体最大化后的边界。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Drawing.Rectangle.Top" /> 属性的值大于窗体的高度。  
  
- 或 - 
<see cref="P:System.Drawing.Rectangle.Left" /> 属性的值大于窗体的宽度。</exception>
        <block subset="none" type="overrides"><para>继承的类<see cref="T:System.Windows.Forms.Form" />可以重写此方法时最大化窗体提供新边界。 此类设置此属性在内部时窗体的**最大化**单击按钮。</para></block>
        <altmember cref="P:System.Windows.Forms.Form.MaximumSize" />
        <altmember cref="P:System.Windows.Forms.Form.MinimumSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximizedBoundsChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MaximizedBoundsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MaximizedBoundsChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MaximizedBoundsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MaximizedBoundsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MaximizedBoundsChanged;" />
      <MemberSignature Language="F#" Value="member this.MaximizedBoundsChanged : EventHandler " Usage="member this.MaximizedBoundsChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在 <see cref="P:System.Windows.Forms.Form.MaximizedBounds" /> 属性的值更改后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何将此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Form.MaximizedBoundsChanged>事件。 此报告可帮助您了解事件发生的并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑更换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或将消息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.Form>名为`Form1`。 然后，确保事件处理程序相关联<xref:System.Windows.Forms.Form.MaximizedBoundsChanged>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#389](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#389)]
 [!code-vb[System.Windows.Forms.EventExamples#389](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#389)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MaximizedBounds" />
        <altmember cref="M:System.Windows.Forms.Form.OnMaximizedBoundsChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="MaximumSize">
      <MemberSignature Language="C#" Value="public override System.Drawing.Size MaximumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MaximumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MaximumSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property MaximumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Size MaximumSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumSize : System.Drawing.Size with get, set" Usage="System.Windows.Forms.Form.MaximumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(typeof(System.Drawing.Size), "0, 0")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取窗体可调整到的最大大小。</summary>
        <value><see cref="T:System.Drawing.Size" />，表示该窗体的最大大小。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性可以将指定的最大大小的窗体的大小限制。 您可以使用此功能时一次显示多个窗口以确保在一个窗口不会导致其他窗口处于隐藏状态。 如果此属性设置为<xref:System.Drawing.Size>是 0 高度和宽度，窗体中的为 0 的对象将具有 Windows 所设置的限制之外没有最大大小。  
  
   
  
## Examples  
 下面的代码示例演示了如何设置<xref:System.Windows.Forms.Form.MaximumSize%2A>属性。  
  
 [!code-cpp[System.Windows.Forms.FormExample#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormExample/CPP/form1.cpp#3)]
 [!code-csharp[System.Windows.Forms.FormExample#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormExample/CS/form1.cs#3)]
 [!code-vb[System.Windows.Forms.FormExample#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormExample/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="T:System.Drawing.Size" /> 对象内的高或宽的值小于零。</exception>
        <altmember cref="P:System.Windows.Forms.Form.MaximizedBounds" />
        <altmember cref="P:System.Windows.Forms.Form.MinimumSize" />
        <altmember cref="P:System.Windows.Forms.SystemInformation.MaxWindowTrackSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximumSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MaximumSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MaximumSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MaximumSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MaximumSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MaximumSizeChanged;" />
      <MemberSignature Language="F#" Value="member this.MaximumSizeChanged : EventHandler " Usage="member this.MaximumSizeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在 <see cref="P:System.Windows.Forms.Form.MaximumSize" /> 属性的值更改后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何将此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Form.MaximumSizeChanged>事件。 此报告可帮助您了解事件发生的并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑更换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或将消息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.Form>名为`Form1`。 然后，确保事件处理程序相关联<xref:System.Windows.Forms.Form.MaximumSizeChanged>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#390](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#390)]
 [!code-vb[System.Windows.Forms.EventExamples#390](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#390)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MaximumSize" />
        <altmember cref="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="MdiChildActivate">
      <MemberSignature Language="C#" Value="public event EventHandler MdiChildActivate;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MdiChildActivate" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MdiChildActivate" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MdiChildActivate As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MdiChildActivate;" />
      <MemberSignature Language="F#" Value="member this.MdiChildActivate : EventHandler " Usage="member this.MdiChildActivate : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在多文档界面 (MDI) 应用程序内激活或关闭 MDI 子窗体时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以使用此事件来执行任务，例如更新 MDI 子窗体的内容和更改菜单选项 MDI 父窗体中提供基于状态的 MDI 子窗体的激活。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何将此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Form.MdiChildActivate>事件。 此报告可帮助您了解事件发生的并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑更换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或将消息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.Form>名为`Form1`。 然后，确保事件处理程序相关联<xref:System.Windows.Forms.Form.MdiChildActivate>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#397](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#397)]
 [!code-vb[System.Windows.Forms.EventExamples#397](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#397)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnMdiChildActivate(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="MdiChildren">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form[] MdiChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form[] MdiChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MdiChildren" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MdiChildren As Form()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Windows::Forms::Form ^&gt; ^ MdiChildren { cli::array &lt;System::Windows::Forms::Form ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MdiChildren : System.Windows.Forms.Form[]" Usage="System.Windows.Forms.Form.MdiChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取窗体的数组，这些窗体表示以此窗体作为父级的多文档界面 (MDI) 子窗体。</summary>
        <value><see cref="T:System.Windows.Forms.Form" /> 对象的数组，每个对象都标识此窗体的一个 MDI 子窗体。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性，可获得对所有 MDI 子窗体的 MDI 父窗体中当前打开的引用。 若要创建的 MDI 子窗体，将分配<xref:System.Windows.Forms.Form>，将为到 MDI 父窗体<xref:System.Windows.Forms.Form.MdiParent%2A>子窗体的属性。  
  
 此属性可用于循环访问所有 MDI 子窗体来执行操作，如将数据保存到数据库，MDI 父窗体关闭时或更新基于你的应用程序中执行的操作的子窗体上的字段。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.Form.MdiChildren%2A>属性来循环访问列表的 MDI 子窗体并添加<xref:System.Windows.Forms.Button>到每个控件。  
  
 [!code-cpp[Form.MDIChildren#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.MDIChildren/CPP/form1.cpp#1)]
 [!code-csharp[Form.MDIChildren#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.MDIChildren/CS/form1.cs#1)]
 [!code-vb[Form.MDIChildren#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.MDIChildren/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiChild" />
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
        <altmember cref="P:System.Windows.Forms.Form.MdiParent" />
      </Docs>
    </Member>
    <Member MemberName="MdiParent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form MdiParent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form MdiParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MdiParent" />
      <MemberSignature Language="VB.NET" Value="Public Property MdiParent As Form" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Form ^ MdiParent { System::Windows::Forms::Form ^ get(); void set(System::Windows::Forms::Form ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MdiParent : System.Windows.Forms.Form with get, set" Usage="System.Windows.Forms.Form.MdiParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置此窗体的当前多文档界面 (MDI) 父窗体。</summary>
        <value><see cref="T:System.Windows.Forms.Form" />，表示 MDI 父窗体。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要创建的 MDI 子窗体，将分配<xref:System.Windows.Forms.Form>，将为到 MDI 父窗体<xref:System.Windows.Forms.Form.MdiParent%2A>子窗体的属性。 若要获取所有子窗体都需要的全局信息或调用执行所有子窗体的操作的方法，可以使用的 MDI 子窗体中的此属性。  
  
> [!NOTE]
>  如果有两个<xref:System.Windows.Forms.MenuStrip>上设置的 MDI 子窗体控件<xref:System.Windows.Forms.Form.IsMdiContainer%2A>到`true`父窗体将仅其中一个的内容合并<xref:System.Windows.Forms.MenuStrip>控件。 使用<xref:System.Windows.Forms.ToolStripManager.Merge%2A>合并的其他子内容<xref:System.Windows.Forms.MenuStrip>MDI 父窗体上的控件。  
  
   
  
## Examples  
 下面的代码示例演示如何在 MDI 应用程序中创建子窗体。 示例代码使用唯一的文本来确定子窗体创建一个窗体。 该示例使用<xref:System.Windows.Forms.Form.MdiParent%2A>属性来指定窗体是子窗体。 此示例需要在示例代码从窗体具有调用其<xref:System.Windows.Forms.Form.IsMdiContainer%2A>属性设置为`true`和窗体具有名为的私有类级别的整型变量`childCount`。  
  
 [!code-cpp[Form.MDIParent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.MDIParent/CPP/form1.cpp#1)]
 [!code-csharp[Form.MDIParent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.MDIParent/CS/form1.cs#1)]
 [!code-vb[Form.MDIParent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.MDIParent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">分配给此属性的 <see cref="T:System.Windows.Forms.Form" /> 没有被标记为 MDI 容器。  
  
- 或 - 
分配给此属性的 <see cref="T:System.Windows.Forms.Form" /> 同时作为子 MDI 窗体和 MDI 容器窗体。  
  
- 或 - 
分配给此属性的 <see cref="T:System.Windows.Forms.Form" /> 位于其他线程上。</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">用于请求窗体。 关联枚举：<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />。</permission>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiChild" />
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
        <altmember cref="P:System.Windows.Forms.Form.MdiChildren" />
      </Docs>
    </Member>
    <Member MemberName="Menu">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MainMenu Menu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.MainMenu Menu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Menu" />
      <MemberSignature Language="VB.NET" Value="Public Property Menu As MainMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::MainMenu ^ Menu { System::Windows::Forms::MainMenu ^ get(); void set(System::Windows::Forms::MainMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Menu : System.Windows.Forms.MainMenu with get, set" Usage="System.Windows.Forms.Form.Menu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.ReferenceConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MainMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在窗体中显示的 <see cref="T:System.Windows.Forms.MainMenu" />。</summary>
        <value><see cref="T:System.Windows.Forms.MainMenu" />，表示要在窗体中显示的菜单。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性可用于在运行时完成菜单集之间切换。 例如，定义<xref:System.Windows.Forms.MainMenu>多文档界面 (MDI) 窗体具有没有活动的 MDI 子窗体，另一个时要显示<xref:System.Windows.Forms.MainMenu>显示的子窗口时显示。 您还可以使用其他<xref:System.Windows.Forms.MainMenu>的应用程序需要显示不同的菜单组中存在特定条件时。  
  
   
  
## Examples  
 下面的代码示例将创建<xref:System.Windows.Forms.MainMenu>，将分配两个<xref:System.Windows.Forms.MenuItem>对象添加到<xref:System.Windows.Forms.MainMenu>并将其绑定到窗体。 此示例要求具有<xref:System.Windows.Forms.Form>创建名为`Form1`。  
  
 [!code-cpp[Classic MainMenu.MainMenu Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MainMenu.MainMenu Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MainMenu.MainMenu Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MainMenu.MainMenu Example/CS/source.cs#1)]
 [!code-vb[Classic MainMenu.MainMenu Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MainMenu.MainMenu Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MainMenu" />
        <altmember cref="T:System.Windows.Forms.MenuItem" />
        <altmember cref="T:System.Windows.Forms.Menu" />
      </Docs>
    </Member>
    <Member MemberName="MenuComplete">
      <MemberSignature Language="C#" Value="public event EventHandler MenuComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MenuComplete" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MenuComplete" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MenuComplete As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MenuComplete;" />
      <MemberSignature Language="F#" Value="member this.MenuComplete : EventHandler " Usage="member this.MenuComplete : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当窗体菜单失去焦点时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当单击菜单中的任何菜单项的结果中正在执行的命令和菜单失去焦点时，引发此事件。 可以使用此事件来执行任务，例如更新的文本<xref:System.Windows.Forms.StatusBar>控件或上启用和禁用按钮<xref:System.Windows.Forms.ToolBar>。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何将此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Form.MenuComplete>事件。 此报告可帮助您了解事件发生的并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑更换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或将消息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.Form>名为`Form1`。 然后，确保事件处理程序相关联<xref:System.Windows.Forms.Form.MenuComplete>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#398](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#398)]
 [!code-vb[System.Windows.Forms.EventExamples#398](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#398)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnMenuComplete(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="MenuStart">
      <MemberSignature Language="C#" Value="public event EventHandler MenuStart;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MenuStart" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MenuStart" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MenuStart As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MenuStart;" />
      <MemberSignature Language="F#" Value="member this.MenuStart : EventHandler " Usage="member this.MenuStart : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当窗体菜单接收焦点时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当用户单击菜单中的任何菜单项时，引发此事件。 此事件可用于执行任务，例如启用和禁用时正在访问菜单不应由用户访问窗体控件。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何将此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Form.MenuStart>事件。 此报告可帮助您了解事件发生的并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑更换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或将消息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.Form>名为`Form1`。 然后，确保事件处理程序相关联<xref:System.Windows.Forms.Form.MenuStart>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#399](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#399)]
 [!code-vb[System.Windows.Forms.EventExamples#399](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#399)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnMenuStart(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="MergedMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MainMenu MergedMenu { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.MainMenu MergedMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MergedMenu" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MergedMenu As MainMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::MainMenu ^ MergedMenu { System::Windows::Forms::MainMenu ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MergedMenu : System.Windows.Forms.MainMenu" Usage="System.Windows.Forms.Form.MergedMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MainMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取窗体的合并菜单。</summary>
        <value><see cref="T:System.Windows.Forms.MainMenu" />，表示窗体的合并菜单。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性主要用于在窗体时将使用其父窗体菜单其菜单合并多文档界面 (MDI) 子窗体。 此属性可用于获取 MDI 应用程序以进行更改或添加到菜单结构中的当前菜单结构。 若要获取的未合并<xref:System.Windows.Forms.MainMenu>分配给窗体，使用<xref:System.Windows.Forms.Form.Menu%2A>属性。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MainMenu" />
        <altmember cref="T:System.Windows.Forms.MenuItem" />
        <altmember cref="P:System.Windows.Forms.Form.Menu" />
      </Docs>
    </Member>
    <Member MemberName="MinimizeBox">
      <MemberSignature Language="C#" Value="public bool MinimizeBox { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MinimizeBox" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MinimizeBox" />
      <MemberSignature Language="VB.NET" Value="Public Property MinimizeBox As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MinimizeBox { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MinimizeBox : bool with get, set" Usage="System.Windows.Forms.Form.MinimizeBox" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否在窗体的标题栏中显示“最小化”按钮。</summary>
        <value><see langword="true" /> 若要显示**最小化**按钮窗体; 否则为<see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一个**最小化**按钮使用户能够最小化窗口为图标。 若要显示**最小化**按钮，窗体的值<xref:System.Windows.Forms.Form.ControlBox>属性必须为`true`，其默认值。  <xref:System.Windows.Forms.Form.ControlBox>属性确定是否在标题栏的右上角包含最大化按钮、 最小化按钮、 帮助按钮和关闭按钮等控件。 此外，还必须设置窗体的<xref:System.Windows.Forms.Form.FormBorderStyle%2A>属性设置为<xref:System.Windows.Forms.FormBorderStyle.FixedSingle?displayProperty=nameWithType>， <xref:System.Windows.Forms.FormBorderStyle.Sizable?displayProperty=nameWithType>， <xref:System.Windows.Forms.FormBorderStyle.Fixed3D?displayProperty=nameWithType>，或<xref:System.Windows.Forms.FormBorderStyle.FixedDialog?displayProperty=nameWithType>。  
  
> [!NOTE]
>  最小化窗体，在运行时生成<xref:System.Windows.Forms.Control.Resize>事件。 <xref:System.Windows.Forms.Form.WindowState%2A>属性反映在窗口的当前状态。 如果您设置<xref:System.Windows.Forms.Form.WindowState%2A>属性设置为`FormWindowState.Minimized`，在窗体独立于任何设置是在起作用的最小化<xref:System.Windows.Forms.Form.MinimizeBox%2A>和<xref:System.Windows.Forms.Form.FormBorderStyle%2A>属性。  
  
   
  
## Examples  
 下面的代码示例创建的新实例<xref:System.Windows.Forms.Form>，并调用<xref:System.Windows.Forms.Form.ShowDialog%2A>窗体显示为对话框中的方法。 该示例设置<xref:System.Windows.Forms.Form.FormBorderStyle%2A>， <xref:System.Windows.Forms.Form.AcceptButton%2A>， <xref:System.Windows.Forms.Form.CancelButton%2A>， <xref:System.Windows.Forms.Form.MinimizeBox%2A>， <xref:System.Windows.Forms.Form.MaximizeBox%2A>，并<xref:System.Windows.Forms.Form.StartPosition%2A>属性以更改到对话框的外观和功能的窗体。 此示例还使用<xref:System.Windows.Forms.Form.ControlCollection.Add%2A>窗体的方法<xref:System.Windows.Forms.Control.Controls%2A>集合来添加两个<xref:System.Windows.Forms.Button>控件。 该示例使用<xref:System.Windows.Forms.Form.HelpButton%2A>属性对话框中的标题栏中显示帮助按钮。  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MaximizeBox" />
        <altmember cref="P:System.Windows.Forms.Form.ControlBox" />
      </Docs>
    </Member>
    <Member MemberName="MinimumSize">
      <MemberSignature Language="C#" Value="public override System.Drawing.Size MinimumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MinimumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MinimumSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property MinimumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Size MinimumSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.MinimumSize : System.Drawing.Size with get, set" Usage="System.Windows.Forms.Form.MinimumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.DefaultValue(typeof(System.Drawing.Size), "0, 0")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置窗体可调整到的最小大小。</summary>
        <value><see cref="T:System.Drawing.Size" />，表示该窗体的最小大小。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性可以将指定的最小大小的窗体的大小限制。 此功能可用于防止用户将窗口调整为不合需要的大小。 如果此属性设置为<xref:System.Drawing.Size>是 0 高度和宽度，窗体中的为 0 的对象将具有 Windows 所设置的限制之外没有最小大小。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="T:System.Drawing.Size" /> 对象内的高或宽的值小于零。</exception>
      </Docs>
    </Member>
    <Member MemberName="MinimumSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MinimumSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MinimumSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MinimumSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MinimumSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MinimumSizeChanged;" />
      <MemberSignature Language="F#" Value="member this.MinimumSizeChanged : EventHandler " Usage="member this.MinimumSizeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在 <see cref="P:System.Windows.Forms.Form.MinimumSize" /> 属性的值更改后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何将此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Form.MinimumSizeChanged>事件。 此报告可帮助您了解事件发生的并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑更换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或将消息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.Form>名为`Form1`。 然后，确保事件处理程序相关联<xref:System.Windows.Forms.Form.MinimumSizeChanged>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#391](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#391)]
 [!code-vb[System.Windows.Forms.EventExamples#391](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#391)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnMinimumSizeChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Form.MinimumSize" />
      </Docs>
    </Member>
    <Member MemberName="Modal">
      <MemberSignature Language="C#" Value="public bool Modal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Modal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Modal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Modal { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Modal : bool" Usage="System.Windows.Forms.Form.Modal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否有模式地显示此窗体。</summary>
        <value>如果该窗体进行模式显示，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当有模式地显示窗体时，（键盘或鼠标单击） 能进行任何输入除模式窗体上的对象。 该程序必须隐藏或关闭模式 （通常在对一些用户执行任何操作响应） 窗体之前另一种形式的输入进行。 有模式地显示的窗体通常用作应用程序中的对话框。  
  
 此属性可用于确定是否已有模式地显示已从方法或属性获取一个窗体。  
  
 若要显示窗体以模式方式使用<xref:System.Windows.Forms.Form.ShowDialog%2A>方法。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Windows.Forms.Form.Modal%2A>属性来确定是否窗体显示为模式窗体。 如果不是<xref:System.Windows.Forms.Form.FormBorderStyle%2A>和<xref:System.Windows.Forms.Form.TopLevel%2A>属性发生更改以使具有工具窗口边框的非顶级窗体的窗体。  
  
 [!code-cpp[Form.Modal#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Modal/CPP/form1.cpp#1)]
 [!code-csharp[Form.Modal#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Modal/CS/form1.cs#1)]
 [!code-vb[Form.Modal#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Modal/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.ShowDialog" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnActivated : EventArgs -&gt; unit&#xA;override this.OnActivated : EventArgs -&gt; unit" Usage="form.OnActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.Activated" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnActivated%2A> 方法还允许派生类对事件进行处理而不必附加委托。 重写此方法是用于处理派生类中的事件的首选的技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
        <altmember cref="E:System.Windows.Forms.Form.Activated" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnBackgroundImageChanged">
      <MemberSignature Language="C#" Value="protected override void OnBackgroundImageChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnBackgroundImageChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnBackgroundImageChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnBackgroundImageChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnBackgroundImageChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnBackgroundImageChanged : EventArgs -&gt; unit" Usage="form.OnBackgroundImageChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">包该数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.BackgroundImageChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnBackgroundImageChanged%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnBackgroundImageChanged(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnBackgroundImageChanged(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnBackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="protected override void OnBackgroundImageLayoutChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnBackgroundImageLayoutChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnBackgroundImageLayoutChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnBackgroundImageLayoutChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnBackgroundImageLayoutChanged : EventArgs -&gt; unit" Usage="form.OnBackgroundImageLayoutChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnBackgroundImageLayoutChanged%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnBackgroundImageLayoutChanged(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnBackgroundImageLayoutChanged(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnClosed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnClosed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClosed : EventArgs -&gt; unit&#xA;override this.OnClosed : EventArgs -&gt; unit" Usage="form.OnClosed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.Closed" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.OnClosed%2A>方法已在.NET Framework 2.0 版中过时; 请使用<xref:System.Windows.Forms.Form.OnFormClosed%2A>方法相反。  
  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnFormClosed%2A> 方法还允许派生类对事件进行处理而不必附加委托。 重写此方法是用于处理派生类中的事件的首选的技术。  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.OnClosed%2A>并<xref:System.Windows.Forms.Form.OnClosing%2A>时，不调用方法<xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType>方法调用以退出应用程序。 如果必须执行这些方法之一验证代码，应调用<xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType>单独之前，调用每个打开的窗体的方法<xref:System.Windows.Forms.Application.Exit%2A>方法。  
  
   
  
## Examples  
 下面的代码示例演示如何重写<xref:System.Windows.Forms.Form.OnClosed%2A>方法在类中的派生自<xref:System.Windows.Forms.Form>。  
  
 [!code-cpp[System.Drawing.PointsAndSizes#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.PointsAndSizes/CPP/form1.cpp#6)]
 [!code-csharp[System.Drawing.PointsAndSizes#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.PointsAndSizes/CS/form1.cs#6)]
 [!code-vb[System.Drawing.PointsAndSizes#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.PointsAndSizes/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnClosed(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnClosed(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
        <altmember cref="E:System.Windows.Forms.Form.Closed" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnClosing (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosing(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnClosing(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosing (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosing(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClosing : System.ComponentModel.CancelEventArgs -&gt; unit&#xA;override this.OnClosing : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="form.OnClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.ComponentModel.CancelEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.Closing" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.OnClosing%2A>方法已在.NET Framework 2.0 版中过时; 请使用<xref:System.Windows.Forms.Form.OnFormClosing%2A>方法相反。  
  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnClosing%2A> 方法还允许派生类对事件进行处理而不必附加委托。 重写此方法是用于处理派生类中的事件的首选的技术。  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.OnClosed%2A>并<xref:System.Windows.Forms.Form.OnClosing%2A>时，不调用方法<xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType>方法调用以退出应用程序。 如果必须执行这些方法之一验证代码，应调用<xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType>单独之前，调用每个打开的窗体的方法<xref:System.Windows.Forms.Application.Exit%2A>方法。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Windows.Forms.Form.Closing>若要测试中的文本<xref:System.Windows.Forms.TextBox>已更改。 如果是，用户询问是否要将所做的更改保存到文件。  
  
 [!code-cpp[Form.Closing#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Closing/CPP/form1.cpp#1)]
 [!code-csharp[Form.Closing#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Closing/CS/form1.cs#1)]
 [!code-vb[Form.Closing#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Closing/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnClosing(System.ComponentModel.CancelEventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnClosing(System.ComponentModel.CancelEventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
        <altmember cref="E:System.Windows.Forms.Form.Closing" />
        <altmember cref="T:System.ComponentModel.CancelEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnCreateControl">
      <MemberSignature Language="C#" Value="protected override void OnCreateControl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnCreateControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnCreateControl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnCreateControl ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnCreateControl();" />
      <MemberSignature Language="F#" Value="override this.OnCreateControl : unit -&gt; unit" Usage="form.OnCreateControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>引发 <see langword="CreateControl" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>重写时<see cref="M:System.Windows.Forms.Form.OnCreateControl" />在派生类中，请务必调用基类的<see cref="M:System.Windows.Forms.Form.OnCreateControl" />方法。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnDeactivate">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivate (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivate(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnDeactivate(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivate (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivate(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDeactivate : EventArgs -&gt; unit&#xA;override this.OnDeactivate : EventArgs -&gt; unit" Usage="form.OnDeactivate e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.Deactivate" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnDeactivate%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnDeactivate(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnDeactivate(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
        <altmember cref="E:System.Windows.Forms.Form.Deactivate" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDpiChanged (System.Windows.Forms.DpiChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDpiChanged(class System.Windows.Forms.DpiChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnDpiChanged(System.Windows.Forms.DpiChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDpiChanged (e As DpiChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDpiChanged(System::Windows::Forms::DpiChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDpiChanged : System.Windows.Forms.DpiChangedEventArgs -&gt; unit&#xA;override this.OnDpiChanged : System.Windows.Forms.DpiChangedEventArgs -&gt; unit" Usage="form.OnDpiChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Visible)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DpiChangedEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Forms.DpiChangedEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.DpiChanged" /> 事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEnabledChanged">
      <MemberSignature Language="C#" Value="protected override void OnEnabledChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnEnabledChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnEnabledChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnEnabledChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnEnabledChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnEnabledChanged : EventArgs -&gt; unit" Usage="form.OnEnabledChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.EnabledChanged" /> 事件。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnEnter">
      <MemberSignature Language="C#" Value="protected override void OnEnter (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnEnter(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnEnter(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnEnter (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnEnter(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnEnter : EventArgs -&gt; unit" Usage="form.OnEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.Enter" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnEnter%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnEnter(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnEnter(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnFontChanged">
      <MemberSignature Language="C#" Value="protected override void OnFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnFontChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnFontChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnFontChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnFontChanged : EventArgs -&gt; unit" Usage="form.OnFontChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.FontChanged" /> 事件。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.OnFontChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnFormClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnFormClosed (System.Windows.Forms.FormClosedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFormClosed(class System.Windows.Forms.FormClosedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFormClosed (e As FormClosedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFormClosed(System::Windows::Forms::FormClosedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnFormClosed : System.Windows.Forms.FormClosedEventArgs -&gt; unit&#xA;override this.OnFormClosed : System.Windows.Forms.FormClosedEventArgs -&gt; unit" Usage="form.OnFormClosed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.FormClosedEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Forms.FormClosedEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.FormClosed" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.OnFormClosing%2A>方法中删除从当前窗体<xref:System.Windows.Forms.Application.OpenForms%2A>关联的集合<xref:System.Windows.Forms.Application>。  
  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnFormClosed%2A> 方法还允许派生类对事件进行处理而不必附加委托。 重写此方法是用于处理派生类中的事件的首选的技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
        <altmember cref="E:System.Windows.Forms.Form.FormClosed" />
        <altmember cref="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnFormClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnFormClosing (System.Windows.Forms.FormClosingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFormClosing(class System.Windows.Forms.FormClosingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFormClosing (e As FormClosingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFormClosing(System::Windows::Forms::FormClosingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnFormClosing : System.Windows.Forms.FormClosingEventArgs -&gt; unit&#xA;override this.OnFormClosing : System.Windows.Forms.FormClosingEventArgs -&gt; unit" Usage="form.OnFormClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.FormClosingEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Forms.FormClosingEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.FormClosing" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnFormClosing%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
        <altmember cref="E:System.Windows.Forms.Form.FormClosing" />
        <altmember cref="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnGetDpiScaledSize">
      <MemberSignature Language="C#" Value="protected virtual bool OnGetDpiScaledSize (int deviceDpiOld, int deviceDpiNew, ref System.Drawing.Size desiredSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnGetDpiScaledSize(int32 deviceDpiOld, int32 deviceDpiNew, valuetype System.Drawing.Size&amp; desiredSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnGetDpiScaledSize(System.Int32,System.Int32,System.Drawing.Size@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnGetDpiScaledSize (deviceDpiOld As Integer, deviceDpiNew As Integer, ByRef desiredSize As Size) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnGetDpiScaledSize(int deviceDpiOld, int deviceDpiNew, System::Drawing::Size % desiredSize);" />
      <MemberSignature Language="F#" Value="abstract member OnGetDpiScaledSize : int * int *  -&gt; bool&#xA;override this.OnGetDpiScaledSize : int * int *  -&gt; bool" Usage="form.OnGetDpiScaledSize (deviceDpiOld, deviceDpiNew, desiredSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deviceDpiOld" Type="System.Int32" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="deviceDpiNew" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="desiredSize" Type="System.Drawing.Size" RefType="ref" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="deviceDpiOld">以前显示窗体的显示设备的 DPI 值。</param>
        <param name="deviceDpiNew">将显示窗体的显示设备的 DPI 值。</param>
        <param name="desiredSize">表示基于新 DPI 值的窗体的新大小的 <see cref="T:System.Drawing.Size" />。</param>
        <summary>引发 GetDpiScaledSize 事件。</summary>
        <returns>如果成功，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHandleCreated">
      <MemberSignature Language="C#" Value="protected override void OnHandleCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnHandleCreated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleCreated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleCreated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnHandleCreated : EventArgs -&gt; unit" Usage="form.OnHandleCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.HandleCreated" /> 事件。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnHandleDestroyed">
      <MemberSignature Language="C#" Value="protected override void OnHandleDestroyed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleDestroyed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnHandleDestroyed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleDestroyed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleDestroyed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnHandleDestroyed : EventArgs -&gt; unit" Usage="form.OnHandleDestroyed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.HandleDestroyed" /> 事件。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnHelpButtonClicked">
      <MemberSignature Language="C#" Value="protected virtual void OnHelpButtonClicked (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHelpButtonClicked(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnHelpButtonClicked(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHelpButtonClicked (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHelpButtonClicked(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnHelpButtonClicked : System.ComponentModel.CancelEventArgs -&gt; unit&#xA;override this.OnHelpButtonClicked : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="form.OnHelpButtonClicked e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.ComponentModel.CancelEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.HelpButtonClicked" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnHelpButtonClicked%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnHelpButtonClicked(System.ComponentModel.CancelEventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnHelpButtonClicked(System.ComponentModel.CancelEventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
        <altmember cref="E:System.Windows.Forms.Form.HelpButtonClicked" />
        <altmember cref="E:System.Windows.Forms.Control.QueryAccessibilityHelp" />
        <altmember cref="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnInputLanguageChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnInputLanguageChanged (System.Windows.Forms.InputLanguageChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInputLanguageChanged(class System.Windows.Forms.InputLanguageChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnInputLanguageChanged(System.Windows.Forms.InputLanguageChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInputLanguageChanged (e As InputLanguageChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInputLanguageChanged(System::Windows::Forms::InputLanguageChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInputLanguageChanged : System.Windows.Forms.InputLanguageChangedEventArgs -&gt; unit&#xA;override this.OnInputLanguageChanged : System.Windows.Forms.InputLanguageChangedEventArgs -&gt; unit" Usage="form.OnInputLanguageChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.InputLanguageChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Forms.InputLanguageChangedEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.InputLanguageChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnInputLanguageChanged%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnInputLanguageChanged(System.Windows.Forms.InputLanguageChangedEventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnInputLanguageChanged(System.Windows.Forms.InputLanguageChangedEventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
        <altmember cref="E:System.Windows.Forms.Form.InputLanguageChanged" />
        <altmember cref="T:System.Windows.Forms.InputLanguageChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnInputLanguageChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnInputLanguageChanging (System.Windows.Forms.InputLanguageChangingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInputLanguageChanging(class System.Windows.Forms.InputLanguageChangingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnInputLanguageChanging(System.Windows.Forms.InputLanguageChangingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInputLanguageChanging (e As InputLanguageChangingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInputLanguageChanging(System::Windows::Forms::InputLanguageChangingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInputLanguageChanging : System.Windows.Forms.InputLanguageChangingEventArgs -&gt; unit&#xA;override this.OnInputLanguageChanging : System.Windows.Forms.InputLanguageChangingEventArgs -&gt; unit" Usage="form.OnInputLanguageChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.InputLanguageChangingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Forms.InputLanguageChangingEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.InputLanguageChanging" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnInputLanguageChanging%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnInputLanguageChanging(System.Windows.Forms.InputLanguageChangingEventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnInputLanguageChanging(System.Windows.Forms.InputLanguageChangingEventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
        <altmember cref="E:System.Windows.Forms.Form.InputLanguageChanging" />
        <altmember cref="T:System.Windows.Forms.InputLanguageChangingEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnLayout">
      <MemberSignature Language="C#" Value="protected override void OnLayout (System.Windows.Forms.LayoutEventArgs levent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnLayout(class System.Windows.Forms.LayoutEventArgs levent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnLayout (levent As LayoutEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnLayout(System::Windows::Forms::LayoutEventArgs ^ levent);" />
      <MemberSignature Language="F#" Value="override this.OnLayout : System.Windows.Forms.LayoutEventArgs -&gt; unit" Usage="form.OnLayout levent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="levent" Type="System.Windows.Forms.LayoutEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="levent">事件数据。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.Layout" /> 事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLoad">
      <MemberSignature Language="C#" Value="protected virtual void OnLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoad (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoad(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoad : EventArgs -&gt; unit&#xA;override this.OnLoad : EventArgs -&gt; unit" Usage="form.OnLoad e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.Load" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnLoad%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
        <altmember cref="E:System.Windows.Forms.Form.Load" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMaximizedBoundsChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMaximizedBoundsChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMaximizedBoundsChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMaximizedBoundsChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMaximizedBoundsChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMaximizedBoundsChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMaximizedBoundsChanged : EventArgs -&gt; unit&#xA;override this.OnMaximizedBoundsChanged : EventArgs -&gt; unit" Usage="form.OnMaximizedBoundsChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.MaximizedBoundsChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnMaximizedBoundsChanged%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnMaximizedBoundsChanged(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnMaximizedBoundsChanged(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
        <altmember cref="P:System.Windows.Forms.Form.MaximizedBounds" />
        <altmember cref="E:System.Windows.Forms.Form.MaximizedBoundsChanged" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMaximumSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMaximumSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMaximumSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMaximumSizeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMaximumSizeChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMaximumSizeChanged : EventArgs -&gt; unit&#xA;override this.OnMaximumSizeChanged : EventArgs -&gt; unit" Usage="form.OnMaximumSizeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.MaximumSizeChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnMaximumSizeChanged%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
        <altmember cref="P:System.Windows.Forms.Form.MaximumSize" />
        <altmember cref="E:System.Windows.Forms.Form.MaximumSizeChanged" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMdiChildActivate">
      <MemberSignature Language="C#" Value="protected virtual void OnMdiChildActivate (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMdiChildActivate(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMdiChildActivate(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMdiChildActivate (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMdiChildActivate(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMdiChildActivate : EventArgs -&gt; unit&#xA;override this.OnMdiChildActivate : EventArgs -&gt; unit" Usage="form.OnMdiChildActivate e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.MdiChildActivate" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnMdiChildActivate%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnMdiChildActivate(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnMdiChildActivate(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
        <altmember cref="E:System.Windows.Forms.Form.MdiChildActivate" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMenuComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnMenuComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMenuComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMenuComplete(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMenuComplete (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMenuComplete(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMenuComplete : EventArgs -&gt; unit&#xA;override this.OnMenuComplete : EventArgs -&gt; unit" Usage="form.OnMenuComplete e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.MenuComplete" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnMenuComplete%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnMenuComplete(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnMenuComplete(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
        <altmember cref="E:System.Windows.Forms.Form.MenuComplete" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMenuStart">
      <MemberSignature Language="C#" Value="protected virtual void OnMenuStart (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMenuStart(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMenuStart(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMenuStart (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMenuStart(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMenuStart : EventArgs -&gt; unit&#xA;override this.OnMenuStart : EventArgs -&gt; unit" Usage="form.OnMenuStart e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.MenuStart" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnMenuStart%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnMenuStart(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnMenuStart(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
        <altmember cref="E:System.Windows.Forms.Form.MenuStart" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMinimumSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMinimumSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMinimumSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMinimumSizeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMinimumSizeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMinimumSizeChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMinimumSizeChanged : EventArgs -&gt; unit&#xA;override this.OnMinimumSizeChanged : EventArgs -&gt; unit" Usage="form.OnMinimumSizeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.MinimumSizeChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnMinimumSizeChanged%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnMinimumSizeChanged(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnMinimumSizeChanged(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
        <altmember cref="E:System.Windows.Forms.Form.MinimumSizeChanged" />
        <altmember cref="P:System.Windows.Forms.Form.MinimumSize" />
      </Docs>
    </Member>
    <Member MemberName="OnPaint">
      <MemberSignature Language="C#" Value="protected override void OnPaint (System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPaint(class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnPaint(System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPaint (e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPaint(System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnPaint : System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="form.OnPaint e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Forms.PaintEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.Paint" /> 事件。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnResize">
      <MemberSignature Language="C#" Value="protected override void OnResize (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnResize(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnResize(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnResize (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnResize(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnResize : EventArgs -&gt; unit" Usage="form.OnResize e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.Resize" /> 事件。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnResizeBegin">
      <MemberSignature Language="C#" Value="protected virtual void OnResizeBegin (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResizeBegin(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnResizeBegin(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnResizeBegin (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnResizeBegin(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnResizeBegin : EventArgs -&gt; unit&#xA;override this.OnResizeBegin : EventArgs -&gt; unit" Usage="form.OnResizeBegin e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.ResizeBegin" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ResizeBegin>将仅引发事件，如果窗体的<xref:System.Windows.Forms.Control.CanRaiseEvents%2A>属性设置为`true`。  
  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnResizeBegin%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnResizeBegin(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnResizeBegin(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
        <altmember cref="E:System.Windows.Forms.Form.ResizeBegin" />
        <altmember cref="M:System.Windows.Forms.Form.OnResizeEnd(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnResizeEnd">
      <MemberSignature Language="C#" Value="protected virtual void OnResizeEnd (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResizeEnd(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnResizeEnd(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnResizeEnd (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnResizeEnd(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnResizeEnd : EventArgs -&gt; unit&#xA;override this.OnResizeEnd : EventArgs -&gt; unit" Usage="form.OnResizeEnd e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.ResizeEnd" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ResizeEnd>将仅引发事件，如果窗体的<xref:System.Windows.Forms.Control.CanRaiseEvents%2A>属性设置为`true`。  
  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnResizeEnd%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnResizeEnd(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnResizeEnd(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
        <altmember cref="E:System.Windows.Forms.Form.ResizeEnd" />
        <altmember cref="M:System.Windows.Forms.Form.OnResizeBegin(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnRightToLeftLayoutChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRightToLeftLayoutChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRightToLeftLayoutChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnRightToLeftLayoutChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRightToLeftLayoutChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRightToLeftLayoutChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRightToLeftLayoutChanged : EventArgs -&gt; unit&#xA;override this.OnRightToLeftLayoutChanged : EventArgs -&gt; unit" Usage="form.OnRightToLeftLayoutChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.RightToLeftLayoutChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前窗体或其父项之一正在释放资源，<xref:System.Windows.Forms.Form.OnRightToLeftLayoutChanged%2A>方法将返回而不执行任何操作。 如果<xref:System.Windows.Forms.Control.RightToLeft%2A>窗体的属性的值为<xref:System.Windows.Forms.RightToLeft.Yes>，然后通过调用将重新创建窗体及其子控件的句柄<xref:System.Windows.Forms.Control.RecreateHandle%2A>方法。  
  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnRightToLeftLayoutChanged%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnRightToLeftLayoutChanged(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnRightToLeftLayoutChanged(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
        <altmember cref="E:System.Windows.Forms.Form.RightToLeftLayoutChanged" />
        <altmember cref="P:System.Windows.Forms.Form.RightToLeftLayout" />
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="Overload:System.Windows.Forms.Form.Dispose" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
      </Docs>
    </Member>
    <Member MemberName="OnShown">
      <MemberSignature Language="C#" Value="protected virtual void OnShown (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnShown(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnShown (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnShown(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnShown : EventArgs -&gt; unit&#xA;override this.OnShown : EventArgs -&gt; unit" Usage="form.OnShown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.Shown" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.Shown>事件发生时首次显示窗体。  
  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnShown%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
        <altmember cref="E:System.Windows.Forms.Form.Shown" />
        <altmember cref="Overload:System.Windows.Forms.Form.Show" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected override void OnStyleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnStyleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnStyleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnStyleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnStyleChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnStyleChanged : EventArgs -&gt; unit" Usage="form.OnStyleChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.StyleChanged" /> 事件。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnTextChanged">
      <MemberSignature Language="C#" Value="protected override void OnTextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnTextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnTextChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnTextChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnTextChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnTextChanged : EventArgs -&gt; unit" Usage="form.OnTextChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.TextChanged" /> 事件。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnVisibleChanged">
      <MemberSignature Language="C#" Value="protected override void OnVisibleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnVisibleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnVisibleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnVisibleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnVisibleChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnVisibleChanged : EventArgs -&gt; unit" Usage="form.OnVisibleChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.VisibleChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnVisibleChanged%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnVisibleChanged(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnVisibleChanged(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
        <altmember cref="E:System.Windows.Forms.Control.VisibleChanged" />
      </Docs>
    </Member>
    <Member MemberName="Opacity">
      <MemberSignature Language="C#" Value="public double Opacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Opacity" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Opacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Opacity As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Opacity { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Opacity : double with get, set" Usage="System.Windows.Forms.Form.Opacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(1)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.Forms.OpacityConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置窗体的不透明度级别。</summary>
        <value>窗体的不透明度级别。 默认值为 1.00。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.Opacity%2A>属性可以指定为窗体及其控件的透明度级别。 当此属性设置为小于 100%(1.00) 的值时，则整个窗体，包括边框、 由更加透明。 此属性设置为值为 0%(0.00) 使窗体完全不可见。 可以使用此属性，以提供不同级别的透明度或提供如窗体逐渐入或移出视图的效果。 例如，您可以阶段窗体到视图通过设置<xref:System.Windows.Forms.Form.Opacity%2A>属性设置为 0%(0.00) 和逐渐增加的值，直到它达到 100%(1.00) 的值。  
  
 <xref:System.Windows.Forms.Form.Opacity%2A> 不同于由提供的透明度<xref:System.Windows.Forms.Form.TransparencyKey%2A>，后者只能使窗体，并且其控件完全透明如果中指定的值与相同的颜色<xref:System.Windows.Forms.Form.TransparencyKey%2A>属性。  
  
 此属性不是支持何时<xref:System.Windows.Forms.Form.RightToLeftLayout%2A>是`true`。  
  
 <xref:System.Windows.Forms.Form.Opacity%2A>属性取决于分层 Windows API 引入 Windows 2000。 有关详细信息，请参阅"分层 Windows:新建和的方式使用半透明度在 Windows 应用程序中的透明效果"上的平台 SDK 文档中[ http://msdn.microsoft.com ](https://msdn.microsoft.com/)。  
  
   
  
## Examples  
 下面的代码示例演示如何创建带有 75%的不透明度级别显示的窗体。 该代码示例创建新的窗体，位于与屏幕的中央<xref:System.Windows.Forms.Form.Opacity%2A>属性设置为更改窗体的不透明度级别。 代码示例还将设置<xref:System.Windows.Forms.Form.Size%2A>属性以提供更大大小超过默认大小的窗体的窗体。 编写此代码示例时，在此示例中定义的方法从另一种形式的事件处理程序或其他方法中调用的假设。  
  
 [!code-cpp[Form.Opacity#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Opacity/CPP/form1.cpp#1)]
 [!code-csharp[Form.Opacity#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Opacity/CS/form1.cs#1)]
 [!code-vb[Form.Opacity#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Opacity/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.TransparencyKey" />
        <altmember cref="F:System.Windows.Forms.OSFeature.LayeredWindows" />
      </Docs>
    </Member>
    <Member MemberName="OwnedForms">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form[] OwnedForms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form[] OwnedForms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.OwnedForms" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnedForms As Form()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Windows::Forms::Form ^&gt; ^ OwnedForms { cli::array &lt;System::Windows::Forms::Form ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnedForms : System.Windows.Forms.Form[]" Usage="System.Windows.Forms.Form.OwnedForms" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Windows.Forms.Form" /> 对象的数组，这些对象表示此窗体拥有的所有窗体。</summary>
        <value><see cref="T:System.Windows.Forms.Form" /> 数组，它表示此窗体的附属窗体。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回一个数组，包含此窗体拥有的所有窗体。 若要使窗体拥有的另一种形式，请调用<xref:System.Windows.Forms.Form.AddOwnedForm%2A>方法。 分配给所有者窗体在窗体仍拥有直到<xref:System.Windows.Forms.Form.RemoveOwnedForm%2A>调用方法。 此外可以通过设置拥有的另一个窗体<xref:System.Windows.Forms.Form.Owner%2A>属性对其所有者窗体的引用。  
  
 当窗体拥有的另一种形式时，它已关闭或隐藏与所有者窗体。 例如，考虑名为窗体`Form2`归名为窗体`Form1`。 如果`Form1`已关闭或最小化`Form2`也会关闭或隐藏。 附属窗体也永远不会显示在其所有者窗体后面。 可以使用如查找 windows 附属窗体和替换 windows，不应在选择所有者窗体时显示在所有者窗体。  
  
> [!NOTE]
>  如果窗体多文档界面 (MDI) 父窗体，此属性将返回所有显示除了当前任何 MDI 子窗体的窗体打开。 若要获取在 MDI 父窗体中打开的 MDI 子窗体，请使用<xref:System.Windows.Forms.Form.MdiChildren%2A>属性。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.Form.OwnedForms%2A>属性以修改所有者窗体拥有的所有窗体。 在示例中第一种方法将窗体添加到与附属窗体的附属窗体的数组。 第二种方法循环访问所有附属窗体，并更改标题。 此示例需要这两种方法由一个事件或窗体的其他方法调用。  
  
 [!code-cpp[Form.OwnedForms#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.OwnedForms/CPP/form1.cpp#1)]
 [!code-csharp[Form.OwnedForms#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.OwnedForms/CS/form1.cs#1)]
 [!code-vb[Form.OwnedForms#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.OwnedForms/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.AddOwnedForm(System.Windows.Forms.Form)" />
        <altmember cref="M:System.Windows.Forms.Form.RemoveOwnedForm(System.Windows.Forms.Form)" />
        <altmember cref="P:System.Windows.Forms.Form.Owner" />
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form Owner { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form Owner" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Owner" />
      <MemberSignature Language="VB.NET" Value="Public Property Owner As Form" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Form ^ Owner { System::Windows::Forms::Form ^ get(); void set(System::Windows::Forms::Form ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Owner : System.Windows.Forms.Form with get, set" Usage="System.Windows.Forms.Form.Owner" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置拥有此窗体的窗体。</summary>
        <value><see cref="T:System.Windows.Forms.Form" />，表示作为此窗体的所有者的窗体。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要使窗体拥有的另一种形式，将分配其<xref:System.Windows.Forms.Form.Owner%2A>对将成为所有者的窗体的引用的属性。  
  
 当窗体拥有的另一种形式时，它已关闭或隐藏与所有者窗体。 例如，考虑名为窗体`Form2`归名为窗体`Form1`。 如果`Form1`已关闭或最小化`Form2`也会关闭或隐藏。附属窗体也永远不会显示在其所有者窗体后面。 可以使用如查找 windows 附属窗体和替换 windows，选择所有者窗体时应不会消失。 若要确定所拥有的父窗体的窗体，请使用<xref:System.Windows.Forms.Form.OwnedForms%2A>属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">顶级窗口不能具有所有者。</exception>
        <altmember cref="M:System.Windows.Forms.Form.AddOwnedForm(System.Windows.Forms.Form)" />
        <altmember cref="M:System.Windows.Forms.Form.RemoveOwnedForm(System.Windows.Forms.Form)" />
        <altmember cref="P:System.Windows.Forms.Form.OwnedForms" />
      </Docs>
    </Member>
    <Member MemberName="ProcessCmdKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessCmdKey (ref System.Windows.Forms.Message msg, System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessCmdKey(valuetype System.Windows.Forms.Message&amp; msg, valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessCmdKey (ByRef msg As Message, keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessCmdKey(System::Windows::Forms::Message % msg, System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="override this.ProcessCmdKey :  * System.Windows.Forms.Keys -&gt; bool" Usage="form.ProcessCmdKey (msg, keyData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message" RefType="ref" />
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="msg">通过引用传递的 <see cref="T:System.Windows.Forms.Message" />，它表示要处理的 Win32 消息。</param>
        <param name="keyData"><see cref="T:System.Windows.Forms.Keys" /> 值之一，表示要处理的键。</param>
        <summary>处理命令键。</summary>
        <returns>如果控件处理并使用击键，则为 <see langword="true" />；否则为 <see langword="false" />，以允许进一步处理。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ProcessCmdKey%2A>方法重写基  
  
 <xref:System.Windows.Forms.ContainerControl.ProcessCmdKey%2A?displayProperty=nameWithType> 要提供其他处理的主菜单命令键和 MDI 加速器的实现。  
  
 有关捕获击键的信息，请参阅[如何通过使用视觉对象捕获在控件中的键击C#](https://support.microsoft.com/help/320584/how-to-trap-keystrokes-in-controls-by-using-visual-c)并[如何捕获在.NET 中的键击控件通过使用 Visual Basic.NET](https://support.microsoft.com/help/320583/how-to-trap-keystrokes-in-net-controls-by-using-visual-basic-net-or-vi)在 microsoft支持网站。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
        <altmember cref="T:System.Windows.Forms.Message" />
        <altmember cref="M:System.Windows.Forms.Form.ProcessDialogKey(System.Windows.Forms.Keys)" />
        <altmember cref="M:System.Windows.Forms.Form.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
        <altmember cref="M:System.Windows.Forms.ContainerControl.ProcessMnemonic(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogChar">
      <MemberSignature Language="C#" Value="protected override bool ProcessDialogChar (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessDialogChar(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessDialogChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessDialogChar (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessDialogChar(char charCode);" />
      <MemberSignature Language="F#" Value="override this.ProcessDialogChar : char -&gt; bool" Usage="form.ProcessDialogChar charCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">要处理的字符。</param>
        <summary>处理对话框字符。</summary>
        <returns>如果字符已由控件处理，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessDialogKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessDialogKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessDialogKey(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessDialogKey (keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessDialogKey(System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="override this.ProcessDialogKey : System.Windows.Forms.Keys -&gt; bool" Usage="form.ProcessDialogKey keyData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData"><see cref="T:System.Windows.Forms.Keys" /> 值之一，表示要处理的键。</param>
        <summary>处理对话框键。</summary>
        <returns>如果控件处理并使用击键，则为 <see langword="true" />；否则为 <see langword="false" />，以允许进一步处理。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ProcessDialogKey%2A>方法重写基<xref:System.Windows.Forms.ContainerControl.ProcessDialogKey%2A?displayProperty=nameWithType>实现以提供的对话框中的返回和转义键的其他处理。 方法包括 ALT 或控件修饰符的击键上执行任何处理。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.ProcessDialogKey(System.Windows.Forms.Keys)" />
        <altmember cref="M:System.Windows.Forms.Form.ProcessDialogChar(System.Char)" />
        <altmember cref="M:System.Windows.Forms.Form.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
        <altmember cref="M:System.Windows.Forms.ContainerControl.ProcessMnemonic(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyPreview">
      <MemberSignature Language="C#" Value="protected override bool ProcessKeyPreview (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessKeyPreview(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessKeyPreview(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessKeyPreview (ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessKeyPreview(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="override this.ProcessKeyPreview :  -&gt; bool" Usage="form.ProcessKeyPreview m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">通过引用传递的 <see cref="T:System.Windows.Forms.Message" />，表示要处理的窗口消息。</param>
        <summary>预览键盘消息。</summary>
        <returns>如果消息已由控件处理，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.ProcessKeyPreview(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessMnemonic">
      <MemberSignature Language="C#" Value="protected internal override bool ProcessMnemonic (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance bool ProcessMnemonic(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessMnemonic(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function ProcessMnemonic (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override bool ProcessMnemonic(char charCode);" />
      <MemberSignature Language="F#" Value="override this.ProcessMnemonic : char -&gt; bool" Usage="form.ProcessMnemonic charCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="charCode">要处理的字符。</param>
        <summary>处理助记键字符。</summary>
        <returns>如果字符由控件作为助记键处理，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessTabKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessTabKey (bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessTabKey(bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessTabKey(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessTabKey (forward As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessTabKey(bool forward);" />
      <MemberSignature Language="F#" Value="override this.ProcessTabKey : bool -&gt; bool" Usage="form.ProcessTabKey forward" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="forward">如果在 ContainerControl 内的控件中向前循环，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>选择下一个可用控件并使其成为活动控件。</summary>
        <returns>如果选择了一个控件，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.ProcessTabKey(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveOwnedForm">
      <MemberSignature Language="C#" Value="public void RemoveOwnedForm (System.Windows.Forms.Form ownedForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveOwnedForm(class System.Windows.Forms.Form ownedForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.RemoveOwnedForm(System.Windows.Forms.Form)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveOwnedForm (ownedForm As Form)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveOwnedForm(System::Windows::Forms::Form ^ ownedForm);" />
      <MemberSignature Language="F#" Value="member this.RemoveOwnedForm : System.Windows.Forms.Form -&gt; unit" Usage="form.RemoveOwnedForm ownedForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownedForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="ownedForm"><see cref="T:System.Windows.Forms.Form" />，表示要从此窗体的附属窗体列表中移除的窗体。</param>
        <summary>从此窗体移除附属窗体。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 分配给所有者窗体在窗体将保持被拥有直到<xref:System.Windows.Forms.Form.RemoveOwnedForm%2A>调用方法。 除了从列表中的附属窗体移除附属窗体，此方法还设置所有者窗体为`null`。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.AddOwnedForm(System.Windows.Forms.Form)" />
        <altmember cref="P:System.Windows.Forms.Form.Owner" />
        <altmember cref="P:System.Windows.Forms.Form.OwnedForms" />
      </Docs>
    </Member>
    <Member MemberName="ResizeBegin">
      <MemberSignature Language="C#" Value="public event EventHandler ResizeBegin;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ResizeBegin" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.ResizeBegin" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResizeBegin As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ResizeBegin;" />
      <MemberSignature Language="F#" Value="member this.ResizeBegin : EventHandler " Usage="member this.ResizeBegin : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>窗体进入大小调整模式时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ResizeBegin>用户开始调整窗体中，通常通过单击和拖动边框或位于窗体右下角的大小调整手柄之一时将引发事件。 此操作将在窗体放入大小调整模式循环，直到完成调整大小操作。 通常情况下，调整大小操作过程中发生以下事件集：  
  
1.  单个<xref:System.Windows.Forms.Form.ResizeBegin>事件发生在窗体进入大小调整模式。  
  
2.  零个或多个对<xref:System.Windows.Forms.Control.Resize>并<xref:System.Windows.Forms.Control.SizeChanged>作为窗体的事件发生<xref:System.Windows.Forms.Form.Size%2A>被修改。  
  
3.  单个<xref:System.Windows.Forms.Form.ResizeEnd>事件发生在窗体退出大小调整模式。  
  
> [!NOTE]
>  只需单击而不拖动边框或重设大小手柄将生成<xref:System.Windows.Forms.Form.ResizeBegin>并<xref:System.Windows.Forms.Form.ResizeEnd>事件而无需任何中间<xref:System.Windows.Forms.Control.Resize>和<xref:System.Windows.Forms.Control.SizeChanged>事件对。  
  
 <xref:System.Windows.Forms.Form.ResizeBegin>和<xref:System.Windows.Forms.Form.ResizeEnd>当用户移动窗体中，通常通过单击和拖动在标题栏上，也会引发的事件对。 生成这些事件不通过以编程方式操作的窗体，例如通过更改<xref:System.Windows.Forms.Form.Size%2A>或<xref:System.Windows.Forms.Control.Location%2A>属性。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何将此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Form.ResizeBegin>事件。 此报告可帮助您了解事件发生的并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑更换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或将消息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.Form>名为`Form1`。 然后，确保事件处理程序相关联<xref:System.Windows.Forms.Form.ResizeBegin>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#404](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#404)]
 [!code-vb[System.Windows.Forms.EventExamples#404](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#404)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnResizeBegin(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Form.AutoSize" />
        <altmember cref="P:System.Windows.Forms.Form.ClientSize" />
        <altmember cref="P:System.Windows.Forms.Form.DesktopBounds" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
        <altmember cref="P:System.Windows.Forms.Form.MaximumSize" />
        <altmember cref="P:System.Windows.Forms.Form.MinimumSize" />
        <altmember cref="P:System.Windows.Forms.Control.PreferredSize" />
        <altmember cref="P:System.Windows.Forms.Form.Size" />
        <altmember cref="P:System.Windows.Forms.Form.SizeGripStyle" />
        <altmember cref="E:System.Windows.Forms.Control.Click" />
        <altmember cref="E:System.Windows.Forms.Control.Resize" />
        <altmember cref="E:System.Windows.Forms.Form.ResizeEnd" />
        <altmember cref="E:System.Windows.Forms.Control.SizeChanged" />
      </Docs>
    </Member>
    <Member MemberName="ResizeEnd">
      <MemberSignature Language="C#" Value="public event EventHandler ResizeEnd;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ResizeEnd" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.ResizeEnd" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResizeEnd As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ResizeEnd;" />
      <MemberSignature Language="F#" Value="member this.ResizeEnd : EventHandler " Usage="member this.ResizeEnd : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>窗体退出大小调整模式时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ResizeEnd>用户完成调整大小操作窗体中，通常通过拖动其中一个边框或大小调整手柄位于右下角的窗体，然后将其释放时引发事件。 有关在调整操作的详细信息，请参阅<xref:System.Windows.Forms.Form.ResizeBegin>事件。  
  
 <xref:System.Windows.Forms.Form.ResizeEnd>之后用户移动窗体中，通常通过单击和拖动在标题栏上，也会生成事件。 此事件不由生成以编程方式操作的窗体，例如通过更改<xref:System.Windows.Forms.Form.Size%2A>或<xref:System.Windows.Forms.Control.Location%2A>属性。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何将此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Form.ResizeEnd>事件。 此报告可帮助您了解事件发生的并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑更换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或将消息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.Form>名为`Form1`。 然后，确保事件处理程序相关联<xref:System.Windows.Forms.Form.ResizeEnd>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#405](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#405)]
 [!code-vb[System.Windows.Forms.EventExamples#405](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#405)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnResizeEnd(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Form.AutoSize" />
        <altmember cref="P:System.Windows.Forms.Form.ClientSize" />
        <altmember cref="P:System.Windows.Forms.Form.DesktopBounds" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
        <altmember cref="P:System.Windows.Forms.Form.MaximumSize" />
        <altmember cref="P:System.Windows.Forms.Form.MinimumSize" />
        <altmember cref="P:System.Windows.Forms.Control.PreferredSize" />
        <altmember cref="P:System.Windows.Forms.Form.Size" />
        <altmember cref="P:System.Windows.Forms.Form.SizeGripStyle" />
        <altmember cref="E:System.Windows.Forms.Control.Click" />
        <altmember cref="E:System.Windows.Forms.Control.Resize" />
        <altmember cref="E:System.Windows.Forms.Form.ResizeBegin" />
        <altmember cref="E:System.Windows.Forms.Control.SizeChanged" />
      </Docs>
    </Member>
    <Member MemberName="RestoreBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle RestoreBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle RestoreBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.RestoreBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestoreBounds As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle RestoreBounds { System::Drawing::Rectangle get(); };" />
      <MemberSignature Language="F#" Value="member this.RestoreBounds : System.Drawing.Rectangle" Usage="System.Windows.Forms.Form.RestoreBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取窗体在其正常窗口状态下的位置和大小。</summary>
        <value><see cref="T:System.Drawing.Rectangle" />，包含窗体在正常窗口状态下的位置和大小。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常情况下，使用<xref:System.Windows.Forms.Form.RestoreBounds%2A>属性来跟踪用户的窗口大小和位置在其正常窗口状态的窗体的首选项。 您应该跟踪的值<xref:System.Windows.Forms.Form.WindowState%2A>和<xref:System.Windows.Forms.Form.RestoreBounds%2A>属性跟踪用户的窗口首选项时。  
  
> [!NOTE]
>  值<xref:System.Windows.Forms.Form.RestoreBounds%2A>属性是仅当<xref:System.Windows.Forms.Form.WindowState%2A>的属性<xref:System.Windows.Forms.Form>类不是等于<xref:System.Windows.Forms.FormWindowState.Normal>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RightToLeftLayout">
      <MemberSignature Language="C#" Value="public virtual bool RightToLeftLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RightToLeftLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.RightToLeftLayout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property RightToLeftLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool RightToLeftLayout { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RightToLeftLayout : bool with get, set" Usage="System.Windows.Forms.Form.RightToLeftLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否打开从右向左的镜像放置。</summary>
        <value>如果打开了从右到左的镜像放置，则为 <see langword="true" />；否则对于标准子控件放置，为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.RightToLeftLayout%2A>属性是主要用于开发适用于全球用户的全球通用的窗体。 许多窗体的设计，以便以从左到右的方式在窗体上布置控件。 这些窗体都遵循这种书写方向的语言与兼容。 但是，当向右到左的语言的用户显示的相同窗体，通常最好是反转窗体上控件的顺序。 如果这两个<xref:System.Windows.Forms.Form.RightToLeftLayout%2A>并<xref:System.Windows.Forms.Control.RightToLeft%2A>属性是`true`，镜像将打开的窗体，并且将从右到左控件位置和文本流。  
  
 与不同<xref:System.Windows.Forms.Control.RightToLeft%2A>，<xref:System.Windows.Forms.Form.RightToLeftLayout%2A>不会继承。 如果你想才会生效的子控件，必须将其设置的每个要镜像的子控件。  
  
 不是所有者描述支持何时<xref:System.Windows.Forms.Form.RightToLeftLayout%2A>设置为`Yes`。 所有者 draw 事件仍会发生，但未定义这些事件中编写任何代码的行为。 此外， <xref:System.Windows.Forms.Control.BackgroundImage%2A>， <xref:System.Windows.Forms.Form.Opacity%2A>， <xref:System.Windows.Forms.Form.TransparencyKey%2A>，和不支持的绘制事件。  
  
 <xref:System.Windows.Forms.Form.RightToLeftLayout%2A>和<xref:System.Windows.Forms.Control.RightToLeft%2A>属性会导致以下 Windows API 窗口样式设置：  
  
-   当<xref:System.Windows.Forms.Control.RightToLeft%2A>设置为`Yes`并<xref:System.Windows.Forms.Form.RightToLeftLayout%2A>设置为`true`，Windows 窗体设置`WS_EX_LAYOUTRTL`窗口样式，并删除`WS_EX_RIGHT`和`WS_EX_RTLREADING`样式。  
  
-   当<xref:System.Windows.Forms.Control.RightToLeft%2A>设置为`Yes`但<xref:System.Windows.Forms.Form.RightToLeftLayout%2A>设置为`No`，Windows 窗体设置`WS_EX_RIGHT`和`WS_EX_RTLREADING`窗口样式。  
  
 更改此属性的值将引发<xref:System.Windows.Forms.Form.RightToLeftLayoutChanged>事件。  
  
 全球化问题的详细信息，请参阅[开发全球通用应用程序的最佳实践](~/docs/standard/globalization-localization/best-practices-for-developing-world-ready-apps.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="Overload:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="E:System.Windows.Forms.Form.RightToLeftLayoutChanged" />
      </Docs>
    </Member>
    <Member MemberName="RightToLeftLayoutChanged">
      <MemberSignature Language="C#" Value="public event EventHandler RightToLeftLayoutChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler RightToLeftLayoutChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.RightToLeftLayoutChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RightToLeftLayoutChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ RightToLeftLayoutChanged;" />
      <MemberSignature Language="F#" Value="member this.RightToLeftLayoutChanged : EventHandler " Usage="member this.RightToLeftLayoutChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>更改 <see cref="P:System.Windows.Forms.Form.RightToLeftLayout" /> 属性值之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.RightToLeft%2A>和<xref:System.Windows.Forms.Form.RightToLeftLayout%2A>中开发全球通用应用程序通常使用属性。  
  
   
  
## Examples  
 下面的代码示例演示如何将此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Form.RightToLeftLayoutChanged>事件。 此报告可帮助您了解事件发生的并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑更换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或将消息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.Form>名为`Form1`。 然后，确保事件处理程序相关联<xref:System.Windows.Forms.Form.RightToLeftLayoutChanged>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#402](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#402)]
 [!code-vb[System.Windows.Forms.EventExamples#402](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#402)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.RightToLeftLayout" />
        <altmember cref="M:System.Windows.Forms.Form.OnRightToLeftLayoutChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="ScaleControl">
      <MemberSignature Language="C#" Value="protected override void ScaleControl (System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ScaleControl(valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ScaleControl (factor As SizeF, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ScaleControl(System::Drawing::SizeF factor, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="override this.ScaleControl : System.Drawing.SizeF * System.Windows.Forms.BoundsSpecified -&gt; unit" Usage="form.ScaleControl (factor, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factor" Type="System.Drawing.SizeF" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="factor">控件高度和宽度的缩放因子。</param>
        <param name="specified">一个 <see cref="T:System.Windows.Forms.BoundsSpecified" /> 值，指定在定义控件的大小和位置时要使用的控件边界。</param>
        <summary>缩放控件的位置、大小、空白和边距。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleCore">
      <MemberSignature Language="C#" Value="protected override void ScaleCore (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ScaleCore(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ScaleCore(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ScaleCore (x As Single, y As Single)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ScaleCore(float x, float y);" />
      <MemberSignature Language="F#" Value="override this.ScaleCore : single * single -&gt; unit" Usage="form.ScaleCore (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">水平缩放窗体的百分比</param>
        <param name="y">垂直缩放窗体的百分比</param>
        <summary>执行窗体缩放操作。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.ScaleCore(System.Single,System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="protected override void Select (bool directed, bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Select(bool directed, bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Select(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Select (directed As Boolean, forward As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Select(bool directed, bool forward);" />
      <MemberSignature Language="F#" Value="override this.Select : bool * bool -&gt; unit" Usage="form.Select (directed, forward)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directed" Type="System.Boolean" />
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="directed">如果设置为 true，则更改活动控件</param>
        <param name="forward">如果 directed 为 true，则它控制焦点移动的方向。 如果此项为 <see langword="true" />，则下一个控件被选定；否则，上一个控件被选定。</param>
        <summary>选择此窗体，并且可以选择下一个或上一个控件。</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">用于更改焦点。 关联枚举：<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="SetBoundsCore">
      <MemberSignature Language="C#" Value="protected override void SetBoundsCore (int x, int y, int width, int height, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetBoundsCore(int32 x, int32 y, int32 width, int32 height, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetBoundsCore (x As Integer, y As Integer, width As Integer, height As Integer, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetBoundsCore(int x, int y, int width, int height, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="override this.SetBoundsCore : int * int * int * int * System.Windows.Forms.BoundsSpecified -&gt; unit" Usage="form.SetBoundsCore (x, y, width, height, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="x">控件的新 <see cref="P:System.Windows.Forms.Control.Left" /> 属性值。</param>
        <param name="y">控件的新 <see cref="P:System.Windows.Forms.Control.Top" /> 属性值。</param>
        <param name="width">控件的新 <see cref="P:System.Windows.Forms.Control.Width" /> 属性值。</param>
        <param name="height">控件的新 <see cref="P:System.Windows.Forms.Control.Height" /> 属性值。</param>
        <param name="specified"><see cref="T:System.Windows.Forms.BoundsSpecified" /> 值的按位组合。</param>
        <summary>执行设置该控件的指定边界的工作。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      </Docs>
    </Member>
    <Member MemberName="SetClientSizeCore">
      <MemberSignature Language="C#" Value="protected override void SetClientSizeCore (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetClientSizeCore(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetClientSizeCore(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetClientSizeCore (x As Integer, y As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetClientSizeCore(int x, int y);" />
      <MemberSignature Language="F#" Value="override this.SetClientSizeCore : int * int -&gt; unit" Usage="form.SetClientSizeCore (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">请求的工作区宽度。</param>
        <param name="y">请求的工作区高度。</param>
        <summary>设置窗体的工作区大小。 这将调整窗体的界限，以将工作区大小设置为请求的大小。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Form.ClientSize" />
      </Docs>
    </Member>
    <Member MemberName="SetDesktopBounds">
      <MemberSignature Language="C#" Value="public void SetDesktopBounds (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDesktopBounds(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetDesktopBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDesktopBounds (x As Integer, y As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDesktopBounds(int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.SetDesktopBounds : int * int * int * int -&gt; unit" Usage="form.SetDesktopBounds (x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">窗体位置的 x 坐标。</param>
        <param name="y">窗体位置的 y 坐标。</param>
        <param name="width">窗体的宽度。</param>
        <param name="height">窗体的高度。</param>
        <summary>以桌面坐标设置窗体的边界。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 桌面坐标相对于屏幕，其中不包括任务栏的工作区。 此方法可用于设置在桌面上的位置和你的窗体的大小。 因为桌面坐标基于窗体的工作区，可以使用此方法以确保你的窗体是完全在桌面上可见。  
  
   
  
## Examples  
 下面的代码示例演示了如何使用<xref:System.Windows.Forms.Form.SetDesktopBounds%2A>方法。 若要运行此示例中，粘贴以下代码中包含名为的按钮的窗体`Button2`。 请确保所有事件都都具有其事件处理程序相关联。  
  
 [!code-cpp[System.Windows.Forms.FormExample#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormExample/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.FormExample#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormExample/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.FormExample#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormExample/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.SetDesktopLocation(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SetDesktopLocation">
      <MemberSignature Language="C#" Value="public void SetDesktopLocation (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDesktopLocation(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetDesktopLocation(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDesktopLocation (x As Integer, y As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDesktopLocation(int x, int y);" />
      <MemberSignature Language="F#" Value="member this.SetDesktopLocation : int * int -&gt; unit" Usage="form.SetDesktopLocation (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">窗体位置的 x 坐标。</param>
        <param name="y">窗体位置的 y 坐标。</param>
        <summary>以桌面坐标设置窗体的位置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 桌面坐标相对于屏幕，其中不包括任务栏的工作区。 此方法可用于在桌面上定位你的窗体。 因为桌面坐标基于窗体的工作区，可以使用此方法以确保你的窗体是完全在桌面上可见。 此方法应主要用于顶级窗体;使用<xref:System.Windows.Forms.Form.LayoutMdi%2A>方法来定位多文档界面 (MDI) 子窗体。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.Form.SetDesktopLocation%2A>，<xref:System.Windows.Forms.Form.Load>和<xref:System.Windows.Forms.Form.Activate%2A>成员。 若要运行该示例，请将以下代码粘贴在一个称为窗体`Form1`包含一个按钮调用`Button1`并将两个`Label`控件称为`Label1`和`Label2`。  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.SetDesktopBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.Form.LayoutMdi(System.Windows.Forms.MdiLayout)" />
      </Docs>
    </Member>
    <Member MemberName="SetVisibleCore">
      <MemberSignature Language="C#" Value="protected override void SetVisibleCore (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetVisibleCore(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetVisibleCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetVisibleCore (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetVisibleCore(bool value);" />
      <MemberSignature Language="F#" Value="override this.SetVisibleCore : bool -&gt; unit" Usage="form.SetVisibleCore value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value"><see langword="true" /> 表示使控件可见；<see langword="false" /> 表示使控件不可见。</param>
        <summary>将控件设置为指定的可见状态。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show (System.Windows.Forms.IWin32Window owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show(class System.Windows.Forms.IWin32Window owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Show(System.Windows.Forms.IWin32Window)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Show (owner As IWin32Window)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Show(System::Windows::Forms::IWin32Window ^ owner);" />
      <MemberSignature Language="F#" Value="override this.Show : System.Windows.Forms.IWin32Window -&gt; unit" Usage="form.Show owner" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owner" Type="System.Windows.Forms.IWin32Window" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="owner">任何实现 <see cref="T:System.Windows.Forms.IWin32Window" /> 并表示将拥有此窗体的顶级窗口的对象。</param>
        <summary>向用户显示具有指定所有者的窗体。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可用于显示非模式窗体。 使用此方法时<xref:System.Windows.Forms.Form.Owner%2A>窗体的属性设置为`owner`。 可以使用非模式形式<xref:System.Windows.Forms.Form.Owner%2A>属性以获取有关所属的窗体的信息。  调用此方法等同于设置<xref:System.Windows.Forms.Form.Owner%2A>的非模式的属性，然后再调用<xref:System.Windows.Forms.Control.Show>方法。  
  
 显示窗体等效于设置<xref:System.Windows.Forms.Control.Visible%2A>属性设置为`true`。 之后<xref:System.Windows.Forms.Form.Show%2A>调用方法时，<xref:System.Windows.Forms.Control.Visible%2A>属性返回的值`true`直到<xref:System.Windows.Forms.Control.Hide%2A>调用方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">要显示的窗体已经可见。  
  
- 或 - 
<paramref name="owner" /> 参数中指定的窗体就是显示的窗体。  
  
- 或 - 
所显示窗体被禁用。  
  
- 或 - 
显示的窗体不是顶级窗口。  
  
- 或 - 
显示为对话框的窗体已经是模式窗体。  
  
- 或 - 
当前进程不是以用户交互模式运行的（有关更多信息，请参见 <see cref="P:System.Windows.Forms.SystemInformation.UserInteractive" />）。</exception>
        <altmember cref="Overload:System.Windows.Forms.Form.ShowDialog" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="P:System.Windows.Forms.Form.WindowState" />
        <altmember cref="P:System.Windows.Forms.Form.ShowInTaskbar" />
        <altmember cref="P:System.Windows.Forms.Form.ShowIcon" />
        <altmember cref="E:System.Windows.Forms.Form.Shown" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ShowDialog">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将窗体显示为模式对话框。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ShowDialog">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DialogResult ShowDialog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Forms.DialogResult ShowDialog() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ShowDialog" />
      <MemberSignature Language="VB.NET" Value="Public Function ShowDialog () As DialogResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::DialogResult ShowDialog();" />
      <MemberSignature Language="F#" Value="member this.ShowDialog : unit -&gt; System.Windows.Forms.DialogResult" Usage="form.ShowDialog " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DialogResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将窗体显示为模式对话框。</summary>
        <returns><see cref="T:System.Windows.Forms.DialogResult" /> 值之一。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可用于在应用程序中显示模式对话框。 调用此方法时，其后的代码对话框的关闭后不执行之前。 对话框中可分配的值之一<xref:System.Windows.Forms.DialogResult>通过将其分配给枚举<xref:System.Windows.Forms.Button.DialogResult%2A>的属性<xref:System.Windows.Forms.Button>窗体上或通过设置<xref:System.Windows.Forms.Form.DialogResult%2A>的代码中的窗体的属性。 然后通过此方法返回此值。 可以使用此返回值来确定如何处理发生在对话框中的操作。 例如，如果对话框已关闭，并且返回`DialogResult.Cancel`值通过此方法中，你可以阻止之后到调用代码<xref:System.Windows.Forms.Form.ShowDialog%2A>执行。  
  
 当窗体显示为模式对话框中时，单击**关闭**按钮 （与窗体的右上角的 X 按钮） 后，窗体会被隐藏，<xref:System.Windows.Forms.Form.DialogResult%2A>属性设置为`DialogResult.Cancel`。 与非模式窗体不同<xref:System.Windows.Forms.Form.Close%2A>当用户单击关闭窗体按钮的对话框中，或设置的值不由.NET Framework 调用方法<xref:System.Windows.Forms.Form.DialogResult%2A>属性。 而是窗体处于隐藏状态，而无需创建新实例对话框的可再次显示。 因为窗体显示为对话框中隐藏的而不是已关闭，则必须调用<xref:System.Windows.Forms.Control.Dispose%2A>窗体时应用程序不再需要在窗体的方法。  
  
 此版本的<xref:System.Windows.Forms.Form.ShowDialog%2A>方法没有指定窗体或控件作为其所有者。 当调用此版本时，当前处于活动状态的窗口进行对话框的所有者。 如果你想要指定特定的所有者，则使用此方法的其他版本。  
  
   
  
## Examples  
 下面的代码示例显示作为模式对话框窗体和计算，然后确定是否读取的值对话框的的返回值<xref:System.Windows.Forms.TextBox>对话框窗体上的控件。 此示例需要<xref:System.Windows.Forms.Form>名为`testDialog`创建和它所包含<xref:System.Windows.Forms.TextBox>控件命名为`TextBox1`。 此外，该示例需要在此示例中的代码是包含和名为来自不同<xref:System.Windows.Forms.Form>以便显示`testDialog`为模式对话框。 此示例使用的版本<xref:System.Windows.Forms.Form.ShowDialog%2A>指定所有者为对话框的。  
  
 [!code-cpp[Classic Form.ShowDialog Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ShowDialog Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ShowDialog Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ShowDialog Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ShowDialog Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ShowDialog Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">要显示的窗体已经可见。  
  
- 或 - 
所显示窗体被禁用。  
  
- 或 - 
显示的窗体不是顶级窗口。  
  
- 或 - 
显示为对话框的窗体已经是模式窗体。  
  
- 或 - 
当前进程不是以用户交互模式运行的（有关更多信息，请参见 <see cref="P:System.Windows.Forms.SystemInformation.UserInteractive" />）。</exception>
        <altmember cref="P:System.Windows.Forms.Form.DialogResult" />
      </Docs>
    </Member>
    <Member MemberName="ShowDialog">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DialogResult ShowDialog (System.Windows.Forms.IWin32Window owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Forms.DialogResult ShowDialog(class System.Windows.Forms.IWin32Window owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ShowDialog(System.Windows.Forms.IWin32Window)" />
      <MemberSignature Language="VB.NET" Value="Public Function ShowDialog (owner As IWin32Window) As DialogResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::DialogResult ShowDialog(System::Windows::Forms::IWin32Window ^ owner);" />
      <MemberSignature Language="F#" Value="member this.ShowDialog : System.Windows.Forms.IWin32Window -&gt; System.Windows.Forms.DialogResult" Usage="form.ShowDialog owner" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DialogResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owner" Type="System.Windows.Forms.IWin32Window" />
      </Parameters>
      <Docs>
        <param name="owner">任何实现 <see cref="T:System.Windows.Forms.IWin32Window" />（表示将拥有模式对话框的顶级窗口）的对象。</param>
        <summary>将窗体显示为具有指定所有者的模式对话框。</summary>
        <returns><see cref="T:System.Windows.Forms.DialogResult" /> 值之一。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可用于在应用程序中显示模式对话框。 调用此方法时，其后的代码对话框的关闭后不执行之前。 对话框中可分配的值之一<xref:System.Windows.Forms.DialogResult>通过将其分配给<xref:System.Windows.Forms.Button.DialogResult%2A>的属性<xref:System.Windows.Forms.Button>窗体上或通过设置<xref:System.Windows.Forms.Form.DialogResult%2A>的代码中的窗体的属性。 然后通过此方法返回此值。 可以使用此返回值来确定如何处理发生在对话框中的操作。 例如，如果对话框已关闭，并且返回`DialogResult.Cancel`值通过此方法中，你可以阻止之后到调用代码<xref:System.Windows.Forms.Form.ShowDialog%2A>执行。  
  
 当窗体显示为模式对话框中时，单击**关闭**按钮 （与窗体的右上角的 X 按钮） 后，窗体会被隐藏，<xref:System.Windows.Forms.Form.DialogResult%2A>属性设置为`DialogResult.Cancel`。 与无模式窗体不同<xref:System.Windows.Forms.Form.Close%2A>当用户单击关闭窗体按钮的对话框中，或设置的值不由.NET Framework 调用方法<xref:System.Windows.Forms.Form.DialogResult%2A>属性。 而是窗体处于隐藏状态，而无需创建新实例对话框的可再次显示。 因为窗体显示为对话框中隐藏的而不是已关闭，则必须调用<xref:System.Windows.Forms.Control.Dispose%2A>窗体时应用程序不再需要在窗体的方法。  
  
 此版本的<xref:System.Windows.Forms.Form.ShowDialog%2A>方法，可指定特定的窗体将拥有所示的对话框。  
  
   
  
## Examples  
 下面的代码示例显示作为模式对话框窗体和计算，然后确定是否读取的值对话框的的返回值<xref:System.Windows.Forms.TextBox>对话框窗体上的控件。 此示例需要<xref:System.Windows.Forms.Form>名为`Form2`创建和它所包含<xref:System.Windows.Forms.TextBox>控件命名为`TextBox1`。 此示例使用的版本<xref:System.Windows.Forms.Form.ShowDialog%2A>指定所有者为对话框的。  
  
 [!code-cpp[Classic Form.ShowDialog Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ShowDialog Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ShowDialog Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ShowDialog Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ShowDialog Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ShowDialog Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="owner" /> 参数中指定的窗体就是显示的窗体。</exception>
        <exception cref="T:System.InvalidOperationException">要显示的窗体已经可见。  
  
- 或 - 
所显示窗体被禁用。  
  
- 或 - 
显示的窗体不是顶级窗口。  
  
- 或 - 
显示为对话框的窗体已经是模式窗体。  
  
- 或 - 
当前进程不是以用户交互模式运行的（有关更多信息，请参见 <see cref="P:System.Windows.Forms.SystemInformation.UserInteractive" />）。</exception>
        <altmember cref="P:System.Windows.Forms.Form.DialogResult" />
      </Docs>
    </Member>
    <Member MemberName="ShowIcon">
      <MemberSignature Language="C#" Value="public bool ShowIcon { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowIcon" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ShowIcon" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowIcon As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowIcon { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowIcon : bool with get, set" Usage="System.Windows.Forms.Form.ShowIcon" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否在窗体的标题栏中显示图标。</summary>
        <value>如果窗体在标题栏中显示图标，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ShowIcon%2A>属性包含<xref:System.Boolean>值，该值指示是否在窗体的<xref:System.Windows.Forms.Form.Icon%2A>窗体的标题栏中显示。 如果<xref:System.Windows.Forms.Form.ControlBox%2A>属性是`false`，将禁止显示的图标和控件框。  
  
 如果<xref:System.Windows.Forms.Form.ShowIcon%2A>是`false`主窗体显示时，将应用程序在任务栏按钮中显示通用图标。  
  
 此属性如果不起作用<xref:System.Windows.Forms.Form.FormBorderStyle%2A>设置为<xref:System.Windows.Forms.FormBorderStyle.FixedDialog>。 在这种情况下，窗体不显示一个图标。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.Icon" />
        <altmember cref="P:System.Windows.Forms.Form.ShowInTaskbar" />
        <altmember cref="P:System.Windows.Forms.Form.FormBorderStyle" />
        <altmember cref="P:System.Windows.Forms.Form.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbar">
      <MemberSignature Language="C#" Value="public bool ShowInTaskbar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowInTaskbar" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ShowInTaskbar" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowInTaskbar As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowInTaskbar { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowInTaskbar : bool with get, set" Usage="System.Windows.Forms.Form.ShowInTaskbar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否在 Windows 任务栏中显示窗体。</summary>
        <value>如果为 <see langword="true" />，则运行时在 Windows 任务栏中显示窗体；否则，为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果另一个窗体中为父窗体，该父窗体不会显示在 Windows 任务栏中。  
  
 此属性可用于防止用户选择通过 Windows 任务栏窗体。 例如，如果在应用程序中显示的查找和替换工具窗口，您可能想要防止该窗口被选中通过 Windows 任务栏，因为您将需要应用程序的主窗口和查找和替换工具窗口显示，以便适当地处理搜索。  
  
 您通常希望创建一个具有窗体时使用此属性<xref:System.Windows.Forms.FormBorderStyle.FixedToolWindow>样式。 设置<xref:System.Windows.Forms.FormBorderStyle.FixedToolWindow>样式不单独保证该窗口不会出现在任务栏中。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.Form.ShowInTaskbar%2A>属性以使框的对话框不显示在 Windows 任务栏中。  
  
 [!code-cpp[Form.ShowInTaskbar#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.ShowInTaskbar/CPP/form1.cpp#1)]
 [!code-csharp[Form.ShowInTaskbar#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.ShowInTaskbar/CS/form1.cs#1)]
 [!code-vb[Form.ShowInTaskbar#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.ShowInTaskbar/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shown">
      <MemberSignature Language="C#" Value="public event EventHandler Shown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Shown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Shown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Shown As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Shown;" />
      <MemberSignature Language="F#" Value="member this.Shown : EventHandler " Usage="member this.Shown : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>只要窗体是首次显示就发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.Shown>第一次显示一个窗体仅引发事件; 随后降至最低、 最大化、 还原、 隐藏、 显示，或使无效并重新绘制不会引发此事件。 窗体的事件的顺序的详细信息，请参阅[在 Windows 窗体中的事件顺序的](~/docs/framework/winforms/order-of-events-in-windows-forms.md)。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何将此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Form.Shown>事件。 此报告可帮助您了解事件发生的并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑更换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或将消息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.Form>名为`Form1`。 然后，确保事件处理程序相关联<xref:System.Windows.Forms.Form.Shown>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#403](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#403)]
 [!code-vb[System.Windows.Forms.EventExamples#403](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#403)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" />
        <altmember cref="Overload:System.Windows.Forms.Form.Show" />
        <altmember cref="M:System.Windows.Forms.Form.Close" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
        <altmember cref="E:System.Windows.Forms.Form.Load" />
        <altmember cref="E:System.Windows.Forms.Form.Activated" />
        <altmember cref="E:System.Windows.Forms.Form.FormClosing" />
        <altmember cref="E:System.Windows.Forms.Form.FormClosed" />
        <altmember cref="M:System.Windows.Forms.Form.LayoutMdi(System.Windows.Forms.MdiLayout)" />
        <altmember cref="E:System.Windows.Forms.Control.Paint" />
      </Docs>
    </Member>
    <Member MemberName="ShowWithoutActivation">
      <MemberSignature Language="C#" Value="protected virtual bool ShowWithoutActivation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowWithoutActivation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ShowWithoutActivation" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property ShowWithoutActivation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool ShowWithoutActivation { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ShowWithoutActivation : bool" Usage="System.Windows.Forms.Form.ShowWithoutActivation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示显示窗口时是否激活它。</summary>
        <value>如果显示窗口时不将其激活，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果想要显示的顶级窗口中，但不想要通过输入的焦点离开当前窗口会中断用户的工作，请使用此属性。 这可以是信息性的弹出窗口或浮动窗口中，如画图应用程序中的工具调色板。  
  
 此属性是只读的因为您只能更改其值通过重写<xref:System.Windows.Forms.Form.ShowWithoutActivation%2A>中自己的窗体，和它返回编程`true`。  
  
 如果您未激活的窗口需要使用 UI 控件，则应考虑使用<xref:System.Windows.Forms.ToolStrip>控件，如<xref:System.Windows.Forms.ToolStripDropDown>。 这些控件无窗口，并且不会导致在窗口中选择它们时激活。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Forms.Form.Show" />
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public System.Drawing.Size Size { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size Size" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Size" />
      <MemberSignature Language="VB.NET" Value="Public Property Size As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size Size { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.Size : System.Drawing.Size with get, set" Usage="System.Windows.Forms.Form.Size" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置窗体的大小。</summary>
        <value><see cref="T:System.Drawing.Size" />，它表示窗体的大小。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性可以设置而不是设置同时设置高度和宽度 （以像素为单位） 的窗体<xref:System.Windows.Forms.Control.Height%2A>和<xref:System.Windows.Forms.Control.Width%2A>属性单独。 如果你想要设置的大小和窗体的位置，则可以使用<xref:System.Windows.Forms.Form.DesktopBounds%2A>属性以调整大小和定位该窗体基于桌面坐标或使用<xref:System.Windows.Forms.Control.Bounds%2A>属性的<xref:System.Windows.Forms.Control>类来设置的大小和位置的窗体根据屏幕坐标inates。  
  
> [!NOTE]
>  此属性的最大值受限制的窗体在其运行的屏幕分辨率。 每个屏幕维度 （水平 + 12 和垂直 + 12） 不能大于 12 像素值。  
  
> [!NOTE]
>  在 Pocket PC 设备，可以创建可调整大小窗口通过设置<xref:System.Windows.Forms.Form.FormBorderStyle%2A>到`None`和删除任何<xref:System.Windows.Forms.MainMenu>控件。 可以在智能手机设备上您永远不会调整大小<xref:System.Windows.Forms.Form>-它将始终填充整个屏幕。  
  
   
  
## Examples  
 下面的代码示例演示如何创建带有 75%的不透明度级别显示的窗体。 示例代码将创建新的窗体，位于与屏幕的中央<xref:System.Windows.Forms.Form.Opacity%2A>属性设置为更改窗体的不透明度级别。 示例代码还设置<xref:System.Windows.Forms.Form.Size%2A>属性以提供更大大小超过默认大小的窗体的窗体。 此示例需要在此示例中定义的方法从另一种形式的事件处理程序或其他方法中调用。  
  
 [!code-cpp[Form.Opacity#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Opacity/CPP/form1.cpp#1)]
 [!code-csharp[Form.Opacity#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Opacity/CS/form1.cs#1)]
 [!code-vb[Form.Opacity#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Opacity/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Width" />
        <altmember cref="P:System.Windows.Forms.Control.Height" />
        <altmember cref="P:System.Windows.Forms.Form.DesktopBounds" />
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
      </Docs>
    </Member>
    <Member MemberName="SizeGripStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.SizeGripStyle SizeGripStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.SizeGripStyle SizeGripStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.SizeGripStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property SizeGripStyle As SizeGripStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::SizeGripStyle SizeGripStyle { System::Windows::Forms::SizeGripStyle get(); void set(System::Windows::Forms::SizeGripStyle value); };" />
      <MemberSignature Language="F#" Value="member this.SizeGripStyle : System.Windows.Forms.SizeGripStyle with get, set" Usage="System.Windows.Forms.Form.SizeGripStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.SizeGripStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在窗体右下角显示的大小调整手柄的样式。</summary>
        <value><see cref="T:System.Windows.Forms.SizeGripStyle" />，表示要显示的大小手柄的样式。 默认值为 <see cref="F:System.Windows.Forms.SizeGripStyle.Auto" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性可确定窗体上显示大小调整手柄时。 可以设置此属性以显示大小调整手柄或者使其自动显示基于设置的<xref:System.Windows.Forms.Form.FormBorderStyle%2A>属性。  
  
   
  
## Examples  
 下面的代码示例演示如何隐藏的大小手柄<xref:System.Windows.Forms.Form>时<xref:System.Windows.Forms.Form>不可调整大小。  
  
 [!code-cpp[Form.SizeGripStyle#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.SizeGripStyle/CPP/form1.cpp#1)]
 [!code-csharp[Form.SizeGripStyle#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.SizeGripStyle/CS/form1.cs#1)]
 [!code-vb[Form.SizeGripStyle#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.SizeGripStyle/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">指定值不在有效值范围内。</exception>
        <altmember cref="P:System.Windows.Forms.Form.FormBorderStyle" />
        <altmember cref="T:System.Windows.Forms.SizeGripStyle" />
      </Docs>
    </Member>
    <Member MemberName="StartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.FormStartPosition StartPosition { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.FormStartPosition StartPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.StartPosition" />
      <MemberSignature Language="VB.NET" Value="Public Property StartPosition As FormStartPosition" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::FormStartPosition StartPosition { System::Windows::Forms::FormStartPosition get(); void set(System::Windows::Forms::FormStartPosition value); };" />
      <MemberSignature Language="F#" Value="member this.StartPosition : System.Windows.Forms.FormStartPosition with get, set" Usage="System.Windows.Forms.Form.StartPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormStartPosition</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置运行时窗体的起始位置。</summary>
        <value><see cref="T:System.Windows.Forms.FormStartPosition" />，表示窗体的起始位置。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性可以在运行时显示时设置窗体的起始位置。 可以通过设置手动指定窗体的位置<xref:System.Windows.Forms.Form.Location%2A>属性或使用指定的 Windows 的默认位置。 您可以定位要显示在屏幕的中心或中心位置的窗体多文档界面 (MDI) 子窗体如其父窗体的窗体。  
  
 显示窗体之前，应设置此属性。  可以设置此属性，然后再调用<xref:System.Windows.Forms.Form.Show%2A>或<xref:System.Windows.Forms.Form.ShowDialog%2A>方法或在窗体的构造函数中。  
  
   
  
## Examples  
 下面的代码示例创建的新实例<xref:System.Windows.Forms.Form>，并调用<xref:System.Windows.Forms.Form.ShowDialog%2A>窗体显示为对话框中的方法。 该示例设置<xref:System.Windows.Forms.Form.FormBorderStyle%2A>， <xref:System.Windows.Forms.Form.AcceptButton%2A>， <xref:System.Windows.Forms.Form.CancelButton%2A>，和<xref:System.Windows.Forms.Form.StartPosition%2A>属性以更改到对话框的外观和功能的窗体。 此示例还使用<xref:System.Windows.Forms.Form.ControlCollection.Add%2A>窗体的方法<xref:System.Windows.Forms.Control.Controls%2A>集合来添加两个<xref:System.Windows.Forms.Button>控件。 该示例使用<xref:System.Windows.Forms.Form.HelpButton%2A>属性对话框中的标题栏中显示帮助按钮。  
  
 [!code-cpp[Classic Form.StartPosition Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.StartPosition Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.StartPosition Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.StartPosition Example/CS/source.cs#1)]
 [!code-vb[Classic Form.StartPosition Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.StartPosition Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">指定值不在有效值范围内。</exception>
        <altmember cref="T:System.Windows.Forms.FormStartPosition" />
      </Docs>
    </Member>
    <Member MemberName="TabIndex">
      <MemberSignature Language="C#" Value="public int TabIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TabIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TabIndex" />
      <MemberSignature Language="VB.NET" Value="Public Property TabIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int TabIndex { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.TabIndex : int with get, set" Usage="System.Windows.Forms.Form.TabIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置控件在其容器内的 Tab 键顺序。</summary>
        <value><see cref="T:System.Int32" />，它包含其容器内按 Tab 键顺序包括的控件集内的控件索引。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tab 键顺序不包括窗体。 设置<xref:System.Windows.Forms.Form.TabIndex%2A>属性不执行任何操作。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TabIndexChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TabIndexChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TabIndexChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.TabIndexChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TabIndexChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TabIndexChanged;" />
      <MemberSignature Language="F#" Value="member this.TabIndexChanged : EventHandler " Usage="member this.TabIndexChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 <see cref="P:System.Windows.Forms.Form.TabIndex" /> 属性的值更改时发生。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TabStop">
      <MemberSignature Language="C#" Value="public bool TabStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TabStop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TabStop" />
      <MemberSignature Language="VB.NET" Value="Public Property TabStop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TabStop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TabStop : bool with get, set" Usage="System.Windows.Forms.Form.TabStop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Runtime.InteropServices.DispId(-516)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示用户能否使用 Tab 键将焦点放到该控件上。</summary>
        <value>如果用户可以用 Tab 键将焦点放到此控件上，则为 <see langword="true" />；反之，则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TabStopChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TabStopChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TabStopChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.TabStopChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TabStopChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TabStopChanged;" />
      <MemberSignature Language="F#" Value="member this.TabStopChanged : EventHandler " Usage="member this.TabStopChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 <see cref="P:System.Windows.Forms.Form.TabStop" /> 属性更改时发生。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public override string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Text" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Forms.Form.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置与此控件关联的文本。</summary>
        <value>与该控件关联的文本。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.Text" />
      </Docs>
    </Member>
    <Member MemberName="TopLevel">
      <MemberSignature Language="C#" Value="public bool TopLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TopLevel" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TopLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property TopLevel As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TopLevel { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TopLevel : bool with get, set" Usage="System.Windows.Forms.Form.TopLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否将窗体显示为顶层窗口。</summary>
        <value>如果为 <see langword="true" />，则将窗体显示为顶级窗口；否则，为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 顶级窗体是对没有父窗体中，或者其父窗体是在桌面窗口的窗口。 顶级窗口通常用作应用程序中的主窗体。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Windows.Forms.Form.Modal%2A>属性来确定是否窗体显示为模式窗体。 如果不是<xref:System.Windows.Forms.Form.FormBorderStyle%2A>和<xref:System.Windows.Forms.Form.TopLevel%2A>属性发生更改以使工具窗口边框在窗体非顶级窗体。  
  
 [!code-cpp[Form.Modal#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Modal/CPP/form1.cpp#1)]
 [!code-csharp[Form.Modal#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Modal/CS/form1.cs#1)]
 [!code-vb[Form.Modal#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Modal/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">多文档界面 (MDI) 父窗体必须是顶级窗口。</exception>
        <altmember cref="P:System.Windows.Forms.Form.TopMost" />
      </Docs>
    </Member>
    <Member MemberName="TopMost">
      <MemberSignature Language="C#" Value="public bool TopMost { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TopMost" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TopMost" />
      <MemberSignature Language="VB.NET" Value="Public Property TopMost As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TopMost { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TopMost : bool with get, set" Usage="System.Windows.Forms.Form.TopMost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，指示该窗体是否应显示为最顶层窗体。</summary>
        <value>如果将窗体显示为最顶层窗体，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 最顶层窗体是重叠的所有其他 （非最顶端） 窗体，即使它不处于活动状态或前景窗体的窗体。 最顶层窗体始终显示在桌面上窗口的 z 顺序中最高数据点。 此属性可用于创建始终在应用程序，如查找和替换工具窗口中显示的窗体。  
  
   
  
## Examples  
 下面的代码示例演示如何创建最顶层窗体。 该示例创建两个窗体，一个处于最大化，一个将显示为最顶层窗体。 第一个窗体，名为`bottomForm`，将显示最大化，请使用<xref:System.Windows.Forms.Form.WindowState%2A>属性，以更好地演示的最顶层窗体的能力。 第二个名为的窗体`topMostForm`，设置<xref:System.Windows.Forms.Form.TopMost%2A>属性设置为`true`窗体显示为最顶层窗体。 运行此代码时，单击最大化窗体上不会导致最顶层的窗体最大化窗体下显示。 该示例需要在示例中定义的方法称为从另一种形式。  
  
 [!code-cpp[Form.TopMost#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.TopMost/CPP/form1.cpp#1)]
 [!code-csharp[Form.TopMost#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.TopMost/CS/form1.cs#1)]
 [!code-vb[Form.TopMost#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.TopMost/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.TopLevel" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="form.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取表示当前窗体实例的字符串。</summary>
        <returns>由窗体对象类的完全限定名组成的字符串，窗体的 <see cref="P:System.Windows.Forms.Form.Text" /> 属性追加到字符串的末尾。 例如，如果该窗体派生自 <c>MyNamespace</c> 命名空间中的类 <c>MyForm</c>，并且 <see cref="P:System.Windows.Forms.Form.Text" /> 属性设置为 <c>Hello, World</c>，则此方法会返回 <c>MyNamespace.MyForm, Text:Hello, World</c>。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransparencyKey">
      <MemberSignature Language="C#" Value="public System.Drawing.Color TransparencyKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color TransparencyKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TransparencyKey" />
      <MemberSignature Language="VB.NET" Value="Public Property TransparencyKey As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color TransparencyKey { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.TransparencyKey : System.Drawing.Color with get, set" Usage="System.Windows.Forms.Form.TransparencyKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置将表示窗体透明区域的颜色。</summary>
        <value><see cref="T:System.Drawing.Color" />，表示要在窗体上透明显示的颜色。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Windows.Forms.Form.TransparencyKey%2A>属性分配<xref:System.Drawing.Color>，具有相同的窗体区域<xref:System.Windows.Forms.Control.BackColor%2A>将以透明方式显示。 任何鼠标操作，如单击鼠标，在窗体透明区域上执行会传输到下的透明区域的窗口。 例如，如果窗体的客户端区域进行透明的该区域上单击鼠标将将单击事件通知发送到其下方是任何窗口。 如果将颜色分配给<xref:System.Windows.Forms.Form.TransparencyKey%2A>属性等同于在窗体上任何控件，它们还将显示以透明方式。 例如，如果你有<xref:System.Windows.Forms.Button>具有窗体上的控件及其<xref:System.Windows.Forms.Form.TransparencyKey%2A>属性设置为`SystemColors.Control`，该控件将以透明方式显示，除非<xref:System.Windows.Forms.Control.BackColor%2A>属性<xref:System.Windows.Forms.Button>控件更改为另一种颜色。  
  
 此属性不是支持何时<xref:System.Windows.Forms.Form.RightToLeftLayout%2A>是`true`。  
  
   
  
## Examples  
 下面的代码示例创建具有透明的客户端区域，而不考虑窗体的背景色的窗口。 此示例需要示例方法在窗体类中定义。  
  
 [!code-cpp[Classic Form.TransparencyKey Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.TransparencyKey Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.TransparencyKey Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.TransparencyKey Example/CS/source.cs#1)]
 [!code-vb[Classic Form.TransparencyKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.TransparencyKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultButton">
      <MemberSignature Language="C#" Value="protected override void UpdateDefaultButton ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void UpdateDefaultButton() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.UpdateDefaultButton" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub UpdateDefaultButton ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void UpdateDefaultButton();" />
      <MemberSignature Language="F#" Value="override this.UpdateDefaultButton : unit -&gt; unit" Usage="form.UpdateDefaultButton " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>更新哪个按钮为默认按钮。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.UpdateDefaultButton%2A>方法确定窗体上的哪个按钮引发其 Click 事件，当用户按 ENTER，根据以下优先级：  
  
1.  如果<xref:System.Windows.Forms.ContainerControl.ActiveControl%2A>属性实现<xref:System.Windows.Forms.IButtonControl>接口，控件是默认按钮。  
  
2.  <xref:System.Windows.Forms.Form.AcceptButton%2A>属性是默认按钮。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.ContainerControl.ActiveControl" />
        <altmember cref="P:System.Windows.Forms.Form.AcceptButton" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ValidateChildren">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>验证窗体中所有可选择的子控件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ValidateChildren">
      <MemberSignature Language="C#" Value="public override bool ValidateChildren ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool ValidateChildren() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ValidateChildren" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ValidateChildren () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool ValidateChildren();" />
      <MemberSignature Language="F#" Value="override this.ValidateChildren : unit -&gt; bool" Usage="form.ValidateChildren " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使控件内支持验证的所有子控件都对其数据进行验证。</summary>
        <returns>如果成功验证所有子级，则为 <see langword="true" />；否则为 <see langword="false" />。 如果是从 <see cref="E:System.Windows.Forms.Control.Validating" /> 或 <see cref="E:System.Windows.Forms.Control.Validated" /> 事件处理程序调用的，则该方法将始终返回 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.ValidateChildren" />
      </Docs>
    </Member>
    <Member MemberName="ValidateChildren">
      <MemberSignature Language="C#" Value="public override bool ValidateChildren (System.Windows.Forms.ValidationConstraints validationConstraints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool ValidateChildren(valuetype System.Windows.Forms.ValidationConstraints validationConstraints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ValidateChildren(System.Windows.Forms.ValidationConstraints)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool ValidateChildren(System::Windows::Forms::ValidationConstraints validationConstraints);" />
      <MemberSignature Language="F#" Value="override this.ValidateChildren : System.Windows.Forms.ValidationConstraints -&gt; bool" Usage="form.ValidateChildren validationConstraints" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationConstraints" Type="System.Windows.Forms.ValidationConstraints" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="validationConstraints">添加对哪些控件可以引发其 <see cref="E:System.Windows.Forms.Control.Validating" /> 事件的限制。</param>
        <summary>使控件内支持验证的所有子控件都对其数据进行验证。</summary>
        <returns>如果成功验证所有子级，则为 <see langword="true" />；否则为 <see langword="false" />。 如果是从 <see cref="E:System.Windows.Forms.Control.Validating" /> 或 <see cref="E:System.Windows.Forms.Control.Validated" /> 事件处理程序调用的，则该方法将始终返回 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.ValidateChildren(System.Windows.Forms.ValidationConstraints)" />
      </Docs>
    </Member>
    <Member MemberName="WindowState">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.FormWindowState WindowState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.FormWindowState WindowState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.WindowState" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowState As FormWindowState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::FormWindowState WindowState { System::Windows::Forms::FormWindowState get(); void set(System::Windows::Forms::FormWindowState value); };" />
      <MemberSignature Language="F#" Value="member this.WindowState : System.Windows.Forms.FormWindowState with get, set" Usage="System.Windows.Forms.Form.WindowState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormWindowState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示窗体是最小化、最大化还是正常。</summary>
        <value><see cref="T:System.Windows.Forms.FormWindowState" />，它表示窗体是最小化、 最大化，还是正常。 默认值为 <see langword="FormWindowState.Normal" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 显示一个窗体之前，<xref:System.Windows.Forms.Form.WindowState%2A>属性始终设置为`FormWindowState.Normal`，无论其初始设置。 这反映在<xref:System.Windows.Forms.Control.Height%2A>， <xref:System.Windows.Forms.Control.Left%2A>， <xref:System.Windows.Forms.Control.Top%2A>，和<xref:System.Windows.Forms.Control.Width%2A>属性设置。 如果后已被证实隐藏窗体，这些属性反映以前的状态，直到再次，而不考虑进行的任何更改显示窗体<xref:System.Windows.Forms.Form.WindowState%2A>属性。  
  
   
  
## Examples  
 下面的代码示例演示如何设置<xref:System.Windows.Forms.Form.WindowState%2A>为最大化。 从调用的代码<xref:System.Windows.Forms.Form.Shown>事件处理程序后创建窗体。  
  
```csharp  
private void Form1_Shown(object sender, EventArgs e)  
        {  
            this.WindowState = System.Windows.Forms.FormWindowState.Maximized;  
        }  
```  
  
```vb  
Private  Sub Form1_Shown(ByVal sender As Object, ByVal e As EventArgs)  
            Me.WindowState = System.Windows.Forms.FormWindowState.Maximized  
End Sub  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">指定值不在有效值范围内。</exception>
        <altmember cref="T:System.Windows.Forms.FormWindowState" />
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected override void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.WndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub WndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void WndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="override this.WndProc :  -&gt; unit" Usage="form.WndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">要处理的 Windows <see cref="T:System.Windows.Forms.Message" />。</param>
        <summary>处理 Windows 消息。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.WndProc(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
  </Members>
</Type>